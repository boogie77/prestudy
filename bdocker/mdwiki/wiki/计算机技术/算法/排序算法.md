# 排序算法

所谓[排序](http://baike.baidu.com/item/%E6%8E%92%E5%BA%8F)，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。



## 排序算法说明

1. 排序的定义：对一序列对象根据某个关键字进行排序；

   - **输入**：n个数：$a_1,a_2,a_3,\cdots,a_n$
   - **输出**：n个数的排列：$a_1’,a_2’,a_3’,\cdots,a_n’$，使得$a1’ < a2’ < a3’ \cdots <a_n’$

   形象点就是排排坐，调座位，高的站在后面，矮的站在前面。


2. 对于评述算法优劣术语的说明
   - **稳定**：如果$a$原本在$b$前面，而$a=b$，排序之后$a$仍然在$b$的前面；
   - **不稳定**：如果$a$原本在$b$的前面，而$a=b$，排序之后$a$可能会出现在$b$的后面；
   - **内排序**：所有排序操作都在内存中完成；
   - **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
   - **时间复杂度**：一个算法执行所耗费的时间。
   - **空间复杂度**：运行完一个程序所需内存的大小。

关于时间空间复杂度的更多了解请戳[这里](http://blog.csdn.net/booirror/article/details/7707551/)，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。



## 排序算法比较

|        排序算法        |             平均时间复杂度              |         最好情况         |         最坏情况         |          空间复杂度          |   排序方式    | 稳定性  |
| :----------------: | :------------------------------: | :------------------: | :------------------: | :---------------------: | :-------: | :--: |
|  冒泡排序 BubbleSort   |             $O(n^2)$             |        $O(n)$        |       $O(n^2)$       |         $O(1)$          | In-place  |  稳定  |
| 选择排序 SelectionSort |             $O(n^2)$             |       $O(n^2)$       |       $O(n^2)$       |         $O(1)$          | In-place  | 不稳定  |
| 插入排序 InsertionSort |             $O(n^2)$             |        $O(n)$        |       $O(n^2)$       |         $O(1)$          | In-place  |  稳定  |
|   希尔排序 ShellSort   | $O(n \cdot log (n)) \sim O(n^2)$ |     $O(n^{1.3})$     |       $O(n^2)$       |         $O(1)$          | In-place  | 不稳定  |
|   归并排序 MergeSort   |       $O(n \cdot log (n))$       | $O(n \cdot log (n))$ | $O(n \cdot log (n))$ |         $O(n)$          | Out-place |  稳定  |
|   快速排序 QuickSort   |       $O(n \cdot log (n))$       | $O(n \cdot log (n))$ |       $O(n^2)$       | $O(log (n))  \sim O(n)$ | In-place  | 不稳定  |
|  堆排序     HeapSort  |       $O(n \cdot log (n))$       | $O(n \cdot log (n))$ | $O(n \cdot log (n))$ |         $O(1)$          | In-place  | 不稳定  |
| 计数排序 CountingSort  |             $O(n+k)$             |       $O(n+k)$       |       $O(n+k)$       |         $O(k)$          | Out-place |  稳定  |
|   桶排序 BucketSort   |             $O(n+k)$             |       $O(n+k)$       |       $O(n^2)$       |       $O(n + k)$        | Out-place |  稳定  |
|   基数排序 RadixSort   |         $O(n \times k)$          |   $O(n \times k)$    |   $O(n \times k)$    |        $O(n+k)$         | Out-place |  稳定  |

- n：数据规模
- k：“桶”的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存



## 冒泡排序 BubbleSort

冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。

### 算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个；
2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。



## 选择排序 SelectionSort

选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。通俗来说就是你们中间谁最小谁就出列，站到队列的最后边，然后继续对着剩余的无序数组说你们中间谁最小谁就出列，站到队列的最后边，一直到最后一个，继续站到最后边，这样数组就有了顺序，从小到大。

### 算法步骤

1.  首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；
2.  再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3.  重复第二步，直到所有元素均排序完毕。




## 插入排序 InsertionSort

**插入排序是一种简单直观的[排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 算法步骤

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）


**步骤：**

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

![](/img/InsertionSort-Example.gif)



## 希尔排序 ShellSort

希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。

希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。



## 归并排序 MergeSort

归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。

先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。

再考虑递归分解，基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。

归并排序，是创建在归并操作上的一种有效的排序算法，效率为$O(n \cdot log(n))$。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。

作为一种典型的分而治之思想的算法应用，归并排序的实现有两种方法：

1. 自上而下的递归；
2. 自下而上的迭代；

> 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：
>
> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.
>
> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是$O(n \cdot log(n))$的时间复杂度。代价是需要额外的内存空间。

### 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

![](/img/MergeSort-Example.gif)


## 快速排序 QuickSort

快速排序通常明显比同为$Ο(n \cdot log(n))$的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。

### 算法步骤

1. 从数列中挑出一个元素作为基准数。
2. 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。
3. 再对左右区间递归执行第二步，直至各区间只有一个数。

![](/img/QuickSort-Example.gif)

## 堆排序 HeapSort

堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。

二叉堆具有以下性质：

父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。

### 算法步骤

1. 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。
2. 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。
3. 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。

![](/img/HeapSort-Example.gif)

## 计数排序 CountingSort

计数排序利用了哈希的性质，将一个中间数组来记录数值对应的下标，最后查询对应的下标进行放置；

### 算法步骤

1. 找出待排序的数组中最小和最大值，计算最大和最小值之间的差值；
2. 计算每个数值出现的次数，接着进行累加计算出数值的位置；
3. 反向填充数组，根据查询下标找到位置后填充数值；

### 缺点和优点

利用了哈希的原理，其时间复杂度为n，但是这是用空间复杂度来换的，即便上面有进行过优化，但是面对一个较大值和较小值的数组，其仍然会对空间造成很大的浪费。



## 桶排序 BucketSort

桶排序的原理在于将数组分配到一定数量的桶中，每个桶在个别排序，最后合并排序。

### 缺点和优点

如果数组中的每个数值都会均匀的落入每个桶中，则其最优的时间复杂度在n，但是如果数值都集中的加入到固定的几个桶中，甚至是都落入一个桶中，那么这样在对数值进行插入排序的时候就变成了双层循环，则其最差时间复杂度为$O(n^2)$。



## 基数排序 RadixSort

将所有数值在每一位上面进行排序，排序方法利用计数排序的原理；

### 算法步骤

1. 计算数值中最大值的位数，用作后面比较的次数；
2. 计算所有数值在每一位上面的排序，参考计数排序；

### 缺点和优点

因为其下标在$0-10$之间，所以有效的控制了空间复杂度，但是其复杂度较计数排序增加了，明显其时间复杂度为￼￼￼$O(k \cdot n)$，$k$代表数字位数，这取决于数字位的选择，比如比特位数，其决定了要进行多少轮的处理；虽然增加了时间复杂度，但依旧比那些需要进行比较的排序算法较快一些。











































---