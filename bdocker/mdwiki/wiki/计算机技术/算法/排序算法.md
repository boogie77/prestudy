# 排序算法

常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。



## 排序算法比较

| 排序算法 |       平均时间复杂度        |          最好情况          |          最坏情况          |    空间复杂度     |   排序方式    | 稳定性  |
| :--: | :------------------: | :--------------------: | :--------------------: | :----------: | :-------: | :--: |
| 冒泡排序 |       $O(n^2)$       |         $O(n)$         |        $O(n^2)$        |    $O(1)$    | In-place  |  稳定  |
| 选择排序 |       $O(n^2)$       |        $O(n^2)$        |        $O(n^2)$        |    $O(1)$    | In-place  | 不稳定  |
| 插入排序 |       $O(n^2)$       |         $O(n)$         |        $O(n^2)$        |    $O(1)$    | In-place  |  稳定  |
| 希尔排序 | $O(n \cdot log (n))$ | $O(n \cdot log ^2(n))$ | $O(n \cdot log^2 (n))$ |    $O(1)$    | In-place  | 不稳定  |
| 归并排序 | $O(n \cdot log (n))$ |  $O(n \cdot log (n))$  |  $O(n \cdot log (n))$  |    $O(n)$    | Out-place |  稳定  |
| 快速排序 | $O(n \cdot log (n))$ |  $O(n \cdot log (n))$  |        $O(n^2)$        | $O(log (n))$ | In-place  | 不稳定  |
| 堆排序  | $O(n \cdot log (n))$ |  $O(n \cdot log (n))$  |  $O(n \cdot log (n))$  |    $O(1)$    | In-place  | 不稳定  |
| 计数排序 |       $O(n+k)$       |        $O(n+k)$        |        $O(n+k)$        |    $O(k)$    | Out-place |  稳定  |
| 桶排序  |       $O(n+k)$       |        $O(n+k)$        |        $O(n^2)$        |   $O(n+k)$   | Out-place |  稳定  |
| 基数排序 |   $O(n \times k)$    |    $O(n \times k)$     |    $O(n \times k)$     |   $O(n+k)$   | Out-place |  稳定  |





## 选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。通俗来说就是你们中间谁最小谁就出列，站到队列的最后边，然后继续对着剩余的无序数组说你们中间谁最小谁就出列，站到队列的最后边，一直到最后一个，继续站到最后边，这样数组就有了顺序，从小到大。

### 算法步骤

1.  首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2.  再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3.  重复第二步，直到所有元素均排序完毕。



## 插入排序

**插入排序**（英语：Insertion Sort）是一种简单直观的[排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**插入排序**在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 算法步骤

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）



## 归并排序

归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为$O(n \cdot log(n))$。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。

作为一种典型的分而治之思想的算法应用，归并排序的实现有两种方法：

1. 自上而下的递归；
2. 自下而上的迭代；

> 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：
>
> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.
>
> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是$O(n \cdot log(n))$的时间复杂度。代价是需要额外的内存空间。

### 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。































































---