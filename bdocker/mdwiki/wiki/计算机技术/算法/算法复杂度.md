# 算法复杂度

算法复杂度，即算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。算法的时间复杂度和空间复杂度合称为算法的复杂度。

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从[时间复杂度](http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)和[空间复杂度](http://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)来考虑。



## 时间复杂度

算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模$n$的函数$f(n)$，算法的时间复杂度也因此记做：$T(n)=Ο(f(n))$。因此，问题的规模$n$越大，算法执行的时间的增长率与$f(n)$的增长率正相关，称作[渐进时间复杂度](http://baike.baidu.com/item/%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)（Asymptotic Time Complexity）。

### 时间频度

算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数[成正比例](http://baike.baidu.com/item/%E6%88%90%E6%AD%A3%E6%AF%94%E4%BE%8B)，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记为 $T(n)$ 。算法的[时间复杂度](http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)是指执行算法所需要的计算工作量。

### 时间复杂度

在刚才提到的时间频度中，$n$称为问题的规模，当$n$不断变化时，时间频度$T(n)$也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。

一般情况下，算法中基本操作重复执行的次数是问题规模$n$的某个函数，用$T(n)$表示，若有某个辅助函数$f(n)$，使得当$n$趋近于无穷大时，$Tn)/f(n)$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)=Ｏ(f(n))$，称$Ｏ(f(n)) $为算法的渐进[时间复杂度](http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)，简称时间复杂度。

在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为$O(1)$，另外，在时间频度不相同时，时间复杂度有可能相同。

> 如：$T(n)=n^2+3n+4$与$T(n)=4n^2+2n+1$它们的频度不同，但时间复杂度相同，都为$O(n^2)$。

**按数量级递增排列，常见的时间复杂度**：

-   $O(1)$：常数阶
-   $O(log_2(n))$：对数阶
-   $O(n)$：线性阶
-   $O(n \cdot log_2(n))$：线性对数阶
-   $O(n^2)​$：平方阶
-   $O(n^3)$：立方阶
-   $\cdots$
-   $O(n^k)​$：$k​$次方阶
-   $O(2^n)$：指数阶

随着问题规模 $n$ 的不断增大，上述[时间复杂度](http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)不断增大，算法的执行效率越低。

### 最坏时间复杂度和平均时间复杂度

最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：**最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界**，这就保证了算法的运行时间不会比任何更长。

在最坏情况下的时间复杂度为 $T(n)=O(n)$ ，它表示对于任何输入实例，该算法的运行时间不可能大于 $O(n)$ 。 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。

显然，时间复杂度为指数阶 $O(2^n)$ 的算法效率极低，当 $n$ 值稍大时就无法应用。

### 求时间复杂度

-   如果算法的执行时间不随着问题规模 $n$ 的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是 $O(1)$ 。

    ```c++
    x=91;
    y=100;
    while(y>0)
      if(x>100) {
        x=x-10;
        y--;
      } else
        x++;
    ```

    > 解答： $T(n)=O(1)$
    >
    > 这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到 $n$ 没有？没。
    >
    > 这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数


-   当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度 $f(n)$ 决定的。

    ```c++
    x=1;
    for(i=1;i<=n;i++)
      for(j=1;j<=i;j++)
        for(k=1;k<=j;k++)
          x++;
    ```

    > 解答：该程序段中频度最大的语句是第5行，内循环的执行次数虽然与问题规模$n$没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与$n$有关，因此可以从内层循环向外层分析语句第5行的执行次数。
    >
    > 该程序段的时间复杂度为 $T(n)=O(n^3/6 + 低次项)=O(n^3)$

- 算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。

    在数值 $A[0 \cdots (n-1)]$ 中查找给定值$K$的算法大致如下：

    ```c++
    i=n-1;
    while(i>=0&&(A[i]!=k))
      i--;
    return i;
    ```

    > 此算法中的语句(3)的频度不仅与问题规模 $n$ 有关，还与输入实例中 $A$ 的各元素取值及 $K$ 的取值有关: ①若 $A$ 中没有与 $K$ 相等的元素，则语句(3)的频度 $f(n)=n$ ； ②若 $A$ 的最后一个元素等于 $K$ ，则语句(3)的频度 $f(n)$ 是常数 $0$ 。

### 时间复杂度评价性能

有两个算法 $A_1$ 和 $A_2$ 求解同一问题，时间复杂度分别是 $T_1(n)=100n^2$ ，$T_2(n)=5n^3$ 。

-   当输入量 $n＜20$ 时，有 $T_1(n)＞T_2(n)$ ，后者花费的时间较少。
-   随着问题规模 $n$ 的增大，两个算法的时间开销之比 $5n^3/100n^2=n/20$ 亦随着增大。即当问题规模较大时，算法 $A_1$ 比算法 $A_2$ 要有效地多。它们的渐近时间复杂度 $O(n^2)$ 和 $O(n^3)$ 从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度 $T(n)=O(f(n))$ 简称为时间复杂度，其中的 $f(n)$ 一般是算法中频度最大的语句频度。



## 空间复杂度

算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间[复杂度](http://baike.baidu.com/item/%E5%A4%8D%E6%9D%82%E5%BA%A6)类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。

-   **固定部分**：这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。
-   **可变空间**：这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

一个算法所需的存储空间用 $f(n)$ 表示。

$S(n)=O(f(n))$

其中$n$为问题的规模，$S(n)$ 表示空间复杂度。

















---