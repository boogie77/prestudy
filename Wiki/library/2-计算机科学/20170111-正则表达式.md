---
layout: post
title: 正则表达式
lead: 正则表达式全集
date: 2017-01-11T00:00:00.000Z
categories: 计算机科学
tagline: 正则表达式
tags:
  - 正则表达式
---


# 正则表达式简介

正则表达式又称规则表达式**。**（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式（规则）的文本。

许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在[Perl](http://baike.baidu.com/view/46614.htm)中就内建了一个功能强大的正则表达式引擎，还有Java语言自带的。正则表达式这个概念最初是由[Unix](http://baike.baidu.com/view/8095.htm)中的工具软件（例如sed和[grep](http://baike.baidu.com/view/1057278.htm)）普及开的。正则表达式通常缩写成`regex`，[单数](http://baike.baidu.com/view/1525497.htm)有regexp、regex，[复数](http://baike.baidu.com/view/10078.htm)有regexps、regexes、regexen。

## 概念

正则表达式是对[字符](http://baike.baidu.com/view/263416.htm)串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个`规则字符串`，这个`规则字符串`用来表达对字符串的一种过滤逻辑。

给定一个正则表达式和另一个字符串，我们可以达到如下的目的：

1. 给定的字符串是否符合正则表达式的过滤逻辑（称作`匹配`）；
2. 可以通过正则表达式，从字符串中获取我们想要的特定部分。

正则表达式的特点是：

1. 灵活性、逻辑性和功能性非常的强；
2. 可以迅速地用极简单的方式达到字符串的复杂控制。
3. 对于刚接触的人来说，比较晦涩难懂。

由于正则表达式主要[应用对象](http://baike.baidu.com/view/5314991.htm)是文本，因此它在各种[文本编辑器](http://baike.baidu.com/view/487023.htm)场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。

## 引擎

正则引擎主要可以分为两大类：一种是DFA，一种是NFA。这两种引擎都有了很久的历史(至今二十多年)，当中也由这两种引擎产生了很多变体！于是POSIX的出台规避了不必要变体的继续产生。这样一来，主流的正则引擎又分为3类：DFA，传统型NFA，POSIX NFA。

- **[DFA](http://baike.baidu.com/view/289418.htm) 引擎**在线性时状态下执行，因为它们不要求回溯（并因此它们永远不测试相同的字符两次）。DFA 引擎还可以确保匹配最长的可能的字符串。但是，因为 DFA 引擎只包含有限的状态，所以它**不能匹配具有反向引用的模式**；并且因为它不构造显示扩展，所以它**不可以捕获子表达式**。
- **传统的 NFA 引擎**运行所谓的`贪婪的`匹配[回溯算法](http://baike.baidu.com/view/6056523.htm)，以指定顺序测试正则表达式的所有可能的扩展并接受第一个匹配项。因为传统的 NFA 构造正则表达式的特定扩展以获得成功的匹配，所以它**可以捕获子表达式匹配和匹配的反向引用**。但是，因为传统的 NFA 回溯，所以它可以访问完全相同的状态多次（如果通过不同的路径到达该状态）。因此，在最坏情况下，它的**执行速度可能非常慢**。因为传统的 NFA 接受它找到的第一个匹配，所以它还**可能会导致其他（可能更长）匹配未被发现**。
- **POSIX NFA 引擎**与传统的 NFA 引擎类似，不同的一点在于：在它们**可以确保已找到了可能的最长的匹配之前，它们将继续回溯**。因此，POSIX NFA 引擎的速度慢于传统的 NFA 引擎；并且在使用 POSIX NFA 时，您恐怕不会愿意在更改回溯搜索的顺序的情况下来支持较短的匹配搜索，而非较长的匹配搜索。

使用DFA引擎的程序主要有：awk，egrep，flex，lex，MySQL，Procmail等；

使用传统型NFA引擎的程序主要有：GNU Emacs，Java，ergp，less，more，.NET语言，PCRE library，Perl，PHP，Python，Ruby，sed，vi；

使用POSIX NFA引擎的程序主要有：mawk，Mortice Kern Systems’ utilities，GNU Emacs(使用时可以明确指定)；

也有使用DFA/NFA混合的引擎：GNU awk，GNU grep/egrep，Tcl。

举例简单说明NFA与DFA工作的区别：

> 比如有字符串`this is yansen’s blog`，正则表达式为 `/ya(msen|nsen|nsem)/ `（不要在乎表达式怎么样，这里只是为了说明引擎间的工作区别）。 NFA工作方式如下，先在字符串中查找 y 然后匹配其后是否为 a ，如果是 a 则继续，查找其后是否为 m 如果不是则匹配其后是否为 n (此时淘汰msen选择支)。然后继续看其后是否依次为 s，e，接着测试是否为 n ，是 n 则匹配成功，不是则测试是否为 m 。为什么是 m ？因为 NFA 工作方式是以正则表达式为标准，反复测试字符串，这样同样一个字符串有可能被反复测试了很多次！
>
> 而DFA则不是如此，DFA会从 this 中 t 开始依次查找 y，定位到 y ，已知其后为 a ，则查看表达式是否有 a ，此处正好有 a 。然后字符串 a 后为 n ，DFA依次测试表达式，此时 msen 不符合要求淘汰。nsen 和 nsem 符合要求，然后DFA依次检查字符串，检测到sen 中的 n 时只有nsen 分支符合，则匹配成功！

由此可以看出来，两种引擎的工作方式完全不同，一个（NFA）以表达式为主导，一个（DFA）以文本为主导！一般而论，DFA引擎则搜索更快一些！但是NFA以表达式为主导，反而更容易操纵，因此一般程序员更偏爱NFA引擎！ 两种引擎各有所长，而真正的引用则取决与你的需要以及所使用的语言！

## 符号

正则表达式由一些普通[字符](http://baike.baidu.com/view/263416.htm)和一些[元字符](http://baike.baidu.com/view/1061241.htm)（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。

下表列出了所有的元字符和对它们的一个简短的描述。

| 类别   |      元字符       | 等价               | 描述                                       |
| ---- | :------------: | ---------------- | :--------------------------------------- |
| 转义   |      `\`       |                  | 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，`\\n`匹配`\n`。`\n`匹配换行符。序列`\\`匹配`\`而`\(`则匹配`(`。即相当于多种编程语言中都有的`转义字符`的概念。 |
| 位置   |      `^`       |                  | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，`^`也匹配`\n`或`\r`之后的位置。 |
| 位置   |      `$`       |                  | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，`$`也匹配`\n`或`\r`之前的位置。 |
| 位置   |      `\A`      |                  | 仅匹配字符串开头                                 |
| 位置   |      `\Z`      |                  | 仅匹配字符串末尾                                 |
| 位置   |      `\b`      |                  | 匹配`\w`和`\W`之间。匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的`匹配`有两种概念，一种是匹配字符，一种是匹配位置，这里的`\b`就是匹配位置的）。例如，`er\b`可以匹配`never`中的`er`，但不能匹配`verb`中的`er`。 |
| 位置   |      `\B`      |                  | 匹配非单词边界。`er\B`能匹配`verb`中的`er`，但不能匹配`never`中的`er`。 |
| 位置   |      `\f`      |                  | 匹配一个换页符。等价于`\x0c`和`\cL`。                 |
| 位置   |      `\n`      |                  | 匹配一个换行符。等价于`\x0a`和`\cJ`。                 |
| 位置   |      `\r`      |                  | 匹配一个回车符。等价于`\x0d`和`\cM`。                 |
| 位置   |      `\t`      |                  | 匹配一个制表符。等价于`\x09`和`\cI`。                 |
| 位置   |      `\v`      |                  | 匹配一个垂直制表符。等价于`\x0b`和`\cK`。               |
|      |                |                  |                                          |
| 重复   |    `{n,m}`     | {n,m}            | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，`o{1,3}`将匹配`fooooood`中的前三个`o`。`o{0,1}`等价于`o?`。请注意在逗号和两个数之间不能有空格。 |
| 重复   |      `*`       | `{0,*}`          | 匹配前面的子表达式任意次。例如，`zo*`能匹配`z`，也能匹配`zo`以及`zoo`。 |
| 重复   |      `+`       | ` {1,*}`         | 匹配前面的子表达式一次或多次（大于等于1次）。例如，`zo+`能匹配`zo`以及`zoo`，但不能匹配`z`。`+`等价于`{1,}`。 |
| 重复   |      `?`       | `{0,1}`          | 匹配前面的子表达式零次或一次。例如，`do(es)?`可以匹配`do`或`does`中的`do`。`?`等价于`{0,1}`。 |
| 重复   |     `{n}`      | `{n,n}`          | n是一个非负整数。匹配确定的n次。例如，`o{2}`不能匹配`Bob`中的`o`，但是能匹配`food`中的两个`o`。 |
| 重复   |     `{n,}`     | `{n,*}`          | n是一个非负整数。至少匹配n次。例如，`o{2,}`不能匹配`Bob`中的`o`，但能匹配`foooood`中的所有`o`。`o{1,}`等价于`o+`。`o{0,}`则等价于`o*`。 |
|      |                |                  |                                          |
|      |      `?`       |                  | 当该字符紧跟在任何一个其他限制符（`*`，`+`，`?`，`{n}`，`{n,}`，`{n,m}`）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串`oooo`，`o+`将匹配每个`o`即4次匹配，而`o+?`将只匹配1次即匹配`oooo`。 |
|      |      `.`       |                  | 匹配除`\r\n`之外的任何单个字符。要匹配包括`\r\n`在内的任何字符，请使用像`[\s\S]`的模式。 |
|      |  `(pattern)`   |                  | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用`$0…$9`属性。要匹配圆括号字符，请使用`\(`或`\)`。 |
|      | `(?:pattern)`  |                  | 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符`(|)`来组合一个模式的各个部分时很有用。例如`industr(?:y|ies)`就是一个比`industry|industries`更简略的表达式。 |
|      | `(?=pattern)`  |                  | 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，`Windows(?=95|98|NT|2000)`能匹配`Windows2000`中的`Windows`，但不能匹配`Windows3.1`中的`Windows`。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
|      | `(?!pattern)`  |                  | 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如`Windows(?!95|98|NT|2000)`能匹配`Windows3.1`中的`Windows`，但不能匹配`Windows2000`中的`Windows`。 |
|      | `(?<=pattern)` |                  | 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，`(?<=95\|98\|NT\|2000)Windows`能匹配`2000Windows`中的`Windows`，但不能匹配`3.1Windows`中的`Windows`。 |
|      | `(?<!pattern)` |                  | 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如`(?<!95\|98\|NT\|2000)Windows`能匹配`3.1Windows`中的`Windows`，但不能匹配`2000Windows`中的`Windows`。*这个地方不正确，有问题此处用或任意一项都不能超过2位，如`(?<!95\|98\|NT\|20)Windows`正确，`(?<!95\|980\|NT\|2000)Windows` 报错，若是单独使用则无限制，如`(?<!2000)Windows` 正确匹配* |
|      |     `x\|y`     |                  | 匹配x或y。例如，`z\|food`能匹配`z`或`food`（此处请谨慎）。`[z\|f]ood`则匹配`zood`或`food`或`|ood`。 |
|      |    `[xyz]`     |                  | 字符集合。匹配所包含的任意一个字符。例如，`[abc]`可以匹配`plain`中的`a`。 |
|      |    `[^xyz]`    |                  | 负值字符集合。匹配未包含的任意字符。例如，`[^abc]`可以匹配`plain`中的`plin`。 |
|      |    `[a-z]`     |                  | 字符范围。匹配指定范围内的任意字符。例如，`[a-z]`可以匹配`a`到`z`范围内的任意小写字母字符。注意：只有连字符在字符组内部时，并且出现在两个字符之间时，才能表示字符的范围； 如果出字符组的开头，则只能表示连字符本身。 |
|      |    `[^a-z]`    |                  | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，`[^a-z]`可以匹配任何不在`a`到`z`范围内的任意字符。 |
|      |     `\cx`      |                  | 匹配由x指明的控制字符。例如，`\cM`匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的`c`字符。 |
|      |      `\d`      | `[0-9]`          | 匹配一个数字字符。等价于`[0-9]`。grep 要加上-P，perl正则支持  |
|      |      `\D`      | `[^0-9]`         | 匹配一个非数字字符。等价于`[^0-9]`。grep要加上-P，perl正则支持 |
|      |      `\s`      | `[ \f\n\r\t\v]`  | 匹配任何不可见字符，包括空格、制表符、换页符、回车符等等。等价于`[ \f\n\r\t\v]`。 |
|      |      `\S`      | `[^ \f\n\r\t\v]` | 匹配任何可见字符。等价于`[^ \f\n\r\t\v]`。            |
|      |      `\w`      | `[A-Za-z0-9_]`   | 匹配包括下划线的任何单词字符。类似但不等价于`[A-Za-z0-9_]`，这里的"单词"字符使用Unicode字符集。 |
|      |      `\W`      | `[^A-Za-z0-9_]`  | 匹配任何非单词字符。等价于`[^A-Za-z0-9_]`。            |
|      |     `\xn`      |                  | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，`\x41`匹配`A`。`\x041`则等价于`\x04&1`。正则表达式中可以使用ASCII编码。 |
|      |     `\num`     |                  | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，`(.)\1`匹配两个连续的相同字符。 |
|      |      `\n`      |                  | 标识一个八进制转义值或一个向后引用。如果`\n`之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
|      |     `\nm`      |                  | 标识一个八进制转义值或一个向后引用。如果`\nm`之前至少有nm个获得子表达式，则nm为向后引用。如果`\nm`之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则`\nm`将匹配八进制转义值nm。 |
|      |     `\nml`     |                  | 如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
|      |     `\un`      |                  | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，`\u00A9`匹配版权符号`©`。 |
|      |    `\p{P}`     |                  | 小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。大括号内的`P`表示Unicode 字符集七个字符属性之一：①P：标点字符。②L：字母；③M：标记符号（一般不会单独出现）；④Z：分隔符（比如空格、换行等）；⑤S：符号（比如数学符号、货币符号等）；⑥N：数字（比如阿拉伯数字、罗马数字等）；⑦C：其他字符。**注：此语法部分语言不支持，例：javascript**。 |
|      |     `< >`      |                  | 匹配词（word）的开始（<）和结束（>）。例如正则表达式`<the>`能够匹配字符串"`for the wise`"中的"`the`"，但是不能匹配字符串"`otherwise`"中的"`the`"。注意：这个元字符不是所有的软件都支持的。 |
|      |     `( )`      |                  | 将( 和 ) 之间的表达式定义为`组`（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 `\1` 到`\9` 的符号来引用。 |
|      |      `|`       |                  | 将两个匹配条件进行逻辑`或`（or）运算。例如正则表达式`(him|her) `匹配"`it belongs to him`"和"`it belongs to her`"，但是不能匹配"`it belongs to them.`"。注意：这个元字符不是所有的软件都支持的。 |
|      |      `+`       |                  | 匹配1或多个正好在它之前的那个字符。例如正则表达式`9+`匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。 |
|      |      `?`       |                  | 匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。   |
|      |  `{i} {i,j}`   |                  | 匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式`A[0-9]{3}` 能够匹配字符"A"后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式`[0-9]{4,6}` 匹配连续的任意4个、5个或者6个数字 |

## 语法支持

|   **命令或环境**    | **`.`** | **`[]`** | **`^`** | **`$`** | **`()`** | **`{}`** | `*`  | **`?`** | **`+`** | **`|`** | **`( )`** |
| :------------: | :-----: | :------: | :-----: | :-----: | :------: | :------: | :--: | :-----: | :-----: | :-----: | :-------: |
|     **vi**     |    √    |    √     |    √    |    √    |    √     |          |      |         |         |         |           |
| **Visual C++** |    √    |    √     |    √    |    √    |    √     |          |      |         |         |         |           |
|    **awk**     |    √    |    √     |    √    |    √    |          |    √     |  √   |    √    |    √    |    √    |     √     |
|    **sed**     |    √    |    √     |    √    |    √    |    √     |    √     |      |         |         |         |           |
|   **delphi**   |    √    |    √     |    √    |    √    |    √     |          |  √   |    √    |    √    |    √    |     √     |
|   **python**   |    √    |    √     |    √    |    √    |    √     |    √     |  √   |    √    |    √    |    √    |     √     |
|    **java**    |    √    |    √     |    √    |    √    |    √     |    √     |  √   |    √    |    √    |    √    |     √     |
| **javascript** |    √    |    √     |    √    |    √    |    √     |          |  √   |    √    |    √    |    √    |     √     |
|    **php**     |    √    |    √     |    √    |    √    |    √     |          |      |         |         |         |           |
|    **perl**    |    √    |    √     |    √    |    √    |    √     |          |  √   |    √    |    √    |    √    |     √     |
|     **C#**     |    √    |    √     |    √    |    √    |          |          |  √   |    √    |    √    |    √    |     √     |

> awk支持`\{ \}`，要在命令行加入 --posix or --re-interval参数即可，可见man awk中的interval expression

# 速记技巧

四个字符（`. [] ^ $`）是所有语言都支持的正则表达式，所以这个四个是基础的正则表达式。正则难理解因为里面有一个等价的概念，这个概念大大增加了理解难度，让很多初学者看起来会懵，如果把等价都恢复成原始写法，自己书写正则就超级简单了，就像说话一样去写你的正则了：

**等价：**

- `?`等价于匹配长度`{0,1}`
- `*`等价于匹配长度`{0,*} `
- `+`等价于匹配长度`{1,*}`
- `\d`等价于`[0-9]`
- `\D`等价于`[^0-9]`
- `\w`等价于`[A-Za-z_0-9]`
- `\W`等价于`[^A-Za-z_0-9]`
- `\s`等价于`[ \f\n\r\t\v]`
- `\S`等价于`[^ \f\n\r\t\v]`

**常用运算符与表达式**：　　

- `^` 开始
- `$ `结尾
- `()`域段
- `[]`包含，默认是一个字符长度
- `[^] `不包含，默认是一个字符长度
- `{n,m}` 匹配长度
- `.` 任何单个字符（`\. `字符点）
- `|` 或
- `\` 转义
- `[A-Z]` 26个大写字母
- `[a-z]` 26个小写字母
- `[0-9]` 0至9数字

**分割语法：**

- `[A,H,T,W]` 包含A或H或T或W字母

- `[a,h,t,w]` 包含a或h或t或w字母
- `[0,3,6,8]` 包含0或3或6或8数字

**语法与释义：**　　

- 基础语法 "`^([]{})([]{})([]{})$`"
- 正则字符串 = "开始（[包含内容]{长度}）（[包含内容]{长度}）（[包含内容]{长度}）结束" 
- `?`，`*`，`+`，`\d`，`\w`这些都是简写的，完全可以用`[]`和`{}`代替，在`(?:)(?=)(?!)(?<=)(?<!)(?i)(*?)(+?)`这种特殊组合情况下除外
- 初学者可以忽略简写标示符，学会了基础使用再按表自己去等价替换

**实例：**

- 字符串：`tel:086-0666-88810009999`
- 原始正则："`^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$`" 
- 速记理解：`开始f` + `tel:` + `[0-9数字]{1至3位}` + `-` +  `[0数字]` +`[0-9数字]{2至3位}`+ `-` + `[0-9数字]{8至11位}`  + `结束`
- 等价简写后正则写法："`^tel:\d{1,3}-[0]\d{2,3}-\d{8,11}$`" ，简写语法不是所有语言都支持

# 正则表达式语法

## 元字符

正则表达式中具有特殊含义的字符，其表示内容已非字符本身的含义，如果需要表示元字符本身则需要使用转义符`\`进行转义。

| 元字符  | 匹配    | 描述                                       |
| :--: | ----- | :--------------------------------------- |
| `\`  | 转义符   | 将下一个字符标记符、或一个向后引用、或一个八进制转义符。             |
| `.`  | 任意符   | 匹配除“`\r\n`”之外的任何单个字符。要匹配包括“`\r\n`”在内的任何字符，请使用像“`[\s\S]`”的模式。 |
| `^`  | 开始符   | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，`^`也匹配`\n`或`\r`之后的位置。 |
| `$`  | 结束符   | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，`$`也匹配`\n`或`\r`之前的位置。 |
| `[]` | 字符集   | `[xyz]``[^xyz]``[a-z]``[^a-z]`匹配所包含的任意一个字符。 |
| `{}` | 重复    | `{n,m}`最少匹配n次且最多匹配m次。                    |
| `()` | 分组    | `(pattern)`匹配pattern并获取这一匹配。             |
| `|`  | 分支    | 将两个匹配条件进行逻辑`或`（or）运算。`x|y`匹配任意一个分支。注意或运算的短路特征，前分支匹配成功则后续匹配不执行。 |
| `*`  | 任意次   | 匹配前面的子表达式任意次。                            |
| `+`  | 一次或多次 | 匹配前面的子表达式一次或多次(大于等于1次）。                  |
| `?`  | 零次或一次 | 匹配前面的子表达式零次或一次。                          |
| `/`  |       | 表示 JScript 中的文本正则表达式模式的开始或结尾。 在第二个“`/`”后添加单字符标志可以指定搜索行为。 |

## 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

### 打印字符

|    类别     |     语法     | 符号         |         等效         |                                          |
| :-------: | :--------: | ---------- | :----------------: | ---------------------------------------- |
|    数字     |    `\d`    | `digit`    |      `[0-9]`       |                                          |
|    非数字    |    `\D`    | `no Digit` |      `[^0-9]`      |                                          |
|    单词     |    `\w`    | `word`     | 类似：`[A-Za-z0-9_]`  | 匹配包括下划线的任何单词字符。类似但不等价于`[A-Za-z0-9_]`，这里的"单词"字符使用Unicode字符集。 |
|    非单词    |    `\W`    | `no Word`  | 类似：`[^A-Za-z0-9_]` |                                          |
|   八进制代码   |   `\0nn`   |            |                    | ASCII代码中八进制代码为`nn`的字符                    |
|  十六进制代码   |   `\xnn`   |            |                    | 匹配`nn`，其中`nn`为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\x41`”匹配“`A`”。“`\x041`”则等价于“`(\x04)1`”。正则表达式中可以使用ASCII编码。 |
| Unicode代码 |  `\unnnn`  |            |                    | Unicode代码中十六进制代码为`nnnn`的字符。`\u00A9` 版权符号` ©` 匹配。 |
|           | `\p{name}` | `property` |                    | Unicode中属性为`name`的字符类，例如`\p{IsGreek}`    |

`\p{name}`用来表示Unicode中属性为`name`的字符类别，具体字符类型如下：

- P：标点字符
- L：字母
- M：标记符号（一般不会单独出现）
- Z：分隔符（比如空格、换行等）
- S：符号（比如数学符号、货币符号等）
- N：数字（比如阿拉伯数字、罗马数字等）
- C：其他字符

Unicode 块和类别的类

- `\p{InGreek} `Greek 块（简单块）中的字符
- `\p{Lu} `大写字母（简单类别）
- `\p{Sc}` 货币符号
- `\P{InGreek} `所有字符，Greek 块中的除外（否定）
- `[\p{L}&&[^\p{Lu}]]` 所有字母，大写字母除外（减去）

POSIX 字符类（仅 US-ASCII）

- `\p{Lower} `小写字母字符：`[a-z]`
- `\p{Upper} `大写字母字符：`[A-Z]`
- `\p{ASCII}` 所有 ASCII：`[\x00-\x7F]`
- `\p{Alpha}` 字母字符：`[\p{Lower}\p{Upper}]`
- `\p{Digit}` 十进制数字：`[0-9]`
- `\p{Alnum} `字母数字字符：`[\p{Alpha}\p{Digit}]`
- `\p{Punct} `标点符号：!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~
- `\p{Graph}` 可见字符：`[\p{Alnum}\p{Punct}]`
- `\p{Print}` 可打印字符：`[\p{Graph}\x20]`
- `\p{Blank}` 空格或制表符：`[ \t]`
- `\p{Cntrl}` 控制字符：`[\x00-\x1F\x7F]`
- `\p{XDigit}` 十六进制数字：`[0-9a-fA-F]`
- `\p{Space}` 空白字符：`[ \f\n\r\t\v]`

### 非打印字符

| **字符** | 符号         | **匹配** | **等效代码**         | 描述                                       |
| ------ | ---------- | ------ | ---------------- | ---------------------------------------- |
| `\cx`  | `control`  | 控制符    |                  | 匹配由`x`指明的控制字符。例如，`\cM`匹配一个`Control-M`或回车符。`x`的值必须为`[A-Za-z]`之一。否则，将`c`视为一个原义的`c`字符。 |
| `\f`   |            | 换页符    | `\x0c` 和 `\cL`   |                                          |
| `\n`   |            | 换行符    | `\x0a` 和 `\cJ`   |                                          |
| `\r`   |            | 回车符    | `\x0d` 和 `\cM`   |                                          |
| `\t`   |            | 横向制表符  | `\x09` 和 `\cI`   |                                          |
| `\v`   |            | 垂直制表符  | `\x0b` 和 `\cK`   |                                          |
| `\s`   | `space`    | 任何空白字符 | `[ \f\n\r\t\v]`  | `space`：匹配任何不可见字符，包括空格、制表符、换页符、回车符等等。    |
| `\S`   | `no Space` | 任何可见字符 | `[^ \f\n\r\t\v]` | `no space`：匹配任何可见字符。                     |
| `\a`   | `alarm`    | 报警字符   |                  | 报警字符(打印它的效果是电脑嘀一声)                       |
| `\e`   | `escape`   | 返回字符   |                  | 返回占位符                                    |

## 位置符

| **字符** | **匹配** | 描述                                       |
| ------ | ------ | ---------------------------------------- |
| `^`    | 开始位置   | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，`^`也匹配`\n`或`\r`之后的位置。 |
| `$`    | 结束位置   | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，`$`也匹配`\n`或`\r`之前的位置。 |
| `\A`   | 开头     | 仅匹配字符串开头(类似`^`，但不受处理多行选项的影响)。            |
| `\z`   | 末尾     | 仅匹配字符串末尾(类似`$`，但不受处理多行选项的影响)。            |
| `\Z`   | 行尾     | 字符串结尾或行尾(不受处理多行选项的影响)。如果是存在换行，只匹配到换行前的结束字符串。 |
| `\G`   |        | 匹配最后匹配完成的位置。                             |
| `\b`   | 单词边界   | 匹配`\w`和`\W`之间。匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的`匹配`有两种概念，一种是匹配字符，一种是匹配位置，这里的`\b`就是匹配位置的）。例如，`er\b`可以匹配`never`中的`er`，但不能匹配`verb`中的`er`。 |
| `\B`   | 非单词边界  | 匹配非单词边界。`er\B`能匹配`verb`中的`er`，但不能匹配`never`中的`er`。 |

## 字符集

`[xyz]，[^xyz]，[a-z]，[^a-z]`匹配字符集所包含的任意一个字符。符号`^`用在字符集的首位表示反义，用于匹配字符集除字符集之外的字符。

- `[]`就是从集合`[aeiou]`中选出一个字符来匹配
- `[]`中出现连字符`-`时，并且出现在两个字符之间时，表示字符范围。（如果出现在字符组的开头或结尾，则只能表示连字符`-`本身）
- 在`[]`中首先出现`^`表示取反，匹配任何不在字符组范围内的任意字符。（如果出现在非首位，只能代表符号`^`本身）

| 字符/代码    | 匹配     | 描述                | 示例                                       |
| -------- | ------ | ----------------- | ---------------------------------------- |
| `[xyz]`  | 字符集合   | 匹配所包含的任意一个字符。     | `[abc]`可以匹配`plain`中的`a`。                 |
| `[^xyz]` | 反向字符集合 | 匹配未包含的任意字符。       | `[^abc]`可以匹配`plain`中的`plin`。             |
| `[a-z]`  | 字符范围   | 匹配指定范围内的任意字符。     | `[a-z]`可以匹配`a`到`z`范围内的任意小写字母字符。注意：只有连字符在字符组内部时，并且出现在两个字符之间时，才能表示字符的范围； 如果出现在字符组的开头或结尾，则只能表示连字符本身。 |
| `[^a-z]` | 反向字符范围 | 匹配任何不在指定范围内的任意字符。 | `[^a-z]`可以匹配任何不在`a`到`z`范围内的任意字符。         |

## 限定符

`(pattern){n,m}`为正则表达式重复的基本表达方法，表示对`(pattern)`匹配`n`次且最多匹配`m`次（`m`和`n`均为非负整数，其中`n<=m`）。正则表达式通常支持对重复模式的简写表示`*+?`如下表。

重复限定符表

| **代码/语法** | 等效语法    | **说明**                                   |
| --------- | ------- | ---------------------------------------- |
| `{n,m}`   |         | 最少匹配`n`次且最多匹配`m`次（`m`和`n`均为非负整数，其中`n<=m`）。 |
| `{n,}`    | `{n,*}` | 至少匹配`n`次（`n`是一个非负整数）。                    |
| `{n}`     | `{n,n}` | 匹配确定的`n`次（`n`是一个非负整数）。                   |
| `*`       | `{0,*}` | 匹配前面的子表达式任意次。                            |
| `+`       | `{1,*}` | 匹配前面的子表达式一次或多次（大于等于1次）。                  |
| `?`       | `{0,1}` | 匹配前面的子表达式零次或一次。                          |

### 贪婪与懒惰

当这种模式成为**贪婪模式**。

> 

如果需要**懒惰匹配**，即匹配尽可能少的字符。需要在重复限定符后加`？`表示。

### 正则的特性

- **贪婪性**：正则在捕获时，包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在限定符后加`?`来表示。

  > `a.*b`，它将会匹配最长的以`a`开始，以`b`结束的字符串。如果用它来搜索`aabab`的话，它会匹配整个字符串`aabab`。
  >
  > `a.*?b`匹配最短的，以`a`开始，以`b`结束的字符串。如果把它应用于`aabab`的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。

- **懒惰性**：正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符`g`来标明是全局捕获。

## 分支

将两个匹配条件进行逻辑`或`（or）运算。`x|y`匹配任意一个分支。注意或运算的短路特征，前分支匹配成功则后续匹配不执行。

> - `0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，`8`位本地号(如`010-12345678`)，一种是4位区号，`7`位本地号(`0376-2233445`)。
> - `\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}`这个表达式匹配`3`位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持`4`位区号的。
> - `\d{5}-\d{4}|\d{5}`这个表达式用于匹配美国的邮政编码。美国邮编的规则是`5`位数字，或者用连字号间隔的`9`位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成`\d{5}|\d{5}-\d{4}`的话，那么就只会匹配`5`位的邮编(以及`9`位邮编的前`5`位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

## 分组

### 后向引用

对一个正则表达式模式或部分模式两边添加圆括号`()`将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从`1`开始，最多可存储`99`个捕获的子表达式。每个缓冲区都可以使用 '`\n`' 访问，其中`n`为一个标识特定缓冲区的一位或两位十进制数。


小括号的语法

|  分类  |             代码/语法              | 说明                                       |
| :--: | :----------------------------: | :--------------------------------------- |
|  捕获  |            `(exp)`             | 匹配exp，并捕获文本到自动命名的组里，按顺序依次命名为$1,2,3,\cdots,10$，一般支持10个分组。 |
|  捕获  |           `(?>exp)`            | 贪婪子表达式， 匹配的独立模式，省去回溯。                    |
|  捕获  | `(?<name>exp)` 或`(?'name'exp)` | 匹配exp，并捕获文本到名称为name的组里。（{ python:  `(?P<name>exp) `}） |
|  捕获  |       `(?(name)yes|no)`        | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no      |
|  捕获  |         `(?(name)yes)`         | 同上，只是使用空表达式作为no                          |
|  捕获  |           `(?:exp)`            | 匹配exp，不捕获匹配的文本，也不给此分组分配组号。  **当我们加`()`只是为了提高优先级而不想捕获小分组时用来取消分组捕获** |
|  捕获  |        `(?<x>-<y>exp)`         | 平衡组                                      |
| 后向引用 |              `\n`              | 匹配第`n`个分组的子表达式，如果它经匹配（`n`是一个非负整数，一般支持10个分组，部分可支持到99个分组）。否则指的是八进制字符码的表达式。 |
| 后向引用 |           `\<name>`            | 匹配命名分组。                                  |
| 零宽断言 |           `(?=exp)`            | 匹配exp前面的位置。                              |
| 零宽断言 |           `(?!exp)`            | 匹配后面不是exp的位置。                            |
| 零宽断言 |           `(?<=exp)`           | 匹配exp后面的位置。                              |
| 零宽断言 |           `(?<!exp)`           | 匹配前面不是exp的位置。                            |
| 零宽断言 |        `(?(exp)yes|no)`        | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
| 零宽断言 |         `(?(exp)yes)`          | 同上，只是使用空表达式作为no                          |
|  注释  |         `(?#comment)`          | 不对正则表达式的处理产生任何影响，用于提供注释让人阅读。             |
| 处理选项 |        `(?im-nsx:exp)`         | 在子表达式exp中改变处理选项（`i，m，x，n，s`；选项前加`-`表示关闭） |
| 处理选项 |          `(?im-nsx)`           | 为表达式后面的部分改变处理选项（`i，m，x，n，s`；选项前加`-`表示关闭） |

 

## 零宽断言

用于查找在某些内容（但并不包括这些内容）之前或之后的东西，也就是说它们像`\b`，`^`，`$`那样用于指定一个位置，这个位置应该满足一定的条件（即断言），因此它们也被称为**零宽断言**。断言用来声明一个应该为真的事实。[正则表达式](http://baike.baidu.com/view/94238.htm)中只有当断言为真时才会继续进行匹配。

- **`(?=exp)`零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。

  > `\b\w+(?=ing\b)`匹配以ing结尾的单词的前面部分（除了ing以外的部分），如查找*`I'm singing while you're dancing.`*时匹配`sing`和`danc`。

- **`(?<=exp)`零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。

  > `(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分（除了re以外的部分），如查找*`reading a book`*时匹配`ading`。
  >
  > ​
  >
  > 同时使用这两种断言：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字（再次强调，不包括这些空白符）。

- **`(?!exp)`零宽度负预测先行断言**，它断言此位置的后面不能匹配表达式exp。

  > `\d{3}(?!\d)`匹配三位数字并且之后不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

- **`(?<!exp)`零宽度负回顾后发断言**，它断言此位置的前面不能匹配表达式exp。

  > `(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

> `(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容。
>
> - `(<?=(\w+)>)`指定了这样的**前缀**：被尖括号括起来的单词(比如可能是`<b>`)，然后是`.*`(任意的字符串)，最后是一个**后缀**`(?=<\/\1>)`。
> - 注意后缀里的`\/`，它用到了前面提过的字符转义；
> - `\1`则是一个[反向引用](http://baike.baidu.com/view/6987307.htm)，引用的正是捕获的第一组，前面的`(\w+)`匹配的内容，这样如果前缀实际上是`<b>`的话，后缀就是`</b>`了。
> - 整个表达式匹配的是`<b>`和`</b>`之间的内容（再次提醒，不包括前缀和后缀本身）。

## 优先级

正则表达式的计算方式与算术表达式非常类似；即从左到右进行计算，并遵循优先级顺序。

下表按从高到低的顺序包含了正则表达式运算符的优先级顺序。

| **运算符**                | **说明**  |
| ---------------------- | ------- |
| `\`                    | 转义符     |
| `(), (?:), (?=), []`   | 圆括号和方括号 |
| `*、+、?、{n}、{n,}、{n,m}` | 限定符     |
| `^、$、\任何元字符`           | 定位点和序列  |
| `|`                    | 替换符     |

字符具有高于替换运算符的优先级，例如，允许“`m|food`”匹配“`m`”或“`food`”。



# 常用正则表达式

> 说明：正则表达式通常用于两种任务：
>
> 1. 验证
> 2. 搜索/替换
>
> 用于验证时，通常需要在前后分别加上`^`和`$`，以匹配整个待验证字符串；
>
> 搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上`\b`而不是`^`和`$`。
>
> 此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。

| **说明**                                   | **正则表达式**                                |
| ---------------------------------------- | ---------------------------------------- |
| 网址（URL）                                  | `[a-zA-z]+://[^\s]*`                     |
| IP地址(IP Address)                         | `((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)` |
| 电子邮件(Email)                              | `\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*` |
|                                          |                                          |
| QQ号码                                     | `[1-9]\d{4,}`                            |
| HTML标记(包含内容或自闭合)                         | `<(.*)(.*)>.*<\/\1>|<(.*) \/>`           |
| 密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)      | `(?=^.{8,}$`)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$ |
| 密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 | `^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ |
| 日期(年-月-日)                                | `(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))` |
| 日期(月/日/年)                                | `((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})` |
| 时间(小时:分钟, 24小时制)                         | `((1|0?)[0-9]|2[0-3]):([0-5][0-9])`      |
| 汉字(字符)                                   | `[\u4e00-\u9fa5]`                        |
| 中文及全角标点符号(字符)                            | `[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]` |
| 中国大陆固定电话号码                               | `(\d{4}-|\d{3}-)?(\d{8}|\d{7})`          |
| 中国大陆手机号码                                 | `1\d{10}`                                |
| 中国大陆邮政编码                                 | `[1-9]\d{5}`                             |
| 中国大陆身份证号(15位或18位)                        | `\d{15}(\d\d[0-9xX])?`                   |
| 非负整数(正整数或零)                              | `\d+`                                    |
| 正整数                                      | `[0-9]*[1-9][0-9]*`或`[1-9]\d*|0`         |
| 负整数                                      | `-[0-9]*[1-9][0-9]*`或`-[1-9]\d*`         |
| 整数                                       | `-?\d+`                                  |
| 小数                                       | `(-?\d+)(\.\d+)?`                        |
| 不包含abc的单词                                | `\b((?!abc)\w)+\b`                       |



“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 `^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$` 



























































---