---
layout: post
title: Python
lead: Python语言学习
date: 2016-12-01T00:00:00.000Z
categories: Development
tagline: Python
tags:
  - Python
---

## Python资源

- [awesome-python](https://awesome-python.com)

# Python 简介

## Python 的由来

Python的创始人：吉多·范罗苏姆（Guido van Rossum）

![img](http://images2015.cnblogs.com/blog/1033021/201610/1033021-20161018104511873-131390826.png)

1989年，吉多·范罗苏姆为了在阿姆斯特丹打发圣诞节假期时间，开发的一个新的脚本解释程序，作为ABC语言的一种继承。

Python社区的人赋予他“仁慈大君” 的称号，这一称号直接来自英国肥皂剧《Monty Python飞行马戏团》。Guido当初之所以选中Python作为语言的名字，是因为他太喜欢这部肥皂剧了。

Python是一门解释型的高级编程语言，特点是简单明确。Python作者是荷兰人Guido van Rossum，1982年他获得数学和计算机硕士学位后，在荷兰数学与计算科学研究所（**C**entrum **W**iskunde & **I**nformatica, **CWI**）谋了份差事。在CWI期间，Guido参与到了一门叫做ABC的语言开发工作中。ABC是一门教学语言，所以拥有简单，可读性好，语法更接近自然语言等特点。在那个C语言一统天下的年代，ABC就是一股简单的清流，毕竟是门教学语言，最后没有流行起来，不过这段经历影响了Guido。1989年的圣诞假期，闲得蛋疼的Guido决定设计一门简单易用的新语言，要介于C和Shell之间，同时吸取ABC语法中的优点。Guido用自己喜欢的一部喜剧电视剧来命名这门语言：《Monty **Python**'s Flying Circus》。

1991年，第一版基于C实现的Python编译器诞生，因为简单，拓展性好，Python很快就在Guido的同事中大受欢迎，不久Python的核心开发人员就从Guido一人变成了一个小团队。后来随着互联网时代的到来，开源及社区合作的方式蓬勃发展，Python也借此上了发展的快车道。因为Python非常容易拓展，在不同领域的开发者贡献下，许多受欢迎的功能和特征被开发出来，渐渐形成了各种各样的库，其中一部分被加入到Python的标准库中，这让本来就不需要过多思考底层细节的Python变得更加强大好用。在不过多考虑执行效率的前提下，使用Python进行开发的周期相比传统的C/C++甚至Java等语言都大大缩短，代码量也大幅降低，所以出bug的可能性也小了很多。因此有了语言专家Bruce Eckel的那句名言：**Life is short, you need Python**. 后来这句话的中文版“==人生苦短，我用Python==”被Guido印在了T恤上。发展至今，Python渐渐成了最流行的语言之一，在编程语言排行榜TOBIE中常年占据前5的位置。另外随着Python的用户群越来越壮大，慢慢在本身特点上发展出了自己的哲学，叫做Python的禅（The Zen of Python）。遵循Python哲学的做法叫做很Python（Pythonic），具体参见：

[PEP 20 -- The Zen of Python](https://www.python.org/dev/peps/pep-0020/)

或者在Python中执行：

```python
>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

Python拥有很好的扩充性，可以非常轻松地用其他语言编写模块供调用，用Python编写的模块也可以通过各种方式轻松被其他语言调用。所以一种常见的Python使用方式是，底层复杂且对效率要求高的模块用C/C++等语言实现，顶层调用的API用Python封装，这样可以通过简单的语法实现顶层逻辑，故而Python又被称为“**胶水语言**”。这种特性的好处是，**无需花费很多时间在编程实现上，更多的时间可以专注于思考问题的逻辑**。尤其是对做算法和深度学习的从业人员，这种方式是非常理想的，所以如今的深度学习框架中，除了MATLAB，或是Deeplearning4j这种摆明了给Java用的，其他框架基本上要么官方接口就是Python，要么支持Python接口。

## Python 的特点

**优点：**

- **易于学习：**Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。
- **易于阅读：**Python代码定义的更清晰。
- **易于维护：**Python的成功在于它的源代码是相当容易维护的。
- **广泛的标准库：**Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。
- **互动模式：**互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。
- **可移植：**基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。
- **可扩展：**如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。
- **数据库：**Python提供所有主要的商业数据库的接口。
- **GUI编程：**Python支持GUI可以创建和移植到许多系统调用。
- **可嵌入: **你可以将Python嵌入到C/C++程序，让你的程序的用户获得"脚本化"的能力。

**缺点：**

- **运行速度慢**：和C程序相比非常慢。因为Python是解释型语言，代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。

  但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如，开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。


- **代码不能加密：**如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。

  这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是，在目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。另外，现在如火如荼的开源运动和互联网自由开放的精神是一致的，互联网上有无数非常优秀的像Linux一样的开源代码，我们千万不要高估自己写的代码真的有非常大的“商业价值”。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了，一旦开源，就没人敢用他们的产品了。


- **线程不能利用多CPU：**这是Python被人诟病最多的一个缺点，GIL即全局解释器锁。是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。

## Python 应用领域

- **WEB／客户端开发**：豆瓣、Youtube 、Quora 、BitTorrent、dropbox 、Gmail、Google Maps
- **云计算**：OpenStack
- **爬虫**：搜索引擎、网站比价、买火车票
- **游戏**：EVE online、Civilization IV
- **科学运算、人工智能**：典型库NumPy，SciPy，Matplotlib，Enthought librarys，pandas
- **系统运维**：运维人员必备语言
- **金融**：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c、c++、Java等，尤其擅长策略回测
- **图形GUI**：PyQT、WxPython、TkInter

### Python 应用

- 谷歌：Google App Engine 、code.google.com 、Google Earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发
- CIA：美国中情局网站就是用Python开发的
- NASA：美国航天局(NASA)大量使用Python进行数据分析和运算
- YouTube：世界上最大的视频网站YouTube就是用Python开发的
- Dropbox：美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载
- Instagram：美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发
- Facebook：大量的基础库均通过Python实现的
- Redhat： 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的
- 豆瓣：公司几乎所有的业务均是通过Python开发的
- 知乎：国内最大的问答社区，通过Python开发(国外Quora)
- 春雨医生：国内知名的在线医疗网站是用Python开发的
- 除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。




## Python版本

Python 3.x与Python 2.x是不兼容的。这貌似是Python开发者犯的一个错误，而事实是Guido Van Rossum(Python语言的最初创建者)故意为之。**Guido的本意就是想不考虑太多向后兼容性的问题，去适当地清理一下Python 2.x中不合理的内容，而不是把Python 3.x简单的当做对Python 2.x的更新版本。**

实际上，Python 3.0在2008年12月就已经发布了，Python官方在2010年年中发布2.7时宣布，2.7将是Python 2.x的最后一个主发布版本。**其实Python 2.7 是向Python 3.x的一个过渡版本，里面支持了一些Python 3.x的特性**。

2014年11月，Python官方宣布Python 2.7将会被支持到2020年，并再次确认了不会有Python 2.8发布，希望用户尽快迁移到Python 3.4+ 。3.x正在处于积极开发状态，并且在过去5年里已经发布了多个稳定版本，包括2012年的3.3，2014年的3.4，2015年的3.5。这意味着最近所有的标准库更新将默认只能在Python 3.x中可用。

如何查看版本呢？使用**python --version**命令。

### Python 2.x 与 Python 3.x 的主要区别：

#### PRINT IS A FUNCTION

在Python 3.x中，输出语句需要使用print()函数，该函数接收一个关键字参数，以此来代替Python 2.x中的大部分特殊语法。下面是几个对比项：

| **目标**             | **Python 2.x的实现**                   | **Python 3.x的实现**                        |
| ------------------ | ----------------------------------- | ---------------------------------------- |
| 拼接并输出多个值           | `print "The result is", 2+3`        | `print("The result is", 2+3)`            |
| 打印一个元组(1,2,3)      | `print(1,2,3) 或 print (1,2,3)`      | `print((1,2,3))`                         |
| 输出一个内容并且不换行        | `print “Hello”,`                    | `print("Hello", end=" ")`                |
| 输出一个新空白行           | `print`                             | `print()`                                |
| 将输出内容输出到标准错误输出文件   | `print >>sys.stderr, "fatal error"` | `print("fatal error", file=sys.stderr)`  |
| 自定义多个输出内容之间的分隔/拼接符 | `N/A`                               | `print("There are <", 2**32, "> possibilites!", sep="")` |

#### ALL IS Unicode

Python 2.x中使用的默认字符编码为ASCII码，要使用中文字符的话需要指定使用的字符编码，如UTF-8；Python 3.x中使用的默认字符编码为Unicode，就不存在这个问题了。

#### 多变量同时赋值问题

Python 2.x中如果要给多个变量同时赋值，要求=号右边的表达式返回结果的个数要与=号左边接收值的变量个数相等，不能多，也不能少。如：

```python
a,b,c = (1,2,3)        # 正常，a=1, b=2, c=3

a,b,c = range(5)       # 报错，ValueError: too many values to unpack

a,b,c,d,e = [1,2,3]   # 报错，ValueError: need more than 3 values to unpack 
```

Python 3.x中允许=号昨边的变量数小于=号右边表达式返回的结果的个数，但是需要有1个且只能有1个字典类型的变量来接收多余的返回值。与Python 2.x相同的是 Python 3.x中=号左边的变量数也是不能多与=号右边表达式的返回值个数，但是错误提示语更清晰了。

```python
a,b,c = (1,2,3) # 正常，a=1, b=2, c=3

a,*b,c = range(5) # 正常，a=0, b=[1,2,3], c=4

a,b,c,d,e = [1,2,3] # 报错，ValueError: not enough values to unpack (expected 5, got 3)
```

#### 某些库改名字了

| **Old Name**        | **New Name**   |
| ------------------- | -------------- |
| `_winreg`           | `winreg`       |
| `ConfigParser`      | `configparser` |
| `copy_reg`          | `copyreg`      |
| `Queue`             | `queue`        |
| `SocketServer`      | `socketserver` |
| `markupbase`        | `_markupbase`  |
| `repr`              | `reprlib`      |
| `test.test_support` | `test.support` |

### 选择Python 2 还是 Python 3呢？

如果是要开发一个新项目，不用考虑与老项目的兼容问题，最好是使用Python 3，因为就像Python官方说的那样，Python 3才是Python语言的将来。现在很多第三方类库已经完成了或者正在积极完成对Python 3的支持，只是有些项目由于过于庞大，很难在短时间内完成。我们需要考虑的最大问题在于，新项目中是否存在必须的第三方类库，且该类库当前还不支持Python 3。如果不存在这个问题，那坚定的选择Python 3吧。



## Python 环境搭建

### Windows

```shell
choco install Python 2 -y
choco install pip -y
python -m pip install --upgrade pip
```

### Mac OSX

```sh
$ brew install python   # Python 3 
$ brew install pip

$ brew cask install Caskroom/versions/anaconda2
```

### Linux

```sh
$ apt-get install -y python
```

### Docker

```shell
# 运行python命令行
# Python 3
$ docker run -it --rm python:alpine
# Python 2
$ docker run -it --rm python:2-alpine

# 运行Python 3脚本
$ docker run -it --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp python:alpine python your-daemon-or-script.py
# 运行Python 2脚本
$ docker run -it --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp python:2-alpine python your-daemon-or-script.py
```

### Python包

安装和深度学习相关的框架时，一般来说推荐使用系统自带的包管理，出现版本错误的可能性低一些。另外也可以使用一些提前配置好很多第三方库的Python包，这些包通常已经包含了深度学习框架中绝大多数的依赖库，比如最常用的是Anaconda：[Download Anaconda Now!](https://link.zhihu.com/?target=https%3A//www.continuum.io/downloads)

Windows下的Python安装简单一些，从官方网站下载相应的安装程序就可以了，当然也有更方便的已经包含了很全的第三方库的选择，WinPython：

[WinPython](https://link.zhihu.com/?target=http%3A//winpython.github.io/)

并且是绿色的，直接执行就可以用了。



## Python Hello World

### 交互模式

```python
# python
>>> print("Hello World!");
Hello World!
>>> 
```



### 执行文件模式

Python是一个动态的、强类型的、解释型的编程语言。而实际上，==解释型语言与编译型语言的界限正在变得模糊==。包括Python在内的很多高级编程语言，会将源代码先编译成特定类型的中间代码，然后再由解释器去执行，这样可以提高执行效率。Python的解释器同时也是生成Python中间代码的编译器，`.pyc`文件就是存放Python中间代码的文件。执行Python代码时，如果该源码文件导入了其他的`.py`文件，那么执行过程中会自动生成一个与导入的`.py`文件同名的`.pyc`文件。

磁盘上的文件都是以二进制格式存放的，其中文本文件都是以某种特定编码的字节形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用PyCharm来编写Python程序时会指定工程编码和文件编码为UTF-8，那么Python代码被保存到磁盘时就会被转换为UTF-8编码对应的字节（encode过程）后写入磁盘。当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为Unicode字符串（decode过程）之后才执行后续操作。

上面已经解释过，这个转换过程（decode，解码）需要我们指定文件中保存的字节使用的字符编码是什么，才能知道这些字节在Unicode这张万国码和统一码中找到其对应的代码点是什么。这里指定字符编码的方式大家都很熟悉，如下所示：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

print(u'中文测试正常')
```

![](http://images2015.cnblogs.com/blog/1063221/201612/1063221-20161213112530354-979116962.png)

- 第一行注释是为了告诉Linux/OS X系统，Python解释器路径，Windows系统会忽略这个注释；
- 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

通常Python脚本都是跑在Linux上的，为了让Python脚本文件可以像Shell脚本那样可以直接调用执行，我们通常需要在Python文件最开始的位置指定Python解释器路径，不建议写Python解释器的绝对路径。

Python 3的解释器默认使用Unicode编码，它本身是可以对中文字符进行编码和解码的，所以即便不指定字符编码也能正常运行，但是还是建议保留字符编码的声明。

那么，如果我们没有在代码文件开始的部分指定字符编码，Python解释器就会使用哪种字符编码把从代码文件中读取到的字节转换为Unicode代码点呢？就像我们配置某些软件时，有很多默认选项一样，需要在Python解释器内部设置默认的字符编码来解决这个问题，这就是文章开头所说的“默认编码”。因此大家所说的Python中文字符问题就可以总结为一句话：**当无法通过默认的字符编码对字节进行转换时，就会出现解码错误(UnicodeEncodeError)**。

Python 2和Python 3的解释器使用的默认编码是不一样的，我们可以通过`sys.getdefaultencoding()`来获取默认编码：

```python
# Python 2
import sys
sys.getdefaultencoding()         # 'ascii'

# Python 3
import sys
sys.getdefaultencoding()         # 'utf-8'
```

因此，对于Python 2来讲，Python解释器在读取到中文字符的字节码尝试解码操作时，会先查看当前代码文件头部是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果没有指定则使用默认字符编码"ASCII"进行解码导致解码失败，导致如下错误：

> SyntaxError: Non-ASCII character '\xc4' in file xxx.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details

对于Python 3来讲，执行过程是一样的，只是Python 3的解释器以"UTF-8"作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python 3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，导致如下错误：

> SyntaxError: Non-UTF-8 code starting with '\xc4' in file xxx.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details



### 使用IDE

#### PyCharm

PyCharm是由JetBrains打造的一款Python IDE，具备调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等功能。另外，PyCharm还提供了一些很好的功能用于Django开发，同时支持Google App Engine，更酷的是，PyCharm支持IronPython！

#### IPython

- ​


### [Grumpy](https://github.com/google/grumpy)

Grumpy 是一个 Python to Go 源代码翻译编译器和运行时，旨在替代 CPython 2.7。

关键的区别是它将 Python 源代码编译为 Go 源代码，然后将其编译为本机代码，而不是字节码。这意味着 Grumpy没有 VM。编译的 Go 源代码是对 Grumpy 运行时的一系列调用，Go 库服务与 Python C API 类似的目的（尽管不直接支持 C API）。

# Python语法

> **There should be one-- and preferably only one --obvious way to do it.**
>
> **对于一个特定的问题，应该只用最好的一种方法来解决。**
>
> ​                                                                                                               **-- Tim Peters**

学习一门编程语言，通常是学习该语言的以下几个部分的内容：

- **基础语法**：如，变量的声明与调用、基本输出语句、代码块语法、注释等；
- **数据类型**：通常都为 数字、字符串、布尔值、数组、链表、Map、Set等；
- **运算符**：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符等；
- **流程控制语句**：分支语句、循环语句；
- **类的定义与使用**：这个是面向对象编程语言才有的内容；
- **常用API的使用**：常用方法、工具类或模块的使用。

掌握上面的内容，就算是对一门编程语言入门了，剩下的就是不断的在使用和总结中去提升了。

## 注释

- 使用符号`#`开头注释单行内容
- 如果注释与代码在同一行，注释要写在代码的后面，且代码与`#`号之间至少要有`2`个空格，同时`#`号与注释内容之间至少要有`1`个空格。
- 使用三个单引号(`'''`)或三个双引号(`"""`)注释多行内容

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# 文件名：test.py

# 这是单行注释，以'#'开头
print("Hello World!");

# 如果注释与代码在同一行，注释要写在代码的后面，
# 且代码与‘#’号之间至少要有2个空格，同时‘#’号与注释内容之间至少要有1个空格。
print("你好，世界")  # 这是单行注释
 
'''
这是多行注释，使用单引号。
这是多行注释，使用单引号。
这是多行注释，使用单引号。
'''
 
"""
这是多行注释，使用双引号。
这是多行注释，使用双引号。
这是多行注释，使用双引号。
"""
```

## 变量

### 什么是变量

变量是存储在内存中的值。这就意味着，在创建变量时，会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。

存储在内存中的数据通常有两个属性：

- **在内存中的存放位置**：这个存放位置通过变量名可以找到；
- **在内存中的存放方式**：这个由数据类型决定，如占几个字节的空间、占用空间是否需要连续等。

Python中有很多内置类型(built-in types)，内置类型可以理解为构建在Python Interpreter(Python解释器)里面的类型。Python中主要的内置类型有以下几种：

- **numerics(数字)**：`int`、`float`、`complex`、`bool`、`long`（Python 2）
- **sequences(序列/有序集合)**： `str`、`list`、`tuple`、`range`
- **sets(无序集合)**：`set`
- **mappings(映射)**：`dict`
- **classes(类)**
- **instance(实例)**
- **exceptions(异常)**

Python中的容器是异常好用且异常有用的结构。主要包括列表（list），元组（tuple），字典（dict）和集合（set）。这些结构和其他语言中的类似结构并无本质不同。

Python定义变量无需指定变量类型，Python解释器会在运行时自动推断变量的数据类型。我们可以通过`type()`方法来查看变量类型。

Python中没有语法约束下的常量，仅仅是用完全大写字母的变量来表示这个变量不应该被改变。

### 变量的声明和赋值

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
  
counter = 100  # 赋值整型变量
miles = 1000.0 # 浮点型
name = "John"  # 字符串
 
print counter
print miles
print name

a = 1          # 整数
b = 1.2        # 浮点数
c = True       # 布尔类型
d = "False"    # 字符串
e = None       # NoneType
f = 1+2j       # 复数

# 在Python中利用type函数可以查看一个变量的类型：
type(a)        # <type 'int'>
type(b)        # <type 'float'>
type(c)        # <type 'bool'>
type(d)        # <type 'str'>
type(e)        # <type 'NoneType'>
type(f)        # <type 'complex'>

# Python可以同时为多个变量赋值，如
x, y = 1, 2    # x = 1 y = 2      
```

### 变量的命名规则

- 变量名只能是字母、数字或下划线的任意组合
- 变量名第一个字符不能是数字
- 关键字不能声明为变量名
- 变量类型是不需要声明的

以下关键字不能声明为变量名
[`'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield'`]

### 注意关键字

Python中，万物皆对象。一定要注意关键字，==因为所有东西都是对象，所以一个简简单单的赋值操作就可以把系统内置的函数给变成一个普通变量==，来看下边例子：

```python
id(type)                            # 506070640L
type = 1                            # type成了指向1的变量
id(type)                            # 35556792L
id = 2                              # id成了指向2的变量
from __future__ import print_function
print = 3                           # print成了指向3的变量
```

注意`print`是个很特殊的存在，在Python 3中是按照函数用，在Python 2中却是个命令式的语句，最早`print`的用法其实是下边这样：

```python
print "Hello world!"
```

这么用主要是受到ABC语法的影响，但这个用法并不Pythonic，后来加入了`print`函数，为了兼容允许两种用法并存。所以单纯给`print`赋值是不灵的，在Python 2中使用Python 3中的一些特性都是用`from __future__ import`来实现。

### 变量和引用

```python
# Python中基本变量的赋值一般建立的是个引用
a = 1
b = a
c = 1
# a赋值为1后，b=a执行时并不会将a的值复制一遍，然后赋给b，
# 而是简单地为a所指的值，也就是1建立了一个引用，相当于a和b都是指向包含1这个值的这块内存的指针。
# 所以c=1执行的也是个引用建立，这三个变量其实是三个引用，指向同一个值。

# Python内置了id函数，可以返回一个对象的地址，用id函数可以让我们知道每个变量指向的是不是同一个值：
id(a)   # 140533113576520
id(b)   # 140533113576520
id(c)   # 140533113576520

# 如果这时候我们接下面两个语句：
b = 2   # b的引用到新的一个变量上
id(b)   # 140533113576496
```

### 全局变量与局部变量

一个程序中的变量是有作用域的，作用域的大小会限制变量可访问的范围。根据作用域范围的大小不同可以分为：全局变量和局部变量。顾名思义，全局变量表示变量在全局范围内都可以被访问，而局部变量只能在一个很小的范围内生效。这就好比国家主席与各省的省长：在全国范围内国家主席都是同一个人，因此国家主席就是个全局变量；而各省的省长只能在某个省内生效，河北省省长是一个人，河南省省长又是另外一个人，因此省长就是个局部变量。

对于Python编程语言而言，定义在一个函数内部的变量就是一个局部变量，局部变量只能在其被声明的函数内访问；定义在函数外部的变量就是全局变量，全局变量可以在整个程序范围内访问。

结论：

- 函数内引用一个变量时，会先查找该函数内部是否存在这样一个局部变量，如果存在则直接引用该局部变量，否则将查找并引用全局变量；
- 对局部变量的赋值并不会对全局变量产生什么影响，因为它们本来就是两个不相关的变量。
- 可以在函数内部通过global关键字声明该局部变量就是全局变量。

```python
#!/usr/bin/env python
# -*- encoding:utf-8 -*-

name = 'Tom'

def func1():
    age = 10
    print(name)
    print(age)

def func2():
    sex = 'F'
    print(name)
    print(sex)

print(name)     # Tom
func1()         # Tom 10
func2()         # Tom F
# name是一个全局变量，因此它在程序的任何地方都可以被访问；
# 而func1函数中的age变量和func2函数中的sex变量都是局部变量，因此它们只能在各自定义的函数中被访问。

# 问题1：如果在函数内定义一个与全局变量同名的变量会怎样？
name = 'Tom'

def func3():
    name = 'Jerry'
    print(name)

print(name)     # Tom
func3()         # Jerry
print(name)     # Tom

# 问题2：如果想在上面示例中的函数内部为全局变量重新赋值怎么办？
# 可以在函数内部通过global关键字声明该局部变量就是全局变量：
name = 'Tom'

def func4():
    global name
    name = 'Jerry'
    print(name)

print(name)     # Tom
func4()         # Jerry
print(name)     # Jerry
# 全局name的值的确被func4函数内部的操作改变了。
```

**能不能将全局变量通过传参的方式传递给函数，然后在函数内部对全局变量做修改呢？**

变量值的改变通常有两种方式：(1) 重新赋值 (2) 改变原有值。要想在函数内部通过重新赋值来改变全局变量的值，则只能通过上面介绍的使用global关键字来完成，通过传参是无法实现的。而要想在函数内部改变全局变量的原有值的属性就要看该参数是值传递还是引用传递了，如果是引用传递则可以在函数内部对全局变量的值进行修改，如果是值传递则不可以实现。

### 值传递与引用传递

与 **“值传递与引用传递”** 相似的概念是 **“值拷贝与引用拷贝”**。前者主要是指函数调用时传递参数的时候，后者是指把一个变量赋值给其他变量或其他一些专门的拷贝操作（如深拷贝和浅拷贝）的时候。

这里我们需要先来说明下定义变量的过程是怎样的。首先，我们应该知道变量的值是保存在内存中的；以name='Tom'为例，定义变量name的过程是这样的：

1. 在内存中分配一块内存空间；
2. 将变量的值(字符串“Tom”)存放到这块内存空间；
3. 将这块内存空间的地址(门牌号)赋值给变量name；

也就是说变量保存的不是真实的值，而是存放真实值的内存空间的地址。

“值拷贝”和“值传递”比较好理解，就是直接把变量的值在内存中再复制一份；也就是说会分配并占用新的内存空间，因此变量指向的内存空间是新的，与之前的变量及其指向的内存空间没有什么关联了。而“引用拷贝”和“引用传递”仅仅是把变量对内存空间地址的引用复制了一份，也就是说两个变量指向的是同一个内存空间，因此对一个变量的值的修改会影响其他指向这个相同内存空间的变量的值。实际上，向函数传递参数时传递的也是实参的“值拷贝或引用拷贝”。

**因此当我们判断一个变量是否被修改时，只需要搞明白该变量所指向的内存地址以及该内存地址对应的内存空间中的值是否发生了改变即可。**

#### 示例1：

```python
name1 = 'Tom'
name2 = name1
name2 = 'Jerry'

print('name1: %s' % name1)
print('name2: %s' % name2)
```

> 思考：name1被改变了吗？

分析下上面操作的过程：

- 定义变量name1：在内存中开辟一块空间，将字符串'Tom'保存到该内存空间，然后name1指向该内存空间的地址；
  ![img](http://images2015.cnblogs.com/blog/1063221/201612/1063221-20161221150928354-73618366.png)
- 定义变量name2，并将name1赋值给它：实际上就是让name2也指向name1所指定的内存空间；
  ![img](http://images2015.cnblogs.com/blog/1063221/201612/1063221-20161221150933151-1979307964.png)
- 为变量name2重新赋一个新值：在内存中开辟一块新的空间，将字符串‘Jerry’保存到该内存空间，然后name2指向该内存空间的地址；
  ![img](http://images2015.cnblogs.com/blog/1063221/201612/1063221-20161221150938104-1019888778.png)

name1指向的内存地址发生改变了吗？-- 没有，因为name1并没有被重新进行赋值操作。

name1所指向的内存空间中的内容改变了吗？ -- 没有，并没有对它做什么，并且字符串本就是个常量，是不可能被改变的。

#### 示例2：

```python
num1 = 10
num2 = num1
num2 += 1

print('num1: %d' % num1)  # 10
print('num2: %d' % num2)  # 11
# 与示例1过程相似，只是+=操作也是一个赋值的过程，其他不再做过多解释。
```

#### 示例3：

```python
list1 = ['Tom', 'Jerry', 'Peter', 'Lily']
list2 = list1
list2.pop(0)

print('list1: %s' % list1)
print('list2: %s' % list2)
```

> 思考: list1被改变了吗？

分析上面操作的过程：

- 定义变量list1：在内存中开辟一块空间，将列表 `['Tom', 'Jerry', 'Peter', 'Lily'] `保存到该内存空间（列表在内存中的保存没这么简单，此处只是为了便于理解），然后list1指向该内存空间的地址；
- 定义变量list2，并将list1赋值给它：实际上就是让list2也指向list1所指定的内存空间；
- 移除list2中的一个元素，就是从list2指向的内存地址所对应的内存空间中的内容中移除一个元素；

list1指向的内存地址发生改变了吗？-- 没有，因为list1并没有被重新进行赋值操作。

list2所指向的内存空间中的内容改变了吗？ -- 是的，因为list1和list2指向的是同一个内存地址，通过list2修改了该内存地址中的内容后就相当于修改了list1。

#### 示例4：

其实函数参数的传递过程也是类似的，比如:

```python
num1 = 10
name1 = 'Tom'
list1 = ['Tom', 'Jerry', 'Peter', 'Lily']

def fun1(num2, name2, list2):
    num2 += 1
    name2 = 'Jerry'
    list2.pop(0)
    print('num2: %d' % num2)
    print('name2: %s' % name2)
    print('list2: %s' % list2)


fun1(num1, name1, list1)
print('num1: %d' % num1)
print('name1: %s' % name1)
print('list1: %s' % list1)
```

为了跟上面的示例做对比，我故意把func1函数中的形参的名称写为num2、name2和list2，实际上他们可以为任意有意义的名称。

#### Python中的参数传递都是引用传递

参数传递的过程实际上就像先拷贝，然后将拷贝传递给形参。如果是值拷贝，那么调用函数传参时就是值传递；如果是引用拷贝，那么调用函数传参时就是引用（内存地址）传递。其实通过上面的示例，我们大概可以猜测到对于列表类型的变量貌似是引用传递，但是数字和字符串类型的变量是值传递还是引用传递呢？**Python中的参数的传递都是引用传递**，关于这个问题我们可以通过Python内置的一个id()函数来进行验证。id()函数会返回指定变量所指向的内存地址，如果是引用传递，那么实参和被赋值后的形参所指向的内存地址肯定是相同的。事实上，确实如此，如下所示：

```python
num1 = 10
name1 = 'Tom'
list1 = ['Tom', 'Jerry', 'Peter', 'Lily']

def fun1(num2, name2, list2):
    print(id(num2), id(name2), id(list2))

print(id(num1), id(name1), id(list1))
fun1(num1, name1, list1)
```

输出结果：

```
1828586224 1856648389328 1856648385800
1828586224 1856648389328 1856648385800
```

实参和形参的内存地址一致，说明Python中的参数传递确实是“引用传递”。



## 输出和输入

### 输出

```python
# 用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。
>>> print('Hello World!');
Hello World!

# `print()`函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出
>>> print('The quick brown fox', 'jumps over', 'the lazy dog');
The quick brown fox jumps over the lazy dog
```

### 输入

很多时候都需要与用户进行交互，通过用户输入的内容来做下一步操作。这里需要说明的是，Python 2 与Python 3中接收用户输入的方法是不一样的。

- Python 2中接收用户输入时，主要使用的是`raw_input()`函数
- Python 3中接收用户输入时，主要使用的是`input()`函数
- 通过Python 2中的`raw_input()`与 Python 3中的`input() `获取到的值都是`str`类型，若想转换为其他数据类型需要进行强制类型转换
- Python 2中其实也有`input()`方法，但是通过这个`input()`方法获取的值是与输入内容的数据类型有关的，这很容易造成混乱，因此现在Python 2中很少用这个方法，而是用`raw_input()`代替了。

```python
# Python提供了一个input()函数，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：
# Python 3中的input() 即为 Python 2中的raw_input()
>>> name = raw_input("Enter your name: ")
Enter your name: Bolik
>>> print(name)
Bolik

# Python 3中的input() 即为 Python 2中的raw_input()
>>> name = raw_input("What is your name?");
What is your name?WaterBolik
>>> print("Hello " + name );
Hello WaterBolik

# 输入密码时，如果想要不可见，需要利用 getpass 模块中的 getpass 方法，即：
>>> import getpass;
>>> password = getpass.getpass("Please input your password：");
# 打印输入的内容
>>> print(passwd);
```

## 数据类型



### 数字类型Numerics

数字数据类型用于存储数值，是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。

Python 3 中的数字支持`int`(整型)、`float`(浮点型)、`complex`(复数)。Python文档中`bool`(布尔值)不属于数字类型，但是这里也把`bool`类型放在这里来说，因为`bool`是`int`的子类。就像大多是语言一样，Python中的数据类型也是很直观的。我们通过Python内置的`type()`函数可以查看变量所致的对象类型。

`bool`(布尔型)之所以属于数字类型，是因为`bool`是`int`的子类。

Python支持四种不同的数字类型：

- `int`（有符号整型）
- ==`long`（长整型[也可以代表八进制和十六进制]）仅Python 2支持==
- `float`（浮点型）
- `complex`（复数）
- `bool`（`True`和`False`，`1`和`0`）

#### 整数

Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：`1`，`100`，`-8080`，`0`，等等。

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用`0x`前缀和`0-9`，`a-f`表示，例如：`0xff00`，`0xa5b4c3d2`，等等。

Python 2 中的数字类型还包括一个`long`(长整型)，且会自动将超过整型长度的数字转换为长整型(数字最后加上`L`字母表示长整形)。但是Python 3中已经没有`long`类型了，`int`和`long`都叫整型(`int`)。

#### 浮点数

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如`1.23`，`3.14`，`-9.01`，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是`1.23e9`，或者`12.3e8`，0.000012可以写成`1.2e-5`，等等。

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

#### 布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值（请注意大小写），也可以通过布尔运算计算出来。

布尔值可以用`and`、`or`和`not`运算。

```
>>> TrueTrue>>> FalseFalse>>> 3 > 2True>>> 3 > 5False
```

布尔值可以用`and`、`or`和`not`运算。

#### 空值

空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。



```python
# 数字类型
a = 18         # 整数 int
type(a)        # <type 'int'>
b = 3.1        # 浮点 float
type(b)        # <type 'float'>
c = True       # 布尔 bool
type(c)        # <type 'bool'>
d = 7+3j       # 复数 complex
type(d)        # <type 'complex'>
e = 1000L      # 长整形 long
type(e)        # <type 'long'>

# 布尔型
t = True
f = False
type(t)        # <type 'bool'>

# Python实现了所有的布尔逻辑，但用的是英语，而不是我们习惯的操作符（比如&&和||等）。
print t and f # Logical AND; prints "False"
print t or f  # Logical OR; prints "True"
print not t   # Logical NOT; prints "False"
print t != f  # Logical XOR; prints "True"  
```

- 长整型也可以使用小写`l`，但是还是建议您使用大写`L`，避免与数字`1`混淆。Python使用`L`来显示长整型。
- Python还支持复数，复数由实数部分和虚数部分构成，可以用`a + bj`,或者`complex(a,b)`表示， 复数的实部`a`和虚部`b`都是浮点型


#### 强制类型转换

顾名思义，强制类型转换就是把一个数据类型强制转换为另一数据类型。这里，我们先说下数字类型(`int`、`float`、`bool`、`complex`)间的相互转换。

在Python解释器的交互式终端通过`help(bool)`可以查看`bool`类的完整定义，会发现`bool`是`int`类型的子类。另外`bool`类型只有两个值：`True`和`False`，因此`bool`与`int`类型的值必然存在某种关联。

- `bool`转`int`时，`Ture->1, False->0`
- `int`转`bool`时，`非0->True, 0->False`
- `bool`类型可以看作一个特殊的`int`类型
- `complex`类型不能强制转换为`int`和`float`类型

```python
# bool 转 int时， Ture->1, False->0
# int 转 bool时， 非0->True, 0->False
int(True)               # 1
int(False)              # 0
bool(1)                 # True
bool(-1)                # True
bool(0)                 # False
int(5.999999999999999)  # 5
int(5.9999999999999999) # 6
float(6)                # 6.0
```

#### 自动类型转换

自动类型转换是指两个不同类型的操作数参与运算时，Python会先按照以下规则先对其中一个操作数进行自动类型转换，然后再进行运算。

- 如果有一个操作数是复数，另一个操作数会被转换为复数
- 否则，如果有一个操作数是浮点型，另一个操作数会被转换为浮点型
- (Python 2)否则，如果有一个操作数是长整形，另一个操作数会被转换为长整型(`> 2**63`)
- 否则，如果有一个是整型，另一个是布尔型，则布尔型会被转换为整型`0`或`1`
- 否则，两个都是相同数据类型，无需类型转换

```python
2 + (5+2j)                # 整型转复数      (7+2j)
2.0 + (5+2j)              # 浮点型转复数    (7+2j)
True + (5+2j)             # 布尔型转复数    (6+2j)
2 + 5.0                   # 整型转浮点型    7.0
10L + 20                  # 整形转长整形     30L
True + 5.0                # 布尔型转浮点型   6.0
True + 2                  # 布尔型转整型     3
a = 9223372036854775807   # 9223372036854775807  <type 'int'>
b = 9223372036854775808   # 9223372036854775808L <type 'long'>
c = 2**63                 # 9223372036854775808L <type 'long'>
```



### 字符串

#### 字符串

字符串是以单引号`'`或双引号`"`括起来的任意文本，比如`'abc'`，`"xyz"`等等。请注意，`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串`'abc'`只有`a`，`b`，`c`这3个字符。如果`'`本身也是一个字符，那就可以用`""`括起来，比如`"I'm OK"`包含的字符是`I`，`'`，`m`，空格，`O`，`K`这6个字符。

如果字符串内部既包含`'`又包含`"`可以用转义字符`\`来标识。转义字符`\`可以转义很多字符，比如`\n`表示换行，`\t`表示制表符，字符`\`本身也要转义，所以`\\`表示的字符就是`\`。

如果字符串里面有很多字符都需要转义，就需要加很多`\`，为了简化，Python还允许用`r''`表示`''`内部的字符串默认不转义。

如果字符串内部有很多换行，用`\n`写在一行里不好阅读，为了简化，Python允许用`'''...'''`的格式表示多行内容。多行字符串`'''...'''`还可以在前面加上`r`使用。



字符串常用功能：移除空白、分割、长度、索引、切片


```python
# 字符串用双引号和单引号都可以，
# 区别主要是单引号字符串中如果出现单引号字符则需要用转义符，双引号也是一样，
# 所以在单引号字符串中使用双引号，或者双引号字符串中使用单引号就会比较方便。
s1 = '字符串1'
s2 = '字符串2中包含"test"内容'
s3 = "字符串1中保护'test'"

# 三个双引号或者三个单引号围起来的也是字符串，因为换行方便，更多用于文档。
s4 = '''
这里面的内容都是字符串
	这个做文档比较方便，保护内嵌"字符"
'''
s5 = """
这里面的内容都是字符串
	这个做文档比较方便，保护内嵌'字符'
"""

# 字符串前加r表示字符串内容严格按照输入的样子，好处是不用转义符了，非常方便。
s6 = r"123\t123"     # '123\\t123'
s7 = "123\t123"      # '123\t123'

# Python中字符串相关的处理都非常方便
a = 'Life is short, you need Python'
a.lower()              	    # 'life is short, you need Python'
a.upper()               	# 'LIFE IS SHORT, YOU NEED PYTHON'
a.count('i')            	# 2
a.find('e')             	# 从左向右查找'e'，3
a.rfind('need')         	# 从右向左查找'need'，19
a.replace('you', 'I')       # 'Life is short, I need Python'
tokens = a.split()    	    # ['Life', 'is', 'short,', 'you', 'need', 'Python']
b = ' '.join(tokens)	    # 用指定分隔符按顺序把字符串列表组合成新字符串
c = a + '\n'            	# 加了换行符，注意+用法是字符串作为序列的用法
c.rstrip()              	# 右侧去除换行符
[x for x in a]          	# 遍历每个字符并生成由所有字符按顺序构成的列表
'Python' in a   			# True

# 首字母变大写
# capitalize(self) 
"hello world".capitalize()					# 'Hello world'

# 内容居中
# center(self, width, fillchar=None)  
# width：总长度，
# fillchar：空白处填充内容，默认无
"hello world".center(20,"*")				# '****hello world*****'

# 子序列的个数
# count(self, sub, start=None, end=None) 
"hello world".count("l")					# 3

# 是否以XXX起始
# startswith(self, prefix, start=None, end=None) 
"hello world".startswith("h")				# True

# 判断字符串是否以XXX字符结束
# endswith(self, suffix, start=None, end=None)
"hello world".endswith("d")					# True

# 将tab转换成空格，默认一个tab转换成8个空格
# expandtabs(self, tabsize=None)
"hello\tworld".expandtabs()					# 'hello   world'

# 寻找子序列的位置，如果没找到，返回 -1 
# find(self, sub, start=None, end=None)
"hello world".find("o")						# 4

# 字符串格式化，动态参数
# format(*args, **kwargs)
"{} {}".format("James","24") 				# 'James 24'
"{1} {0} {1}".format("James","24") 	 		# '24 James 24'

# 子序列位置，如果没找到，报错
# index(self, sub, start=None, end=None)
"hello world".index("w") 					# 6

# 是否是字母和数字
# isalnum(self)
"hello3".isalnum()							# True
"hello world".isalnum()						# False
"123".isalnum()								# True
"hello".isalnum()							# True

# 是否是字母
# isalpha(self)
"hello".isalnum()							# True
"123".isalnum()								# True

# 是否是数字
# isdigit(self)
"123".isdigit()								# True
"hello".isdigit()							# False
"hello123".isdigit()						# False

# 是否小写
# islower(self)
"hello".islower()							# True
"Hello".islower()							# False

# 是否大写
# isupper(self)
"hello".isupper()							# False
"Hello".isupper()							# Fales
"HELLO".isupper()							# True

# 变小写
# lower(self)
'HELLO'.lower()								# 'hello'

# 变大写
# upper(self)
"hello".upper()								# 'HELLO'

# 大写变小写，小写变大写
# swapcase(self)
"Hello World".swapcase()					# 'hELLO wORLD'

# 内容左对齐，右侧填充
# ljust(self, width, fillchar=None)
"hello world".ljust(20,"*")					# 'hello world*********'

# 内容右对齐，左侧填充
# rjust(self, width, fillchar=None)
"hello world".rjust(20,"*")					# '*********hello world'

# 移除两端空白
# strip(self, chars=None)
"     hello world     ".strip()				# 'hello world'

# 移除左侧空白
# lstrip(self, chars=None)
"      hello world      ".lstrip()			# 'hello world      '

# 移除右侧空白
# rstrip(self, chars=None)
"      hello world      ".rstrip()			#'      hello world'

# 替换
# replace(self, old, new, count=None)
"hello world".replace("o","*")				# 'hell* w*rld'
```

Python 2.6中引入了`format`进行字符串格式化，相比在字符串中用`%`的类似`C`的方式，更加强大方便。

`format`在生成字符串和文档的时候非常有用，更多更详细的用法可以参考Python官网：

[7.1. string - Common string operations - Python 2.7.13 documentation](https://link.zhihu.com/?target=https%3A//docs.python.org/2/library/string.html%23format-specification-mini-language)

`format`中常见的占位符有：

|   占位符    | 描述                                       | 例子                                       | 结果                                       |
| :------: | :--------------------------------------- | :--------------------------------------- | :--------------------------------------- |
|   `d`    | 整数                                       | `'{:d}'.format(1000000)`                 | '100000'                                 |
|   `f`    | 浮点数                                      | `'{:.6f}'.format(0.0001)`                | '0.000100'                               |
|   `e`    | 科学记数法                                    | `'{:.1e}'.format(0.0001)`                | '1.0e-4'                                 |
|   `g`    | 自动选择                                     | `'{:g}'.format(0.0001)`                  | '0.0001'                                 |
|   `s`    | 字符串                                      | `'{:s}'.format('123abc')`                | '123abc'                                 |
|   `x`    | 十六进制                                     | `'{:x}'.format(1612)`                    | '64c'                                    |
|   `%%`   | 表示一个%                                    | `'growth rate: %d %%' % 7`               | 'growth rate: 7 %'                       |
|   `>`    | 右对齐，`>`前为填充字符                            | `' {:0>6d}'.format(1)`                   | '000001'                                 |
|   `<`    | 左对齐，`<`前为填充字符                            | `'{:-<10}'.format(’****‘)`               | ’****------'                             |
|   `{}`   | 按顺序格式化                                   | `'I’m like a {} chasing {}.' .format('dog', 'cars')` | 'I’m like a dog chasing cars.'           |
|  `{1}`   | 在大括号中指定参数所在位置                            | `'I prefer {1} {0} to {2} {0}' .format('food', 'Chinese', 'American')` | 'I prefer Chinese food to American food' |
| template | `template = '{name} is {age} years old.'` | `template.format(name='Tom', age=8))`    | 'Tom is 8 years old.'                    |

```python
a = 'I’m like a {} chasing {}.'
# 按顺序格式化字符串，'I’m like a dog chasing cars.'
a.format('dog', 'cars')

# 在大括号中指定参数所在位置
b = 'I prefer {1} {0} to {2} {0}'
b.format('food', 'Chinese', 'American')

# >代表右对齐，>前是要填充的字符，依次输出：
# 000001
# 000019
# 000256
for i in [1, 19, 256]:
    print('The index is {:0>6d}'.format(i))

# <代表左对齐，依次输出：
# *---------
# ****------
# *******---
for x in ['*', '****', '*******']:
    progress_bar = '{:-<10}'.format(x)
    print(progress_bar)

for x in [0.0001, 1e17, 3e-18]:
    print('{:.6f}'.format(x))               # 按照小数点后6位的浮点数格式
    print('{:.1e}'.format(x))               # 按照小数点后1位的科学记数法格式
    print ('{:g}'.format(x))                # 系统自动选择最合适的格式

template = '{name} is {age} years old.'
c = template.format(name='Tom', age=8))     # Tom is 8 years old.
d = template.format(age=7, name='Jerry')    # Jerry is 7 years old.
```

### 字符编码

Python 2的**默认编码**是ASCII，不能识别中文字符，需要显式指定字符编码；Python 3的**默认编码**为Unicode，可以识别中文字符。

其实Python 3中对字符串支持的改进，不仅仅是更改了默认编码，而是重新进行了字符串的实现，而且它已经实现了对Unicode的内置支持，从这方面来讲Python已经和Java一样优秀。

#### Python 2

Python 2中对字符串的支持由以下三个类提供

- `class basestring(object)`
- `class str(basestring)`
- `class Unicode(basestring)`

执行`help(str)`和`help(bytes)`会发现结果都是`str`类的定义，这也说明Python 2中`str`就是字节串，而后来的`Unicode`对象对应才是真正的字符串。

**Python 2中的字符串进行字符编码转换过程是：**

字节串-->`decode('原来的字符编码')`-->Unicode字符串-->`encode('新的字符编码')`-->字节串

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

a = '你好'
b = u'你好'

print(type(a), len(a))     # (<type 'str'>, 6)
print(type(b), len(b))     # (<type 'Unicode'>, 2)

utf_8_a = '你好,我爱中国'                            
# '\xe4\xbd\xa0\xe5\xa5\xbd,\xe6\x88\x91\xe7\x88\xb1\xe4\xb8\xad\xe5\x9b\xbd'
gbk_a = utf_8_a.decode('utf-8').encode('gbk')
# '\xc4\xe3\xba\xc3,\xce\xd2\xb0\xae\xd6\xd0\xb9\xfa'
gb2312_a = utf_8_a.decode('utf-8').encode('gb2312')
# '\xc4\xe3\xba\xc3,\xce\xd2\xb0\xae\xd6\xd0\xb9\xfa'
decode_a = utf_8_a.decode('utf-8')
# u'\u4f60\u597d,\u6211\u7231\u4e2d\u56fd'
print(gbk_a.decode('gbk'))
# 我爱中国
```

#### Python 3

Python 3中对字符串的支持进行了实现类层次的上简化，去掉了`Unicode`类，添加了一个`bytes`类。从表面上来看，可以认为Python 3中的`str`和`Unicode`合二为一了。

- `class bytes(object)`
- `class str(object)`

实际上，Python 3中已经意识到之前的错误，开始明确的区分字符串与字节。因此Python 3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。也就是说，Python 3默认定义的就是字符串，实现了对Unicode的内置支持，减轻了程序员对字符串处理的负担。

**Python 3中定义的字符串默认就是Unicode，因此不需要先解码，可以直接编码成新的字符编码：**

字符串-->`encode('新的字符编码')`-->字节串

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

a = 'Bolik,你好'
b = u'Bolik,你好'
c = 'Bolik,你好'.encode('gbk')
d = 'Bolik,你好'.encode('gb2312')
e = 'Bolik,你好'.encode('utf8')

print(type(a), len(a))       # <class 'str'>    8 = 1 * 6 + 1 * 2 
print(a)                     # Bolik,你好    
print(type(b), len(b))       # <class 'str'>    8 = 1 * 6 + 1 * 2 
print(b)                     # Bolik,你好
print(type(c), len(c))       # <class 'bytes'> 10 = 1 * 6 + 2 * 2 
print(c)                     # b'Bolik,\xc4\xe3\xba\xc3'
print(type(d), len(d))       # <class 'bytes'> 10 = 1 * 6 + 2 * 2 
print(d)                     # b'Bolik,\xe4\xbd\xa0\xe5\xa5\xbd'
print(type(e), len(e))       # <class 'bytes'> 12 = 1 * 6 + 3 * 2 
print(e)                     # b'Bolik,\xc4\xe3\xba\xc3'

a = '你好,我爱中国'    
utf_8_a = a.encode('utf8')
# b'\xe4\xbd\xa0\xe5\xa5\xbd,\xe6\x88\x91\xe7\x88\xb1\xe4\xb8\xad\xe5\x9b\xbd'
gbk_a = a.encode('gbk')
# '\xc4\xe3\xba\xc3,\xce\xd2\xb0\xae\xd6\xd0\xb9\xfa'
gb2312_a = a.encode('gb2312')
# '\xc4\xe3\xba\xc3,\xce\xd2\xb0\xae\xd6\xd0\xb9\xfa'
print(gbk_a.decode('gbk'))
# 你好,我爱中国
```



```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

# Python 3的字符串支持多语言，Python 2仅支持部分功能
print('包含中文的str')                        # 包含中文的str
# 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：
# Python 2版本中仅支持ASCII码 chr() arg not in range(256)
ord('A')                                    # 65
ord('中')                                   # 20013
chr(66)                                     # 'B'
chr(25991)                                  # '文'
# 如果知道字符的整数编码，还可以用十六进制这么写str：
'\u4e2d\u6587'                              # '中文'

# 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。
# 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。
# Python对bytes类型的数据用带b前缀的单引号或双引号表示：
x = b'ABC'                                  # b'ABC'
y = 'ABC'                                   # 'ABC'
print(x)                                    # b'ABC'
print(y)                                    # ABC
# 要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

# 以Unicode表示的str通过encode()方法可以编码为指定的bytes
'ABC'.encode('ascii')                       # b'ABC'
'中文'.encode('utf-8')                       # b'\xe4\xb8\xad\xe6\x96\x87'
'中文'.encode('ascii')                       
# UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: 
# ordinal not in range(128)
# 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。
# 含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。
# 在bytes中，无法显示为ASCII字符的字节，用\x##显示。

# 把bytes变为str，用decode()方法：
b'ABC'.decode('ascii')                       # 'ABC'
b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')  # '中文'

# 用len()函数计算str包含多少个字符：
len('ABC')                                   # 3
len('中文')                                   # 2 (Python 2结果为6)

# len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：
len(b'ABC')                                  # 3
len(b'\xe4\xb8\xad\xe6\x96\x87')             # 6
len('中文'.encode('utf-8'))                   # 6
```



### 序列类型Sequence

Python中的序列主要以下几种类型：

- 3种基本序列类型(Basic Sequence Types)：`list`、`tuple`、`range`
- 专门处理文本的附加序列类型(Text Sequence Types)：`str`
- 专门处理二进制数据的附加序列类型(Binary Sequence Types)：`bytes`、`bytearray`、`memoryview`

按照序列是否可被改变分类：

- 可变序列：`list`
- 不可变序列：`tuple`、`str`

#### 序列操作

##### 通用序列操作

这里说的通用序列操作是指大部分可变序列与不可变序列都支持的操作。一般操作包括 增、删、改、查，但是这里说的是包括不可变序列也支持的通用操作，因此只能是“查”操作。

###### 符号说明：

| **符号**               | **说明**              |
| -------------------- | ------------------- |
| `s,t`                | 表示相同类型的序列           |
| `n,i,j,k`            | 表示整数数值              |
| `x`                  | 表示序列中满足条件约束的任意类型的元素 |
| `in`(被包含) 和 `not in` | 具有与比较操作相同的优先级       |
| `+`（连接）和`*`（重复）      | 具有与相应数字操作相同的优先级。    |

序列通用操作及结果说明：

| **操作**                 | **结果**                                   |
| ---------------------- | ---------------------------------------- |
| `x in s`               | 如果序列s中包含x对象则返回`True`，否则返回`False`         |
| `x not in s`           | 如果序列s中不包含x对象则返回`True`，否则返回`True`         |
| `s + t`                | 对序列`s`和序列`t`做连接操作                        |
| `s * n` 或 `n * s`      | 等价于`n`个`s`相加                             |
| `s[i]`                 | 表示序列`s`的第`i`个元素，`i`初始值为`0`               |
| `s[i:j]`               | 序列`s`从下标`i`到下标`j`的切片(包含`s[i]`，但不包含`s[j]`) |
| `s[i:j:k]`             | 序列`s`从下标`i`到下标`j`的切片，且步长为`k`             |
| `len(s)`               | 序列`s`的长度                                 |
| `min(s)`               | 序列`s`中的最小值                               |
| `max(s)`               | 序列中的最大值                                  |
| `s.index(x[, i[, j]])` | `x`在序列`s`中从下标`i`开始到下标`j`之前范围内第一次出现的位置    |
| `s.count(x)`           | `x`在序列`s`中出现的总次数                         |

###### 说明:

1. 对于序列来说，其元素的数字类型是不做严格区分的，如`True=1=1.0`，`False=0=0.0`；
2. 相同类型的序列也支持比较操作，特别是`tuple`和`list`是通过比较对应元素的字典顺序来进行比较的。这意味着要判断两个序列相等，就需要这两个序列中的每个元素都相等，并且这两个序列必须是相同类型且长度相等。

###### 注意：

1. 虽然`in`和`not in`操作只用于一般情况下的简单容器测试，但一些专用序列（如`str`，`bytes`和`bytearray`）也用于子序列测试。
2. 如果`s * n`中`n`小于`0`，则`n`会被当做`0`看待；`s * 0`的结果是产生一个与`s`相同类型的空序列。
3. 对于`s * n`操作，`s`序列中的元素没有被复制，他们只是被引用了多次。
4. 对于序列的切片操作`s[i:j[:k]]`，如果`i`或`j`负数，则索引是相对于字符串的尾部来计算的。如果`i`是负数，则`i`相当于`len(s)+i`，如果`j`是负数，则`j`相当于`len(s)+j`。
5. 还是对于序列的切片操作`s[i:j[:k]]`，其中`i`与`j`的值有如下几种情况：
   - 如果i或j为负数，则先替换为`len(s)+i`或`len(s)+j`再进行如下比较；
   - 如果i或j大于`len(s)`，则其值取`len(s)`；
   - 如果i被忽略或为`None`，则其值取`0`；
   - 如果j被或略或为`None`，则其值取`len(s)`；
   - 如果i的值比j大，则切片结果为空序列。

   如果步长k被指定，则切片结果中的元素为`i,i+k,i+2k,i+3k,...`到`j`的前一个元素停止。`k`的值不能为`0`，如果`k`为`None`则其值取`1`。
6. 连接不可变序列时总是会导致产生一个新的对象。这意味着通过重复连接构建序列将会在在总序列长度中具有二次运行时成本。要获得线性运行成本，必须切换到以下选项之一：
   - 如果连接`str`对象，可以构建一个列表，并在结尾使用`str.join()`方法进行连接；或者写入`io.String()`实例并在完成时检索其值；
   - 如果连接`bytes`对象，可以类似地使用`bytes.join()`方法或`io.BytesIO`，或者可以使用`bytearray`对象进行就地连接；`bytearray`是可以变的，并且具有有效的覆盖分配机制；
   - 如果连接`tuple`对象，请使用扩展`list`的方式替代；
   - 对于其他类型，请查看相关类文档；
7. 一些序列类型(例如 `range`)仅支持遵循特定模式的元素序列，因此不支持序列的连接和重复操作。
8. 对于`s.index(x[, i[, j]])`操作，当在序列`s`中找不到`x`元素时，`index`会抛出`ValueError`。另外，附加参数`i,j`允许对该序列的子序列进行有效的查找，这大致相当于`s[i,j].index(x)`，但是不会拷贝任何数据且返回的索引值是相对于序列的开始位置而不是相对于切片的开始位置。

```python
# 虽然in 和 not in操作只用于一般情况下的简单容器测试，
# 但一些专用序列(如str,bytes和bytearray)也用于子序列测试。
"ll" in "hello"                       # True

# 如果s * n中n小于0，则n会被当做0看待；s * 0的结果是产生一个与s相同类型的空序列。
'ss' * 2                              # 'ssss'
'ss' * -2                             # ''
["Tom", "Peter", "Jerry"] * -2        # []
>>> ("Tom", "Peter", "Jerry") * -2    # ()

# 对于s * n操作，s序列中的元素没有被复制，他们只是被引用了多次。
lists = [['a']] * 3                   # [['a'], ['a'], ['a']]
lists[0].append('b')                  # [['a', 'b'], ['a', 'b'], ['a', 'b']]

# 对于序列的切片操作s[i:j[:k]]，如果i或j负数，则索引是相对于字符串的尾部来计算的。
# 如果i是负数，则i相当于len(s)+i，如果j是负数，则j相当于len(s)+j。
[0,1,2,3,4,5,6,7,8,9][-1]             # 9
[0,1,2,3,4,5,6,7,8,9][-5:-1]          # [5, 6, 7, 8]
[0,1,2,3,4,5,6,7,8,9][1:-1]           # [1, 2, 3, 4, 5, 6, 7, 8]

# 对于序列的切片操作s[i:j[:k]]，其中i与j的值有如下几种情况：
#     如果i或j为负数，则先替换为len(s)+i或len(s)+j再进行如下比较；
#     如果i或j大于len(s)，则其值取len(s)；
#     如果i被忽略或为None，则其值取0；
#     如果j被忽略或为None，则其值取len(s)；
#     如果i的值比j大，则切片结果为空序列。
s = (0,1,2,3,4,5,6,7,8,9)
len(s)                                # 10
s[6:12]                               # (6, 7, 8, 9)
s[:5]                                 # (0, 1, 2, 3, 4)
s[5:]                                 # (5, 6, 7, 8, 9)
s[9:5]                                # ()
# 如果步长k被指定，则切片结果中的元素为i,i+k,i+2k,i+3k,...到j的前一个元素停止。
# k的值不能为0，如果k为None则其值取1。
s[1::2]                               # (1, 3, 5, 7, 9)
s[0::2]                               # (0, 2, 4, 6, 8)
s[0::0]                               # ValueError: slice step cannot be zer
```

##### 可变序列操作

这里来说下可变序列类型支持，而不可变序列类型不支持的操作。在序列通用操作中主要说明的是“查”操作，这里要说的是可变序列的 "增"、“删”、“改”操作。

###### 符号说明：

| **符号** | **说明**                                   |
| ------ | ---------------------------------------- |
| `s`    | 表示一个可变序列类型的实例                            |
| `t`    | 表示任何一个可迭代对象                              |
| `x`    | 表示序列`s`中满足条件约束的任意类型的元素（例如，`bytearray`只接受满足`0 <= x <=255`约束的整型值） |

###### 可变序列支持的操作及结果说明：

| **操作**                | **结果**                                   |
| --------------------- | ---------------------------------------- |
| `s[i] = x`            | 将序列`s`中小标为`i`的元素用`x`替换                   |
| `s[i:j] = t`          | 将序列`s`中从`i`到`j`的切片用可迭代对象`t`的内容替换         |
| `s[i:j:k] = t`        | `s[i:j:k]`中的元素用可迭代对象`t`的内容替换             |
| `s *= n`              | 更新序列`s`为`s`的`n`次重复的结果                    |
| `del s[i:j]`          | 删除序列`s`中从`i`到`j`的切片，等价于 `s[i:j] = []`    |
| `del s[i:j:k]`        | 从序列`s`中删除`s[i:j:k]`中的元素                  |
| `s.pop() / s.pop(i)`  | 获取序列`s`中下标为`i`的元素，并从序列`s`中删除该元素；`i`默认为`-1`，即默认删除并返回序列`s`的最后一个元素 |
| `s.remove(x)`         | 从序列`s`中移除第一个等于`x`(即：`s[i] == x `)的元素；如果`x`在序列`s`中不存在，则会抛出`ValueError` |
| `s.clear()`           | 移除序列`s`中的所有元素，等价于 `del s[:]`             |
| `s.append(x)`         | 将`x`追加到序列`s`的末尾，等价于 `s[len(s):len(s) = [x]]` |
| `s.extend(t) or s+=t` | 将可迭代对象`t`中的元素拼接到序列`s`的末尾，大部分时候等价于 `s[len(s):len(s)] = t` |
| `s.insert(i,x)`       | 在序列`s`中下标为`i`的位置插入`x`                    |
| `s.copy()`            | 创建一个序列`s`的浅拷贝，等价于 `s[:]`                 |
| `s.reverse()`         | 反转序列`s`中元素的位置，该方法直接对序列`s`本身做修改(可以节约空间)，不会返回被反转后的序列 |

###### 注意：

- 可变序列的`clear()`和`copy()`方法是在Python 3.3中新加的方法，是为了与`dict`、`set`这些不支持切片操作的容器所提供的接口保持一致性。
- 对于 `s *= n`操作，如果`n`小于`0`或等于`0`，序列`s`将被清空；另外如果`n`大于`1`，序列`s`并没有被复制，它们只是被引用了多次，这与序列通用操作中的`s *n`是一样的。

##### 不可变序列操作

不可变序列类型通常实现而可变序列没有实现的唯一操作是对内建`hash()`方法的支持。对内建`hash()`的支持允许不可变序列（例如`tuple`）用作`dict`的键并存储在`set`和`frozenset`的实例中。如果尝试`hash`一个包含不可被`hash`的数据的不可变序列会导致`TypeError`错误。



#### 基本序列（basic sequences）

Python中的基本序列类型包括: `list`、`tuple`、`range`，而`str`属于特殊序列类型，专门用于处理文本序列，这个后面单独进行说明。

##### 列表Lists

Python中的列表是可变序列，通常用于存储相同类型的数据集合，当然也可以存储不同类型数据。Python中的列表表现形式有点像其他语言中的数组：列表中的元素是用方括号[]括起来，以逗号进行分割。==List实现了所有通用(common)序列操作和可变序列(mutable sequence)操作==。

###### List的构建方式

- 使用方括号，用逗号分隔各条目：`[]`，`['a']`， `[a, b, c]`
- 使用类型构造函数：`list()`，`list(iterable)`
- 使用列表生成式：`[x for x in iterable]`

列表构造函数`list(iterable)`会创建一个与可迭代对象`iterable`中的条目及条目顺序都相同的列表。可迭代对象`iterable`可以是一个序列(`sequence`)、一个支持迭代操作的容器(`container`)，也可以是一个迭代器对象(`iterator object`)。如果`iterable`已经是一个`list`，则创建一个`copy`并返回，类似于`iterable[:]`。如果没有指定参数，列表构造函数会创建一个新的空`list,[]`。

```python
# list类构建函数
class list([iterable])                       # 这里的方括号表示iterable是可选项

# 创建list示例
list1 = []                                   # 空列表 []
list2 = ["Tom", "Jerry", "Lucy", "Peter"]    # 非空列表
list3 = list()                               # 列表构造函数创建空列表
list4 = list(list2)                          # 列表Copy构建
list5 = [x for x in list2]                   # 列表生成式

# list通用序列操作示例
s = [1, 2, 3, 'a', 'b', 'c']
1 in s                          # 包含判断 True
1.0 in s                        # 数字不严格区分类型(1==1.0==True) True
1 not in s                      # 不包含判断 False
s + ['d', 'e', 'f']             # 拼接操作 [1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f']
s * 2                           # 重复2次 [1, 2, 3, 'a', 'b', 'c', 1, 2, 3, 'a', 'b', 'c']
s[3]                            # 获取下标为3的条目 'a'
s[3:6]                          # 获取序列s的切片，下标分别为 3,4,5  ['a', 'b', 'c']
s[1:6:2]                        # 获取序列s的切片，步长为2，下标分别为 1,3,5  [2, 'a', 'c']
len(s)                          # 获取序列长度 6
min(s)                          # min()和max()的参数中，数据类型需要有可比性 
# TypeError: unorderable types: str() < int()
max([1, 2, 3, 4.0, 5.0])                  # 5.0
min([1, 2, 3, 4.0, 5.0, False])           # False
[1, 2, 3, 4, 2, 5, 6, 3, 2].index(2)      # 获取2在序列s中第一次出现的下标位置 1
[1, 2, 3, 4, 2, 5, 6, 3, 2].index(2, 3)   # 获取序列s从下标3开始查找2第一次出现的下标位置 4
s.count(2)                                # 统计2在序列s中出现的次数 1
[1, 2, 3, 4, 2, 5, 6, 3, 2].count(2)      # 3
len([1, 2, 3, 4, 5])                      # 获取序列长度 5

# list可变序列操作示例
s = [1, 2, 3, 4]
s.append(5)             # 向list末尾追加一个条目           
s                       # [1, 2, 3, 4, 5]
s.insert(0,0)           # 向list开始位置插入一个条目        
s                       # [0, 1, 2, 3, 4, 5]
s.extend([6, 7, 8, 9])  # 扩展list, 向list末尾拼接多个条目  
s                       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
s[9] = 99               # 将list中下标为9的条目替换为99     
s                       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 99]
s[6:9] = ['a', 'b']     # 将list中范围为从6到9(不包含9)的切片替换为['a', 'b']
                        # [0, 1, 2, 3, 4, 5, 'a', 'b', 99]
s[6:10]=['A','B']       # 同上，此处10为list的长度，表示切片范围是到list末尾的
                        # [0, 1, 2, 3, 4, 5, 'A', 'B']
s.pop()                 # 移除list末尾的条目 'B'
                        # [0, 1, 2, 3, 4, 5, 'A']
s.pop(5)                # 移除list中下标为5的条目 5
s                       # [0, 1, 2, 3, 4, 'A']
s.remove('A')           # 移除list中的指定条目'A'
s                       # [0, 1, 2, 3, 4]
del s[1:5:2]            # 删除list中下标为 1,3 的条目
s                       # [0, 2, 4]
s.reverse()             # 将list中元素位置进行反转，list本身发生改变
s                       # [4, 2, 0]
s.copy()                # list浅拷贝，list本身不发生改变 
s                       # [4, 2, 0]
s *= 2                  # 相当于 s = s * 2
s                       # [4, 2, 0, 4, 2, 0]
```

###### List支持的额外操作

`sort(*, key=None, reverse=None)`

此方法仅`s`使用`<`符号进行列表项目之间的比较，即默认对列表进行升序排序。排序过程中的异常不会被捕获，也就是说如果任何比较操作失败，整个排序操作将失败，并且列表可能保留部分已修改状态。

`sort()`只能通过关键字（仅限关键字参数）传递的两个参数如下：

- **`key`** : 指定一个函数，该函数用于从每个列表元素提取用于进行比较操作的键，如`key = str.lower`。列表中每一个条目对应的键都会被计算一次，然后用于整个排序过程。默认值`None`表示列表条目将会被直接排序，而不会计算出一个单独的用于比较的键值。
- **`reverse`** : 是一个布尔值，如果其值为`True`，则列表中的元素将会按照比较方法的反序进行排序。

**说明：**

`sort()`方法会直接修改`list`，这在对大列表进行排序时可以节约空间；该方法的副作用是不会返回排序后的`list`，可以使用`sorted()`显示请求一个新的排序后的`list`实例；

`sorted(iterable, cmp=None, key=None, reverse=False)` --> `new sorted list`

`sort()`方法保证稳定性。如果能保证两个比较相当的元素不会改变相对位置，那么这个排序就是稳定的，这有助于通过多个条件进行排序，比如`先按部门排序，然后再按工资级别排序`。

CPython实现细节：当一个列表正在被排序时，如果尝试修改或检测列表，效果是列表为定义。Python的C实现使得列表在持续时间内显示为空，并且如果它检测到列表在排序期间已发生改变，则会抛出`ValueError`错误。

```python
# List支持的附加操作
s = ['A', 'b', 'C', 'd', 'e']
s.sort()
s                                      # ['A', 'C', 'b', 'd', 'e']
s.sort(key=str.lower)
s                                      # ['A', 'b', 'C', 'd', 'e']
s.sort(key=str.upper)
s                                      # ['A', 'b', 'C', 'd', 'e']
s.sort(key=str.upper, reverse=True)
s                                      # ['e', 'd', 'C', 'b', 'A']
s.sort(reverse=True)
s                                      # ['e', 'd', 'b', 'C', 'A']
sorted(s)                              # ['A', 'C', 'b', 'd', 'e']
# sorted()可以对任何可迭代对象进行排序，不会对原数据进行修改且会返回一个排序后的实例
s                                      # ['e', 'd', 'b', 'C', 'A']
```

列表示例：

```python
list1 = ['James', 786 , 2.23, 'john', 70.2]
# list2 = list['James', 786 , 2.23, 'john', 70.2]
tinylist = [123, 'john']

# 切片Slicing：为了一次性地获取列表中的元素，Python提供了一种简洁的语法，这就是切片。
print(list1)              # 输出完整列表
print(list1[0])           # 输出列表的第一个元素
print(list1[1:3])         # 输出第二个至第三个的元素
print(list1[2:])          # 输出从第三个开始至列表末尾的所有元素
print(tinylist * 2)       # 输出列表两次
print(list1 + tinylist)   # 打印组合的列表

# 使用列表推导，你就可以让代码简化很多：
nums = [0, 1, 2, 3, 4]
squares = [x ** 2 for x in nums]
print squares   # Prints [0, 1, 4, 9, 16]

# 列表推导还可以包含条件：
nums = [0, 1, 2, 3, 4]
even_squares = [x ** 2 for x in nums if x % 2 == 0]
print even_squares  # Prints "[0, 4, 16]"

a = [1, 2, 3, 4]
b = [1]
c = [1]
d = b
e = [1, "Hello world!", c, False]
print(id(b), id(c))                 # (194100040L, 194100552L)
print(id(b), id(d))                 # (194100040L, 194100040L)
print(b == c)                       # True
f = list("abcd")
print(f)                            # ['a', 'b', 'c', 'd']
g = [0]*3 + [1]*4 + [2]*2	        
print(g)                            # [0, 0, 0, 1, 1, 1, 1, 2, 2]
# 因为变量其实是个引用，所以对列表而言也没什么不同，所以列表对类型没什么限制。
# 也正因为如此，和变量不同的是，即使用相同的语句赋值，列表的地址也是不同的，
# 在这个例子中体现在id(b)和id(c)不相等，而内容相等。
# 列表也可以用list()初始化，输入参数需要是一个可以遍历的结构，其中每一个元素会作为列表的一项。
# “*”操作符对于列表而言是复制，最后一个语句用这种办法生成了分段的列表。

# 列表的基本操作有访问，增加，删除，和拼接：
# append(self, p_object)
name = ["James","Kobe","Yao"]
name.append("Rose")
print(name)              # ['James', 'Kobe', 'Yao', 'Rose']

# count(self, value)
name = ["James","Kobe","Yao","James"]
name.count("James")      # 2

# extend(self, iterable)
name1 = ["Kobe","James","Yao"]
name2 = ["Ronaldo","Henry"]
name1.extend(name2)
print(name1)             # ['Kobe', 'James', 'Yao', 'Ronaldo', 'Henry']

# index(self, value, start=None, stop=None)
name = ["James","Kobe","Yao","James"]
name.index("Yao")        # 2

# insert(self, index, p_object)
name = ["James","Kobe","Yao","James"]
name.insert(2,"Henry")
print(name)             # ['James', 'Kobe', 'Henry', 'Yao', 'James']

# pop(self, index=None)
name = ["James","Kobe","Yao","James"]
name.pop()              # 'James'
print(name)             # ['James', 'Kobe', 'Yao']

# remove(self, value)
name = ["James","Kobe","Yao","James"]
name.remove("James")
print(name)             # ['Kobe', 'Yao', 'James']

# reverse(self)
name = ["James","Kobe","Yao"]
name.reverse()
print(name)             # ['Yao', 'Kobe', 'James']

# sort(self, cmp=None, key=None, reverse=False)
name = ["Ronaldo","Kobe","James","Yao","123"]
name.sort()
print(name)             # ['123', 'James', 'Kobe', 'Ronaldo', 'Yao']

# 因为列表是有顺序的，所以和顺序相关的操作是列表中最常见的，
# 首先我们来打乱一个列表的顺序，然后再对这个列表排序：
import random
a = range(10)                 # 生成一个列表，从0开始+1递增到9
print(a)                       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
random.shuffle(a)             # shuffle函数可以对可遍历且可变结构打乱顺序
print(a)                       # [4, 3, 8, 9, 0, 6, 2, 7, 5, 1]
b = sorted(a)               
print(b)                       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
c = sorted(a, reverse=True)
print(c)                       # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```



##### 元组Tuples

Tuple是不可变序列，通常用于存储异构数据集合，例如由内置函数`enumerate()`产生的`2`元组。元组还用于同构数据的不可变序列的情况，例如允许在`set`或`dict`实例中存储。Tuple支持所有通用序列操作，但不支持可变序列操作。

###### Tuple的构建方式

- 使用一对小括号表示空元组：`()`
- 对单个元组要使用逗号结尾：`a, `或 `(a, )`
- 多个条目要使用逗号分隔：`a, b, c` 或` (a, b, c)`
- 使用内置函数`tuple()` 或 `tuple(iterable)`

Tuple构造函数`tuple(iterable)`会创建一个与可迭代对象`iterable`中的条目及条目顺序都相同的元祖。可迭代对象`iterable`可以是一个序列(`sequence`)、一个支持迭代操作的容器(`container`)，也可以是一个迭代器对象(`iterator object`)。如果`iterable`已经是一个`tuple`，则直接返回这个`tuple`。如果没有指定参数，元组构造函数会创建一个新的空`tuple, ()`。

**说明:**

==实际上是逗号产生了一个元祖，而不是小括号==。除了空元组的情形或者需要避免语法模糊的时候外，小括号是可选的。例如`f(a, b, c)`是具有`3`个参数的函数调用，而`f((a, b, c))`是以`3`元祖作为唯一参数的函数调用。

```python
# tuple类构建函数
class tuple([iterable])  # 此处的方括号表示iterable是可选参数

# tuple创建示例
1,                       # 有逗号结尾表示元组  (1,)
(1, )                    # (1,)
1                        # 没逗号结尾表示数字 1
(1)                      # 1
()                       # 空数组()
tuple()                  # ()
tuple([1, 2, 4])         # 非空数组 (1, 2, 4)
1, 2, 3                  # (1, 2, 3)
(1, 2, 3)                # (1, 2, 3)
```

如下实例：

```python
a = (1, 2)
b = tuple(['3', 4])         # 也可以从列表初始化
c = (5,)
print(c)                    # (5,)
d = (6)
print(d)                    # 6
e = 3, 4, 5
print(e)                    # (3, 4, 5)

tuple1 = ( 'James', 786 , 2.23, 'john', 70.2 )
tinytuple = (123, 'john')
 
print(tuple1)               # 输出完整元组
print(tuple1[0])            # 输出元组的第一个元素
print(tuple1[1:3])          # 输出第二个至第三个的元素 
print(tuple1[2:])           # 输出从第三个开始至列表末尾的所有元素
print(tinytuple * 2)        # 输出元组两次
print(tuple1 + tinytuple)   # 打印组合的元组

# count(self, value)
name = ("James","Kobe","James","Yao","James")
name.count("James")         # 3

# index(self, value, start=None, stop=None)
name = ("James","Kobe","James","Yao","James")
name.index("James")         # 0
name.index("Yao")           # 3

# 元组Tuples
d = {(x, x + 1): x for x in range(10)}  # Create a dictionary with tuple keys
print d
t = (5, 6)       # Create a tuple
print type(t)    # Prints "<type 'tuple'>"
print d[t]       # Prints "5"
print d[(1, 2)]  # Prints "1"
```

##### 数字序列Range

`range`类型表示一个不可变的数字序列，通常用于在`for`循环中循环特定次数。

###### Range类构建函数

```python
class range(stop)
class range(start, stop[, step])
    # start：# 表述数字序列开始值，如果该参数没有被提供则值为0
    # stop: 数字序列结束值
    # stop: 数字序列步长，如果该参数没有被提供则值为1
```

关于`start`、`stop`、`step`参数值的说明：

- 这些参数必须是整型值(内建`int`或者任何实现了`__index__ `特殊方法的任意对象)
- 如果`start`参数被忽略，其默认值为`0`；如果`step`参数被忽略，其默认值为`1`；如果`step`为`0`，则会抛出`ValueError`错误
- 如果`step`参数为正数，那么`range`类型对象`r`的内容公式为：`r[i] = start + step*i`，约束条件为：`i >= 0` 且 `r[i] < stop`
- 如果`step`参数为负数，那么`range`类型对象`r`的内容公式仍然为：`r[i] = start + step*i`，但是约束条件为：`i >= 0`且`r[i] > stop`
- 如果`r[0]`不满足约束条件，`range`对象的值将为空
- `range`对象可以包含绝对值大于`sys.maxsize`的值，但是某些功能(如：`len()`)可能会引发`OverflowError`

```python
# range示例
list(range(10))          # start没有指定，默认值为0，即start=0，end=10
                         # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
list(range(1, 11))       # start=1, end=11
                         # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list(range(0, 11, 2))    # 要指定step就必须要指定start
                         # [0, 2, 4, 6, 8, 10]
list(range(0, -10, -1))  # step为负数
                         # [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
list(range(0))           # stop为0
                         # []
list(range(10, 5))       # 如果end < start ，则range对象为空
                         # []
```

这里需要注意一下，Python 2.x中的`range()`函数返回的是一个`list`类型，而Python 3.x中的`range()`函数返回的是一个`range`类型。

```python
# Python 2.x
range(10)         # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Python 3.x
range(10)         # range(0, 10)
```

`range`实现了除连接(`concatenation`)和重复(`repetition`)之外的所有通用序列操作，这是由于`range`对象只能表示遵循严格模式的序列，而连接和重复操作通常会违反这个模式。

`range`相对于常规`list`和`tuple`的优点在于：无论它表示的范围的大小是多少，它始终占用相同(小)量的内存。这是因为它只需要存储`start`、`end`和`step`这`3`个值，然后根据需要计算各个条目和子范围。

**说明:**

测试`range`对象是否相等与序列一样通过`==`和`!=`进行比较，也就是说，如果两个`range`对象表示相同值的序列就被认为是相等的。需要注意的是，比较相等的两个`range`对象可能具有不同的`start`、`end`、`step`参数值，例如`(0) == (2, 1)`，又例如`(0, 3, 2) == (0, 4, 2)`。



#### 文本序列（Text Sequence）

Python中的文本数据由`str`对象或字符串进行处理。

##### 字符串

字符串是Unicode码值的不可变序列。字符串字面量有多种形式：

- 单引号：`'允许嵌入"双"引号'`
- 双引号：`"允许嵌入'单'引号"`
- 三引号：`'''三个单引号''', """三个双引号"""`

**说明：**

- 三引号的字符串可以跨越多行，所关联的空格将包含在字符串文字中；
- 字符串也可以使用`str`构建函数从其他对象创建；
- 因为没有单独的`“字符”`类型，因此索引字符串将产生长度为`1`的字符串。也就是说，对于非空字符串`s`，`s[0] == s[0:1]`；
- 没有可变的字符串类型，但是`str.join()`或`io.StringIO`可以用于从多个片断有效地构造字符串；
- 字符串中可以是用反斜线`\`对特殊字符进行转义，也可以在字符串字面上使用`r`前缀来取消转义；
- Python 3.3中的修改：为了向后兼容Python 2系列，在字符串字面上再次允许使用`u`前缀，但是它对字符串文字的含义没有影响，也不能与`r`前缀组合使用；
- 作为单个表达式的一部分并且在它们之间只有空格的字符串文字将被隐式转换为单个字符串文字。也就是说`("spam" "eggs") == "spameggs"`；



##### Str类

###### str类构建方法

```python
class str(object='')
class str(object=b'', encoding='utf-8', errors='strict')
```

`str`类的构建方法返回对象的字符串版本。如果未提供对象参数，则返回空字符串。否则，`str()`的行为取决于是否给出了`encoding`和`errors`参数，如下所示：

- 如果既没有给出`encoding`也没有给出`errors`参数，`str(object)`将会返回`object.**str**()`的值，这是`object`的“非正式”或可打印的字符串表示。对于字符串对象，这是字符串本身。如果该`object`没有`__str__()`方法，那么`str()`将会返回`repr(object)`的结果值。
- 如果给出了`encoding`或`errors`两个参数中的至少一个，则`object`应该是类似于字节的对象(例如`bytes`或`bytearray`)。在这种情况下，如果`object`是`bytes`(或`bytearray`)对象，则`str(bytes,encoding,errors)`等价于`bytes.decode(encoding, errors)`。
- 将字节对象传递给`str()`而不使用`encoding`或`errors`参数属于返回非正式字符串表示形式的第一种情况。

```python
# str构建示例
'Hello, World!'  # 单引号 'Hello, World!'
"Hello, World!"  # 双引号 'Hello, World!'
# 三引号，多行 
"""
... Hello,
... World!
... """          # '\nHello,\nWorld!\n'

"Hello, \"World!\""  # 使用转义  'Hello, "World!"'

str()  # 不给出object参数，返回空字符串 ''
str("Hello, World!")  # 给出object参数，但不给出encoding和errors 'Hello, World!'
str(b"Hello, World!")  # "b'Hello, World!'"
str(b"Hello, World!", encoding='utf-8')  # 给出object参数，也给出encoding参数 'Hello, World!'
```

##### 文本序列操作

由于文本序列是一个特殊的（专门处理文本）不可变序列，因此它不支持可变序列支持的操作，但是它支持通用序列的所有操作。下面介绍下str支持的除通用序列支持的所有操作外的其他方法：

```python
# 返回一个将字符串居中的指定长度的字符串，填充部分使用fillchar指定的字符来完成(默认为ASCII空格)。
# 如果width小于或等于len(s)，则返回原始字符串
str.center(width[,fillchar])
# 与center()方法类似，只是字符串位于左边, 填充字符位于右边
str.ljust(width[,fillchar])
# 与center()方法类似，只是字符串位于右边，填充字符位于左边
str.rjust(width[,fillchar])
# 在数字字符串左侧以ASCII的'0'数字进行填充，形成一个长度为width的字符串副本，并返回。
# 如果数字字符串中包含前缀符号(如 '+'/'-')则'0'会被插入到前缀字符与数字字符之间。
# 如果width<=len(s)，则返回原始字符串。
str.zfill(width)

# 返回字符串删除指定的前导字符和尾随字符之后的副本。
# 可选参数chars是一个字符串，用来指定要删除的字符集合，如果省略或为None则chars参数默认为删除空格。
# 注意：chars参数不是前缀或后缀字，相反，它包含的字符的所有组合都会被删除。
str.strip([chars])
# 与strip()方法类似，只是仅删除字符串的前导字符
str.lstrip([chars])
# 与strop()方法类似，只是仅删除字符串的尾随字符
str.rstrip([chars])

# 返回子串sub在切片s[start:end]中第一次出现的索引位置，如果子串sub不存在则返回-1。
# 需要注意的是，只有当需要知道sub的位置时，才应该使用find()方法，
# 如果要检查sub是否是字符串的子串，请使用in运算符。
str.find(sub[,start[,end]])
# 返回子串sub在切片s[start:end]中最后一次出现的索引位置，如果子串sub不存在则返回-1。
str.rfind(sub[, start[, end]])

# 该方法类似于find()，但是如果子串未找到会抛出ValueError异常。
str.index(sub[, start[, end]])
# 该方法类似于rfind()，但是如果子串为找到会抛出ValueError异常。
str.rindex(sub[, start[, end]])

# 返回在范围[start, end]内指定的字符串sub不重叠出现的次数。
str.count(sub[, start[, end]])

# 将字符串的编码版本作为字节对象返回，默认编码为“utf-8”。
# errors的默认值为"strict"，意味着编码错误会引发UnicodeError，其他可能的值为"ignore", "replace"等。
str.encode(encoding="utf-8", errors="strict")

# 以当前字符串为连接符把iterable中的所有字符串连接成一个字符串并返回，
# 如果iterable中存在非字符串值(包括bytes对象)，将会抛出TypeError异常。
str.join(iterable)
# 用sep参数的值作为分隔符对字符串进行分割，返回一个字符串列表。
# 如果maxsplit参数被给出，那么最多进行maxsplit次分割操作(因此，得到的字符串里列表将最多有maxsplit+1个元素)；
# 如果maxsplit没有被指定或指定为-1，则不限制分割次数。
str.split(sep=None, maxsplit=-1)
# 用split()函数类似，只是它从右向左进行分割。
str.rsplit(seq=None, maxsplit=-1)
# 在字符串中的行边界位置进行切割，返回一个行的列表。
# 可选参数keepends为一个布尔值，表示换行符是否包含结果列表中，默认为false。
# 这里的行边界包括'\n', '\r', '\r\n'等。|
str.splitlines([keepends])

# 该静态方法将返回一个可用于str.translate(table)方法的转换表(字典)。
# 如果只有一个参数，它必须是一个将Unicode ordinals(整数)或字符(长度为1的字符串) 
# 映射为 Unicode ordinal(整数)，字符串(任意长度)或None的字典映射。
# 字符键值将被转换为整数。
# 如果有两个参数，它们必须是相同长度的字符串，并且在结果字典中，x中的每个字符将被映射到y中相同位置的字符。
# 如果有第三个参数，它必须是一个字符串，其字符将在结果字典中被映射为None。
static str.maketrans(x[, y[, z]])
# 返回一个字符串副本，通过给定的转换表table将字符串副本中的每个字符转换为对应的值(字符/字符串/None)。
# table参数必须是通过__getitem__()实现索引的对象，通常是映射或序列。
# 当使用Unicode序号(整数)索引时，table对象可以执行以下任何操作：
# 返回Unicode序号或字符串，可以将字符映射到一个或多个其它字符；
# 返回None，可以从返回字符串中删除字符；
# 将字符映射到自身，将引发LookupError异常。
str.translate(table)  

# 返回一个将字符串中的所有小写字母转为大写的字符串拷贝。
str.upper()
# 返回一个将字符串中的所有大写字母转为小写的字符串拷贝。
str.lower()
# 返回一个将字符串中的所有大写字母转为小写，将所有的小写字母转为大写的字符串拷贝。
str.swapcase()
# 返回一个将第一个字母转为大写的字符串拷贝。
str.capitalize()
# 返回一个将所有单词手写字母转为大写的字符串拷贝。
str.title()

# 如果字符串以指定的前缀prefix开始，则返回True，否则返回False。
# 后缀也可以是一个后缀元祖。
# 可选参数start和end可以指定查找前缀的开始和结束位置。
str.startswith(prefix[, start[, end]])
# 如果字符串以指定的后缀suffix结尾，则返回True，否则返回False。
# 后缀也可以是一个后缀元祖。
# 可选参数start和end可以指定查找后缀的开始和结束位置。
str.endswith(suffix[, start[, end]])

# 如果字符串中至少有一个字符，且所有字符都是十进制字符则返回True，否则返回False。
# 此类别包括十进制数字和所有可用于形成十进制数字的字符，如 U+0660, ARABIC-INDIC DIGIT ZERO。
str.isdecimal()
# 如果字符串中至少有一个字符，且所有字符都是数字则返回True, 否则返回False。
# 数字包括十进制字符和需要特殊处理的数字，
# 形式上，数字是具有属性值Numeric_Type = Digit 或 Numeric_Type = Decimal的字符。
str.isdigit()
# 如果字符串中至少有一个字符，且所有字符都是数字字符则返回Ture, 否则返回False。
# 这里的数字字符包括digit字符和所有具有Unicode数字值属性的所有字符。
# 形式上，这里的数字字符是指具有属性值Numeric_Type = Digit, 
# Numeric_Type = Decimal 或 Numeric_Type = Numeric的字符。
str.isnumeric()
# 如果字符串中至少有一个字符，且所有字符都是字母则返回True，否则返回False。
str.isalpha()
# 如果字符串中至少有一个字符，且所有字符都是numeric或alpha则返回Ture, 否则返回False。
# 即只要上面4个方法中的任意一个方法调用返回Ture则该方法调用就返回Ture。
str.isalnum()
# 如果字符串中至少有一个字符，且所有字符都是空白字符则返回True, 否则返回False。
str.isspace()
```

操作示例如下：

```python
'welcome'.center(15, '-')            # '----welcome----'
'welcome'.ljust(15, '-')             # 'welcome--------'
'welcome'.rjust(15, '-')             # '--------welcome'
'11'.zfill(15)                       # '000000000000011'
'    spacious    '.strip()           # 'spacious'
'www.example.com'.strip('cmowz')     # '.example.'
'    spacious    '.lstrip()          # 'spacious    '
'www.example.com'.lstrip('cmowz')    # '.example.com'
'    spacious    '.rstrip()          # '    spacious'
'mississippi'.rstrip('ipz')          # 'mississ'
'Hello, Lilly'.find('ll')            # 2
'Hello, Lilly'.find('ll', 4)         # 9
'Hello, Lilly'.rfind('ll')           # 9
'Hello, Lilly'.rfind('ll', 0, 7)     # 2
'Hello, Lilly'.index('ll')           # 2
'Hello, Lilly'.index('ll', 4)        # 9
'Hello, Lilly'.rindex('ll')          # 9
'Hello, Lilly'.rindex('ll', 0, 7)    # 2
'Hello, Lilly'.find('lll')           # -1
'Hello, Lilly'.index('lll')          # ValueError: substring not found

':'.join(['Tom', 'Jerry', 'Peter'])                # 'Tom:Jerry:Peter'
'Tom:Jerry:Peter'.split()                          # ['Tom:Jerry:Peter']
'Tom:Jerry:Peter'.split(sep=':')                   # ['Tom', 'Jerry', 'Peter']
'Tom:Jerry:Peter'.split(sep=':', maxsplit=1)       # ['Tom', 'Jerry:Peter']
'Tom:Jerry:Peter'.rsplit(sep=':')                  # ['Tom', 'Jerry', 'Peter']
'Tom:Jerry:Peter'.rsplit(sep=':', maxsplit=1)      # ['Tom:Jerry', 'Peter']
'Tom:Jerry::Peter:'.split(sep=':')                 # 空值不会被合并，可能需要单独进行空值判断 

'ab c\n\nde fg\rkl\r\n'.splitlines()               # 末尾的行尾标记不会产生一个额外的行 
                                                   # ['ab c', '', 'de fg', 'kl']
'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)  # ['ab c\n', '\n', 'de fg\r', 'kl\r\n']

# 转换表中的key应该是字符对应的Unicode数字值，而不应该是字符本身
'abcdedfg'.translate({'a':'A', 'd': 'D'})    # 'abcdedfg'
'abcdedfg'.translate({97: 'A', 100: 'D'})    # 'AbcDeDfg'
str.maketrans({'a': 'A', 'd': 'D'})          # {97: 'A', 100: 'D'}
table = str.maketrans({'a': 'A', 'd': 'D'})  # 这样就不要是查字符对应的Unicode数字值是多少了
'abcdedfg'.translate(table)                  # 'AbcDeDfg'

'hello, world!'.upper()          # 'HELLO, WORLD!'
'hello, world!'.upper().lower()  # 'hello, world!'
'Hello, World!'.swapcase()       # 'hELLO, wORLD!'
'hello, world!'.capitalize()     # 'Hello, world!'
'hello, world!'.title()          # 'Hello, World!'
```

##### 字符串格式化

在几乎所有的编程语言中，字符串的格式化都是非常重要的基本知识。Python中实现字符串格式化有以下式：

- 字符串拼接（不推荐使用）
- 符串本身所支持的方法调用：`str.format(*args, **kwargs)`
- 字符串的内置操作符：`%`

###### 字符串拼接格式化

```python
a = 2
b = 3
str(a) + ' + ' + str(b) + ' = ' + str(a+b)  # '2 + 3 = 5'
```

此处通过字符串的拼接来输出一定格式的字符串，这会在内存中产生多个字符串对象，且操作复杂，容易出错。

###### `str.fromat()`格式化

该方法用于执行字符串格式化操作。调用此方法的字符串可以包含由大括号字面文本或由大括号{}分割的替换字段。每个替换字段保安位置参数的数字索引或关键字参数的名称。该方法将返回一个字符串副本，其中每个替换字段都替换为相应参数的字符串值。

```python
a = 2
b = 3
'{0} + {1} = {2}'.format(a, b, a+b)                   # 使用位置参数   '2 + 3 = 5'
'{a} + {b} = {c}'.format(a=a, b=b, c=a+b)             # 使用关键字参数 '2 + 3 = 5'
'{a} + {b} = {c}'.format({'a': a, 'b': b, 'c': a+b})  # 不能使用字典   KeyError: 'a'
```

`str.format()`可以实现简单的字符串格式化，但是这种格式化方式存在一些怪癖，比如它不支持接收元组(`tuple`)、字典(`dict`)等数据类型作为参数，这是非常不方便的。

###### `%`格式化

`%`操作符是字符串对象唯一的内置操作，也称为字符串格式化或插值运算符。该接口提供了一种更强大、灵活和可扩展的方法来格式化文本。格式字符串中的`%`转换规范将会被替换为`0`个或多个元素的值，效果类似于在C语言中使用`sprintf()`。

如果格式字符串需要单个参数，那么替换值可以是单个非元组对象；否则，替换值必须是具有由格式化字符串指定的条目数量的元组，或者是单个映射对象(例如，字典)。

```python
# 格式化字符串只需要1个参数，替换值可以是的那个非元组字符
'The sum of 2 + 3 is: %d' % 5                         # 'The sum of 2 + 3 is: 5'
a = 2
b = 3
# 格式化字符串需要n(n > 1)个参数，替换值需要是具有n个元素的元组
'%d + %d = %d' % (a, b, a+b)                          # '2 + 3 = 5'
# 格式化字符串需要n(n > 1)个参数，替换也可以是具有n个元素的映射对象
'%(a)d + %(b)d = %(c)d' % {'a': a, 'b': b, 'c': a+b}  # '2 + 3 = 5'
```

上面示例中，格式字符串中的`%d`, `%(a)d`称为“转换说明标识符”。这个标识符可以由`2`个或多个部分组成，且各部分必须按照指定的顺序排列：

- **`%`字符**：表示“转换说明标识符”的开始；
- **映射键名称(Mapping key)**：可选部分，由小括号包含的字符串序列组成，如：`(name)`；
- **转换标识(Conversion flags)**：可选部分，这个会影响一些转换类型的结果；如：`0`表示用数字字符0进行填充，`-`表示左对齐(用空白字符进行右填充)
- **最小字段宽度(Minimum field width)**：可选部分，指定转换结果的最小宽度
- **精度(Precision)**：可选部分，通过".精度值"的方式来指定小数点后保留几位小数
- **长度修饰符(Length modifier)**：可选部分
- **转换类型(Conversion type)**：用于指定数据类型；常用的转换类型有`d`或`i`表示有符号十进制整数，`f`或`F`表示浮点数，`s`表示字符串, `%`表示其本身

由上可见，在“转换说明表示符”的7个组成部分中，只有第1部分`%`，和最后一部分"转换类型"是必须的指定的，其他部分都是可选的辅助项。另外，长度修饰符（`h`，`l`或`L`）可以存在，但是将被忽略，因为对于Python不是必要的。也就是说，`ld`与`%d`是相同的。

```python
student01 = {'name': 'Peter', 'sno': 15, 'age': 22, 'score': 93.92532}
>>> msg = '''
... ##### Information of student: %(name)s #####
... 姓名：%(name)s
... 学号：%(sno)010d
... 年龄：%(age)d
... 得分：%(score).2f
... ----- end -----
... ''' % student01
>>> print(msg)

##### Information of student: Peter #####
姓名：Peter
学号：0000000015
年龄：22
得分：93.93
----- end -----
```

Python 3.6新增通过[格式化的字符串字面量](https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings)(string literals)[插入字符串](https://www.python.org/dev/peps/pep-0498)，如下例所示：

```python
# 在普通字符串前添加 f 或 F 前缀，其效果类似于str.format()。
name = "Fred"
f"He said his name is {name}."               # 'He said his name is Fred.'
# 其效果相当于：
"He said his name is {name}.".format(**locals())

# 此特性还支持嵌套字段
import decimal
width = 10
precision = 4
value = decimal.Decimal("12.34567")
f"result: {value:{width}.{precision}}"       # 'result:      12.35'
# 相当于
"result: {value:{width}.{precision}}".format(**locals())
```



### 集合类型Sets

集合对象是不同的（不可重复）`hashable`对象的无序集合。常见用法包括：成员关系测试、移除序列中的重复元素、科学计算，例如交集、并集、差分和对称差分。通俗点来说，集合是一个无序不重复元素的数据集，其基本功能是进行成员关系测试和消除重复元素。集合是一种很有用的数学操作，比如列表去重，或是理清两组数据之间的关系，集合的操作符和位操作符有交集，注意不要弄混。

目前有两种内置的集合类型：`set`和`frozenset`。`set`类型是可变的--可以使用`add()`和`remove()`等方法更改其内容。由于它是可变的，它没有`hash`值，因此它不能被当做字典的键值或另一集合的元素。`frozenset`类型是不可变的和 `hashable`的，它的内容不能在创建后改变，因此它可以用作字典的键值或作为另一个集合的元素。

##### set构建

set类构建函数

```python
class set([iterable])
class frozenset([iterable])
```

**set的构建方式**

- 将一个用逗号分割的元素列表放在一堆花括号内可以创建一个非空set集合，如`{'Tom', 'Jerry', 'Peter'}`
- 给`set`的构建函数传递一个空值将会创建一个空`set`集合(注意：`{}`表示的是一个空字典而不是空`set`集合)
- 给`set`的构架你函数传一个非空`iterable`参数将会创建一个非空`set`集合

**注意：**

再次强调，一个`set`集合内的元素必须是`hashable`的（不可变的）。要想表示一个`set`的`set`，那么内部的`set`必须是`frozenset`对象，因为`frozenset`是不可变的，是`hashable`的。

```python
# set构建示例
{'Tom', 'Jerry', 'Peter'}        # 使用花括号创建非空set集合              {'Tom', 'Jerry', 'Peter'}
set()                            # 使用set构建函数创建空set集合           set()
set((1, 2, 3 ,4))                # 使用set构建函数创建非空set集合         {1, 2, 3, 4}
set((1, 2, 3 ,['a', 'b', 'c']))  # set集合中的元素必须是不可变的、可哈希的
# TypeError: unhashable type: 'list'
```

##### set 和 frozenset都支持的操作

作为无序集合，set不记录元素位置或插入顺序。因此set不支持索引、切片或其他类序列行为。

```python
# 获取集合中的条目个数
len(set)         

# 成员关系测试--包含/不包含
x in set                                      
x not in set    
# 循环遍历集合中的条目
for x in set       

# 判断该集合是否与另外一个集合不相交(当且仅当交集为空)，不相交则返回True
isdisjoint(other)       

# 判断该集合是否是另外一个集合的子集
issubset(other) 
set <= other  
# 真子集
set < other  

# 判断该集合是否是另外一个集合的父集
issuperset(other) 
set >= other  
# 真父集
set > other  

# 求该集合与另外一个或多个集合的并集
union(other,...) 
set | other | ...  

# 求该集合与另外一个或多个集合的交集
intersection(other,...) 
set & other & ...  

# 求该集合与另外一个或多个集合的差集(该集合中存在但其它集合中不存在的元素集合)
difference(other,...) 
set - other - ...  

# 求该集合与另外一个集合的对称差集(该集合中存在但另一集合中不存在，或另一集合中存在但该集合中不存在的元素集合)
symmetric_difference(other) 
set ^ other  

# 返回一个新的浅拷贝集合
copy()  
```

**说明：**

- `union()`、`intersection()`、`differnce()`、`symmetric_difference()`、`issubset()`和`issuperset()`方法的可接受任何可迭对象作为参数。相比之下，它们的基于运算符的相应操作需要它们的参数是`set`。这避免了像`set('abc')` &` 'cbs'`这样易出错的结构，有利于更易读的结构，如`set('abc').intersection('cbs')`。
- `set`和`frozenset`支持集合与集合进行比较操作。
  - 当且仅当每个集合的每个元素都包含在另一个(每个集合都是另一个的子集)时，两个集合是相等的；
  - 当且仅当第一集合是第二集合的真子集(是子集，但不相等)时，集合小于另一集合；
  - 当且仅当第一集合是第二集合的真父集(是父集，但不相等)时，集合大于另一集合；
- `set`和`frozenset`之间是基于它们的成员进行比较的。比如`set('abc') == frozenset('abc')`返回`True`，因此`set('abc') in set([frozenset('abc')])`
- 子集和相等的比较不推广到总排序函数。例如，任何两个非空且不相交的集合是不相等的，并且不是彼此的子集。因此，它们对应的以下操作都返回`False`：`a<b, a==b, a>b`。
- 因为`set`之定义了部分排序（子集关系），因此没有为`set`的`list`定义`list.sort()`方法。
- `set`集合的元素像`dict`的键一样，必须是可哈希的。
- `set`实例与`frozenset`实例混合进行二进制操作将会返回第一个操作数的类型。例如：`frozenset('ab') | set('bc')`会返回一个`frozenset`实例。


```python
set('abc')                      # {'a', 'c', 'b'}

# 使用操作符进行相关操作，操作符两边都必须是set类型
set('abc') & 'cbs'              # TypeError: unsupported operand type(s) for &: 'set' and 'str'
set('abc') & set('cbs')         # {'c', 'b'}

# 调用方法进行相关操作，参数可以是任意可迭代对象
set('abc').intersection('cbs')            # {'c', 'b'}
set('abc').intersection(['c','s', 'b'])   # {'c', 'b'}

set('abc') == frozenset('abc')          # True
set('abc') in frozenset('abc')          # False
set('abc') in set(frozenset('abc'))     # False
set('abc') in set([frozenset('abc')])   # True
```

##### set支持但frozenset不支持的操作

set是可变集合，而frozenset是不可变集合，因此set的有些修改操作是frozenset不支持的。

```python
# 向集合中添加一个元素
add(elem)  

# 从集合中删除一个元素，如果集合中不包含该元素会抛出KeyError错误
remove(elem)  
# 如果集合中包含该元素则删除它，这个方法明显比remove()好用
discard(elem)  

# 由于set集合是无序的，因此该方法会移除并返回一个随机元素，而不是像list.pop()移除并返回最后一个元素
pop()  

# 清除set集合中的所有元素
clear()  

# 更新set集合，将其它集合中的元素添加进来；简单点来说就是与其它一个或多个集合求并集并将结果赋值给自己
update(other,...) 
set |= other | ...  

# 更新set集合，只保留所有集合中都存在的元素；简单点来说就是与其它一个或多个集合求交集并将结果赋值为自己
intersection_update(other,...) 
set &= other & ...  

# 与其它一个或多个集合求差集并将结果赋值给自己
difference_update(other,...) 
set -= other | ...  

# 与另外一个集合求对称差集并将结果赋值给自己；对称差集就是A-B 与 B-A 的并集
symmetric_difference_update(other) 
set ^= other  
```

**说明:**

上面这些update方法也是可以接受任何可迭代对象作为参数。另外，remove(elem)和discard(elem)等方法中参数elem可以是一个set集合。为了支持搜索等效的frozenset，elem集合会在搜索期间被暂时修改，然后恢复。在搜索期间，elem不应该被读取或改动，因为它没有有意义的值。


```python
A = set([1, 2, 3, 4])
B = {3, 4, 5, 6}
C = set([1, 1, 2, 2, 2, 3, 3, 3, 3])
print(C)        # 集合的去重效果，set([1, 2, 3])
print(A | B)    # 求并集，set([1, 2, 3, 4, 5, 6])
print(A & B)    # 求交集，set([3, 4])
print(A - B)    # 求差集，属于A但不属于B的，set([1, 2])
print(B - A)    # 求差集，属于B但不属于A的，set([5, 6])
print(A ^ B)    # 求对称差集，相当于(A-B)|(B-A)，set([1, 2, 5, 6])

# 创建集合
name = {"James","Kobe","Yao","James"}
name2 = set({"James","Kobe","Yao","James"})
print(name)     # set(['James', 'Yao', 'Kobe'])
type(name)      # <type'set'>

# 集合Sets
animals = {'cat', 'dog'}
print 'cat' in animals   # Check if an element is in a set; prints "True"
print 'fish' in animals  # prints "False"
animals.add('fish')      # Add an element to a set
print 'fish' in animals  # Prints "True"
print len(animals)       # Number of elements in a set; prints "3"
animals.add('cat')       # Adding an element that is already in the set does nothing
print len(animals)       # Prints "3"
animals.remove('cat')    # Remove an element from a set
print len(animals)       # Prints "2"

# 循环Loops：在集合中循环的语法和在列表中一样，但是集合是无序的，
# 所以你在访问集合的元素的时候，不能做关于顺序的假设。
animals = {'cat', 'dog', 'fish'}
for idx, animal in enumerate(animals):
    print '#%d: %s' % (idx + 1, animal)
# Prints "#1: fish", "#2: dog", "#3: cat"

# 集合推导Set comprehensions：和字典推导一样，可以很方便地构建集合：
from math import sqrt
nums = {int(sqrt(x)) for x in range(30)}
print nums   # Prints "set([0, 1, 2, 3, 4, 5])"

# clear(self, *args, kwargs) 清除内容
name = {"James","Kobe","Yao","James"}
print(name)  # {'Kobe', 'James', 'Yao'}
name.clear()
print(name)  # set()

# copy(self, *args, kwargs) 浅拷贝
name1 = {"James","Kobe","Yao","James"}
print(name1) # {'Kobe', 'James', 'Yao'}
name2 = name1.copy()
print(name2) # {'Kobe', 'James', 'Yao'}
id(name1)    # 3082730828
id(name2)    # 3082730268

# difference(self, *args, kwargs) name2中存在，name1中不存在
name1 = {"James","Kobe","Yao","James"}
name2 = {"James","Henry","Ronaldo"}
name2.difference(name1)    # {'Ronaldo', 'Henry'}

# difference_update(self, *args, kwargs) 从当前集合中删除和另一集合中相同的元素
name1 = {"James","Kobe","Yao","James"}
name2 = {"James","Henry","Ronaldo"}
name2.difference_update(name1)
print(name2)               # {'Ronaldo', 'Henry'}

# discard(self, *args, kwargs) 移除指定元素，不存在不报错
name = {"James","Kobe","Yao"}
name.discard("Kobe")
print(name)                # {'James', 'Yao'}

# intersection(self, *args, kwargs) 交集
name1 = {"James","Kobe","Yao"}
name2 = {"James","Henry","Ronaldo"}
name2.intersection(name1)  # {'James'}

# intersection_update(self, *args, kwargs) 取交集并更新
name1 = {"James","Kobe","Yao"}
name2 = {"James","Henry","Ronaldo"}
name2.intersection_update(name1)
print(name2)               # {'James'}

# isdisjoint(self, *args, kwargs) 如果没有交集，返回True，否则返回False
name1 = {"James","Kobe","Yao"}
name2 = {"James","Henry","Ronaldo"}
name2.isdisjoint(name1)    # True

# issubset(self, *args, kwargs) 是否是子序列
name1 = {"James","Kobe","Yao"}
name2 = {"James"}
name2.issubset(name1)      # True

# issuperset(self, *args, kwargs) 是否是父序列
name1 = {"James","Kobe","Yao"}
name2 = {"James"}
name1.issuperset(name2)    # True

# pop(self, *args, kwargs) 移除元素
name = {"James","Kobe","Yao"}
name.pop()                 # 'Kobe'
print(name)                # {'James', 'Yao'}

# remove(self, *args, kwargs) 移除指定元素，若不存在，则报错
name = {"James","Kobe","Yao"}
name.remove("James")
print(name)                # {'Kobe', 'Yao'}

# symmetric_difference(self, *args, kwargs) 对称差集
name2 = {"James","Henry","Ronaldo"}
name1 = {"James","Kobe","Yao"}
name1.symmetric_difference(name2) # {'Kobe', 'Ronaldo', 'Yao', 'Henry'}

# symmetric_difference_update(self, *args, kwargs) 对称差集并更新
name2 = {"James","Henry","Ronaldo"}
name1 = {"James","Kobe","Yao"}
name1.symmetric_difference_update(name2)
print(name1)               # {'Kobe', 'Ronaldo', 'Yao', 'Henry'}

# union(self, *args, kwargs) 并集
name2 = {"James","Henry","Ronaldo"}
name1 = {"James","Kobe","Yao"}
name1.union(name2)         # {'Kobe', 'James', 'Ronaldo', 'Yao', 'Henry'}

# update(self, *args, kwargs) 更新
name2 = {"James","Henry","Ronaldo"}
name1 = {"James","Kobe","Yao"}
name1.update(name2)
print(name1)               # {'Kobe', 'James', 'Ronaldo', 'Yao', 'Henry'}
```

### 映射类型(Mapping)

一个`mapping`对象将可哈希的值映射为任意对象。映射是可变对象。目前Python中只有一种标准映射类型，就是字典(`dict`)。`dcit`和`set`集合一样也是用花括号表示，但是花括号中的每个元素都是一个键值对(`key:value`)。字典中的键值对也是无序的，且`key`必须是可哈希的不可变类型，如字符串、数字、布尔值和不包含可变类型的`tuple`。而`list`和包含可变类型的`tuple`是不能做字典的`key`的。另外，同一个字典中，`key`不能重复，否则会覆盖之前的值。、

用于键的数字类型遵守数字比较的正常规则：如果两个数字比较相等（比如`1`和`1.0`），则它们可以互相使用以索引相同的字典条目。但是需要注意，由于计算机存储浮点数作为近似值，因此使用它们作为字典的键通常是不明智的。

Python 3.6改进了dict类型， 使其内存使用量与Python 3.5相比减少了20％~25%。这是通过使用一个[类似于PyPy的](https://morepypy.blogspot.com.es/2015/01/faster-more-memory-efficient-and-more.html)新表示实现的，并且也优化了其垃圾回收性能。

#### dict构建

**dict类构建函数**

```python
class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)
```

上面的`dict`构建函数会返回一个新的字典，这个新的字典是从一个可选的位置参数和一组可能为空关键字参数初始化的。

**dict的构建方式**

- 将以逗号分隔的`key:value`（键值对）列表放置在一对花括号中：`{}`，`{'Tom':1, 'Jerry':2, 'Peter':3}`
- 使用不传递位置参数的构建函数，创建空字典：`dict()`，等同于`{}`
- 如果给定了位置参数，并且它是映射对象，则使用与该映射对象相同的键值对创建字典；否则，位置参数必须是可迭代对象。可迭代对象中的每个条目本身必须是具有两个对象的可迭代对象。每个条目的第一个对象将会成为新字典中的键，第二个对象将会成为对应的值。如果键多次出现，则该键的最后一个值将成为新字典中的相应值。
- 如果给出了关键字参数，则将关键字参数及其值添加到从位置参数创建的字典中。如果要添加的键已经存在，则来自关键字参数的值将替换位置参数中的值。
- 可以通过`zip`类来创建(zip在Python 2.x中是一个内建函数，而在Python 3.x中是一个类)。

```python
# dict构建示例
# 空字典
a = {}       # {}
b = dict()   # {}
a == b       # True

# 非空字典
# 将以逗号分隔的键值对列表放置在一对花括号中
a = {'one': 1, 'two': 2, 'three': 3}  
# 使用dict构建函数，并传递关键字参数
b = dict(one=1, two=2, three=3)  
# 使用dict构建函数，并传递可迭代对象为位置参数
c = dict([('two', 2), ('one', 1), ('three', 3)])  
# 使用dict构建函数，并传递可迭代对象作为位置参数
d = dict({'three': 3, 'two': 2, 'one': 1})  
a == b == c == d       # True

# 使用dict构建函数，同时传递可迭代位置参数和关键字参数
e = dict({'three': 3, 'two': 2, 'one': 1}, four=4, five=5)  
e # {'five': 5, 'two': 2, 'three': 3, 'one': 1, 'four': 4}

# zip类构建函数
zip(iter1 [,iter2 [...]])

zip(['one', 'two', 'three'], [1, 2, 3])  
# [('one', 1), ('two', 2), ('three', 3)]

zip(['one', 'two', 'three'], [1, 2, 3], ('I', 'II', 'III'))
# [('one', 1, 'I'), ('two', 2, 'II'), ('three', 3, 'III')]

# 结果中的条目数与此处条目数最少的可迭代对象一致
zip(['one', 'two', 'three', 'four'], [1, 2, 3, 4], ('I', 'II', 'III'))  
# [('one', 1, 'I'), ('two', 2, 'II'), ('three', 3, 'III')]
```

#### dict操作

```python
# 返回字典d中的条目数
len(d)  

# 如果字典d中包含key这个键则返回True, 否则返回False
key in d  
key not in d 

# 返回key对应的条目的值，如果key不存在会抛出KeyError异常
d[key]  
# 如果key存在则返回其对应的值，否则返回default参数指定的值。
# 如果default没有被指定，则default取None，因此该方法永远不会抛出KeyError异常。
get(key[, default])  

# 如果key存在则返回这个key对应的值，如果key不存在则插入一个键值对key:default并返回default的值。
# default默认值为None。
setdefault(key[,default])  

# 这是个类方法，用于创建一个新的字典。
# seq序列中的元素将作为新字典中的key，而value将会是这些key共同的值，value默认为None。
classmethod fromkeys(seq[,value]) 

# 返回该dict的一个浅拷贝
copy()  

# 返回一个字典键的新视图
keys()  

# 返回一个字典值的新视图
values()  

# 返回一个字典条目的新视图：(key, value)
items()  

# 返回字典键的一个迭代器，这是iter(d.keys())的简写方式
iter(d)  

# 如果key不存在则表示新增一个条目，如果key已经存在则表示修改该条目的值
d[key] = value 

# 用other中的键值对更新字典的内容，覆盖现有的key。
# other可以是一个字典对象或键/值对(比如长度为2的元组或其它可迭代对象)。
# 如果指定了关键字参数，字典将会使用关键字参数对字典的键/值对更新，如：d.update(红色=1, 蓝色=2)
update([other])  

# 删除key对应的表目，如果key不存在会抛出KeyError异常
del d[key]  

# 从字典中删除并返回一个任意(key, value)对，如果字典为空会抛出KeyError异常。
# 该方法对于破坏性的遍历字典很有用，常用于集合算法。
popitem()  

# 如果key存在就删除它并返回它的值，否则返回default的值。
# 如果default没有被给出并且key不存在，则抛出KeyError异常。
pop(key[,default])  

# 清空dict中的所有条目
clear()  
```

操作示例

```python
d = {'one': 1, 'two': 2, 'three': 3}
len(d)                    # 3
'two' in d                # True
'two' not in d            # False
d['three']                # 3
d['four']                 # KeyError: 'four'
d.get('three')            # 3
d.get('four', 'default')  # 'default'
d                         # {'one': 1, 'two': 2, 'three': 3}
d.setdefault('three', 'default')  # 3
d                         # {'one': 1, 'two': 2, 'three': 3}
d.setdefault('four', 'default') # 'default'
d                         # {'one': 1, 'two': 2, 'four': 'default', 'three': 3}
dict.fromkeys(['one', 'two', 'three'])  # {'one': None, 'two': None, 'three': None}
dict.fromkeys(['one', 'two', 'three'], 'default') 
# {'one': 'default', 'two': 'default', 'three': 'default'}

d.copy()            # {'one': 1, 'two': 2, 'four': 'default', 'three': 3}
d['four'] = 4       
d # {'one': 1, 'two': 2, 'four': 4, 'three': 3}
d['five'] = 5       
d # {'one': 1, 'two': 2, 'five': 5, 'four': 4, 'three': 3}
d.update({'two': 'II', 'six': 6})
d # {'one': 1, 'two': 'II', 'four': 4, 'five': 5, 'six': 6, 'three': 3}
d.update(two=2, seven=7)
d # {'one': 1, 'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'three': 3}
d.update([('three', 'III'), ('eight', 8)])
d # {'one': 1, 'two': 2, 'four': 4, 'five': 5, 'eight': 8, 'six': 6, 'seven': 7, 'three': 'III'}

d.keys()    # dict_keys(['one', 'two', 'four', 'five', 'eight', 'six', 'seven', 'three'])
d.values()  # dict_values([1, 2, 4, 5, 8, 6, 7, 'III'])
d.items()   # dict_items([('one', 1), ('two', 2), ('four', 4), ('five', 5), ('eight', 8), ('six', 6), ('seven', 7), ('three', 'III')])

iter(d)         # <dict_keyiterator object at 0x000001EA21A179A8>
iter(d.keys())  # <dict_keyiterator object at 0x000001EA21A175E8>

del d['eight']  
d # {'one': 1, 'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'three': 'III'}
d.popitem()     # ('one', 1)
d               # {'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'three': 'III'}
d.pop('three')  # 'III'
d               # {'two': 2, 'four': 4, 'five': 5, 'six': 6, 'seven': 7}
d.pop('three')  # KeyError: 'three'
d.pop('three',None)
d.pop('three','default')  # 'default'
d.clear()
d.popitem()     # KeyError: 'popitem(): dictionary is empty'
```

#### 字典视图对象(Dictionary view objects)

对于`dict.keys()`、`dict.values()`和`dict.items()`这些函数，在Python 2.x中返回的是`list`对象，而在Python 3.x中返回的是一个叫做字典视图的对象。

字典视图在字典条目上提供了一个动态视图，这意味着当字典发生变化时，相应的视图也会发生变化。要保存固定的值需要将字典视图强制转换为其他类型的对象进行保存，通常保存为`list`类型。

```python
# python 2.x
d = {'one': 1, 'two': 2, 'three': 3}
d = {'one': 1, 'two': 2, 'three': 3}
dkeys = d.keys()      
dkeys         # ['three', 'two', 'one']
dvalues = d.values()    
dvalues       # [3, 2, 1]
ditems = d.items()
ditems        # [('three', 3), ('two', 2), ('one', 1)]
d['four'] = 4
d             # {'one': 1, 'three': 3, 'two': 2, 'four': 4}
dkeys         # ['three', 'two', 'one']
dvalues       # [3, 2, 1]
ditems        # [('three', 3), ('two', 2), ('one', 1)]

# python 3.x
d = {'one': 1, 'two': 2, 'three': 3}
dkeys = d.keys()      
dkeys         # dict_keys(['one', 'three', 'two'])
dvalues = d.values()    
dvalues       # dict_values([1, 3, 2])
ditems = d.items()
ditems        # dict_items([('one', 1), ('three', 3), ('two', 2)])
d['four'] = 4
d             # {'one': 1, 'three': 3, 'two': 2, 'four': 4}
dkeys         # dict_keys(['one', 'three', 'two', 'four'])
dvalues       # dict_values([1, 3, 2, 4])
ditems        # dict_items([('one', 1), ('three', 3), ('two', 2), ('four', 4)])
```

如下实例：

```python
a = {'Tom': 8, 'Jerry': 7}
print(a['Tom'])             # 8
if 'Jerry' in a:            # 判断'Jerry'是否在keys里面
    print(a['Jerry'])       # 7
print(a.get('Spike'))       # None，通过get获得值，即使键不存在也不会报异常
a['Spike'] = 10
a['Tyke'] = 3
a.update({'Tuffy': 2, 'Mammy Two Shoes': 42})
print(a.values())   # dict_values([8, 2, 3, 7, 10, 42])
print(a.pop('Mammy Two Shoes'))     # 移除'Mammy Two Shoes'的键值对，并返回42
print(a.keys())     # dict_keys(['Tom', 'Tuffy', 'Tyke', 'Jerry', 'Spike']) 

# 字典Dictionaries
d = {'cat': 'cute', 'dog': 'furry'}  # Create a new dictionary with some data
print d['cat']       # Get an entry from a dictionary; prints "cute"
print 'cat' in d     # Check if a dictionary has a given key; prints "True"
d['fish'] = 'wet'    # Set an entry in a dictionary
print d['fish']      # Prints "wet"
# print d['monkey']  # KeyError: 'monkey' not a key of d
print d.get('monkey', 'N/A')  # Get an element with a default; prints "N/A"
print d.get('fish', 'N/A')    # Get an element with a default; prints "wet"
del d['fish']        # Remove an element from a dictionary
print d.get('fish', 'N/A') # "fish" is no longer a key; prints "N/A"

# 循环Loops：在字典中，用键来迭代更加容易。
d = {'person': 2, 'cat': 4, 'spider': 8}
for animal in d:
    legs = d[animal]
    print 'A %s has %d legs' % (animal, legs)
# Prints "A person has 2 legs", "A spider has 8 legs", "A cat has 4 legs"

# 如果你想要访问键和对应的值，那就使用iteritems方法：
d = {'person': 2, 'cat': 4, 'spider': 8}
for animal, legs in d.iteritems():
    print 'A %s has %d legs' % (animal, legs)
# Prints "A person has 2 legs", "A spider has 8 legs", "A cat has 4 legs"

# 字典推导Dictionary comprehensions：和列表推导类似，但是允许你方便地构建字典
nums = [0, 1, 2, 3, 4]
even_num_to_square = {x: x ** 2 for x in nums if x % 2 == 0}
print even_num_to_square  # Prints "{0: 0, 2: 4, 4: 16}"

# 注意到初始化字典和集合很像，的确如此，集合就像是没有值只有键的字典。
# 既然有了人名到年龄的映射，也许你立马想到是否可以给字典排序？
# 在Python 3.6之前，这个问题是错误的，字典是一种映射关系，没有顺序。
# 当然了，如果要把(键, 值)的这种对进行排序，是没有问题的，
# 前提是先把字典转化成可排序的结构，items()或者iteritems()可以做到这件事：
b = a.items()
print(b)  # [('Tuffy', 2), ('Spike', 10), ('Tom', 8), ('Tyke', 3), ('Jerry', 7)]
from operator import itemgetter
c = sorted(a.items(), key=itemgetter(1))
print(c)  # [('Tuffy', 2), ('Tyke', 3), ('Jerry', 7), ('Tom', 8), ('Spike', 10)]
d = sorted(a.iteritems(), key=itemgetter(1))
print(d)  # [('Tuffy', 2), ('Tyke', 3), ('Jerry', 7), ('Tom', 8), ('Spike', 10)]
e = sorted(a)
print(e)  # 只对键排序，['Jerry', 'Spike', 'Tom', 'Tuffy', 'Tyke']

# items()可以把字典中的键值对转化成一个列表，其中每个元素是一个tuple，
# tuple的第一个元素是键，第二个元素是值。
# 变量c是按照值排序，所以需要一个操作符itemgetter，去位置为1的元素作为排序参考，
# 如果直接对字典排序，则其实相当于只是对键排序。
# 字典被当作一个普通的可遍历结构使用时，都相当于遍历字典的键。
# 如果觉得字典没有顺序不方便，可以考虑使用OrderedDict，使用方式如下：
from collections import OrderedDict
a = {1: 2, 3: 4, 5: 6, 7: 8, 9: 10}
b = OrderedDict({1: 2, 3: 4, 5: 6, 7: 8, 9: 10})
print(a)    # {1: 2, 3: 4, 9: 10, 5: 6, 7: 8}
print(b)    # OrderedDict([(1, 2), (3, 4), (9, 10), (5, 6), (7, 8)])

# 这样初始化时的顺序就保留了，除了有序的特性以外，用法上和字典没有区别。

# 2016年9月，Guido宣布在Python 3.6中，字典将默认有序，这样就不用纠结了。
# 另外需要注意的一点是字典是通过哈希表实现的，所以键必须是可哈希的， 
# list不能被哈希，所以也不能作为字典的键，而tuple就可以。

dict = {}
dict['one'] = "This is one"
dict[2] = "This is two"
 
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
 
print(dict['one'])          # 输出键为'one' 的值
print(dict[2])              # 输出键为 2 的值
print(tinydict)             # 输出完整的字典
print(tinydict.keys())      # 输出所有键
print(tinydict.values())    # 输出所有值

# clear(self) 清除内容
person = {"name":"James","age":24}
person.clear()
print(person)               # {}

# copy(self) 浅拷贝
person1 = {"name":"James","age":24}
person2 = person1.copy()
print(person2)              # {'name': 'James', 'age': 24}
id(person1)                 # 3082800364
id(person2)                 # 3082798892

# get(self, k, d=None)根据key获取值，d是默认值
person = {"name":"James","age":24}
person.get("name")          # 'James'

# items(self)所有项的列表形式
person = {"name":"James","age":24}
person.items()              # [('name', 'James'), ('age', 24)]

# keys(self)所有的key列表
person = {"name":"James","age":24}
person.keys()               # ['name', 'age']

# pop(self, k, d=None)获取并在字典中移除
person = {"name":"James","age":24}
person.pop("name")          # 'James'
print(person)               # {'age': 24}

# popitem(self)获取并在字典中移除
person = {"name":"James","age":24}
person.popitem()            # ('age': 24)
print(person)               # {'name', 'James'}

# setdefault(self, k, d=None)如果key不存在，则创建，如果存在，则返回已存在的值且不修改
person = {"name":"James","age":24}
person.setdefault("name")   # 'James'
person.setdefault("sex")
print(person)               # {'name': 'James', 'age': 24, 'sex': None}

# update(self, E=None, **F)更新
person1 = {"name":"James","age":24}
person2 = {"tel":"10086"}
person1.update(person2)
print(person1)              # {'name': 'James', 'age': 24, 'tel': '10086'}

# values(self)所有的值
person = {"name":"James","age":24}
person.values()             # ['James', 24]
```



## 运算

运算符用于将各种类型的数据进行运算，让静态的数据跑起来。

编程语言中的运算大致分为以下几个大类：

- **算术运算**， 用于加减乘除等数学运算
- **赋值运算**，用于接收运算符或方法调用返回的结果
- **比较运算**, 用于做大小或等值比较运算
- **逻辑运算**，用于做 与、或、非运算
- **位运算**， 用于二进制运算

每种运算中所包含的符号称为相应的运算符，如 算术运算符、比较运算符等。

### 算术运算

Python中的数值的基本运算和C差不多

| 运算符  | 简称                       | 实例 a=10 b=20                    |
| :--: | :----------------------- | :------------------------------ |
| `+`  | 加 - 两个对象相加               | `a + b = 30`                    |
| `-`  | 减 -  两个对象相减              | `a - b = -10`                   |
| `*`  | 乘 - 两个数相乘或是返回一个被重复若干次的序列 | `a * b = 200`                   |
| `/`  | 除 - 两个数相除                | `b / a = 2`                     |
| `//` | 整除 - 返回商的整数部分            | `9//2 = 4 , 9.0//2.0 = 4.0`     |
| `%`  | 去余/取模 - 返回除法的余数          | `b % a = 0`                     |
| `**` | 幂 - 求幂/次方                | `a**b = 100000000000000000000L` |

```python
a = 2
b = 2.3         
c = 3
a + b             # 2 + 2.3 = 4.3
c - a             # 3 - 2 = 1
a / b             # 整数除以浮点数，运算以浮点数为准，2 / 2.3 = 0.8695652173913044
a / c             # Python 2中，整数除法，向下取整 2 / 3 = 0
a ** c            # a的c次方，结果为8
a += 1            # Python中没有i++的用法，自增用+=
c -= 3            # c变成0了
d = 'Hello'     
d + ' world!'     # 相当于字符串拼接，结果为'Hello world!'
d += ' "world"!'  # 相当于把字符串接在当前字符串尾，d变为'Hello "world"!'
e = r'\n\t\\'   
print(e)          # '\\n\\t\\\\'
```

需要注意以下几点：

- ==Python中没有 x++ 和 x-- 的操作符==。
- 在混合计算时，Python会把整型转换成为浮点数。


- Python 3中数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。

- Python 2中两个数值相除会根据数值类型判断是否整数除法，Python 3种则都按照浮点数。想要在Python 2种也执行Python 3中的除法需要执行下面语句：

  ```python
  1 / 2								# 0
  from __future__ import division     # 使用Python 3中的除法
  1 / 2                               # 0.5
  ```




### 赋值运算

| 运算符   | 描述       | 实例                                 |
| ----- | -------- | ---------------------------------- |
| `=`   | 简单的赋值运算符 | `c = a + b` 将 `a + b` 的运算结果赋值为 `c` |
| `+=`  | 加法赋值运算符  | `c += a` 等效于 `c = c + a`           |
| `-=`  | 减法赋值运算符  | `c -= a` 等效于 `c = c - a`           |
| `*=`  | 乘法赋值运算符  | `c *= a` 等效于 `c = c * a`           |
| `/=`  | 除法赋值运算符  | `c /= a` 等效于 `c = c / a`           |
| `//=` | 取整除赋值运算符 | `c //= a` 等效于 `c = c // a`         |
| `%=`  | 取模赋值运算符  | `c %= a` 等效于 `c = c % a`           |
| `**=` | 幂赋值运算符   | `c **= a` 等效于 `c = c ** a`         |



### 比较运算

所有比较运算符返回`1`表示真，返回`0`表示假。这分别与特殊的变量`True`和`False`等价。注意，这些变量名的大写。

比较操作具有相同的优先级。比较操作可以被任意连接，比如`x< y <= z`等同于`x < y and y <= z`，只是第一种形式下的`y`只被评估一次。另外，当`x < y`不成立时，这两种形式下的`z`都不会被评估。

| 运算符  | 名称   | 描述          |
| :--: | :--- | :---------- |
| `==` | 等于   | 比较对象是否相等    |
| `!=` | 不等于  | 比较两个对象是否不相等 |
| `<>` | 不等于  | 比较两个对象是否不相等 |
| `>`  | 严格大于 | 返回x是否大于y    |
| `<`  | 严格小于 | 返回x是否小于y。   |
| `>=` | 大于等于 | 返回x是否大于等于y  |
| `<=` | 小于等于 | 返回x是否小于等于y  |

> **说明：**
>
> - 不同类型的对象进行比较，从来不会相等（不同的数字类型除外）；
> - 当把`<`、`<=`、`>`和`>=`操作符在下面这几种情况下会抛出`TypeError`异常：
>   1. 用于复数和另外的内置数字类型进行比较时；
>   2. 比较的对象为不同类型，无法进行比较时；
>   3. 未定义的其他情况下；
> - 一个类的不同实例通常是不相等的，除非该类定义了`__eq__()`方法；
> - 一个类的实例不能相对于同一类或其他类的的其他实例进行排序，除非该类定义了足够的方法`__lt__()`, `__le__()`, `__gt__()`, `__ge__()`。如果想要比较运算符的常规含义, `__lt__()`和`__eq__()`就足够了；
> - 比较运算的结果为布尔值：`True`或`False`

### 逻辑运算

#### “真”值测试(Truth Value Testing)

在讲解“布尔运算”之前，我们先来说下Python中的一个特殊操作--“真”值测试。
 Python中的任何一个对象都可以被测试“真”值。这里说的“真”值测试可以这样理解：Python中的任何一个对象都可以转换为一个布尔值，而这个“真”值测试就是获取一个对象对应的布尔值的过程。

Python中只有下面这些值对应的布尔值为`False`：

- `None`
- `False`
- 数字类型中的`0`，如：`0`, `0.0`, `0j`
- 任意空序列，如：`''`, `()`, `[]`
- 任意一个空映射，如：`{}`
- 一个用户自定义类的实例--该用户自定义类中定义了一个`__bool__()`或`__len__()`或`__nonzero__()`方法，且实例调用该方法时返回整数`0`或布尔值`False`

除此之外，所有的其它值对应的布尔值都是`True`, 因此许多类型的对象永远是`True`。

 "真"值测试可以被用在`if`或`while`条件中，也可以作为布尔操作的操作数。

#### 布尔运算(Boolean Operations)

Python中的逻辑运算称为“布尔运算(Boolean Operations)”，操作符包括：`and`(与)、`or`(或)、`not`(非)。

下面按照他们的优先级升序顺序进行说明：

| 运算符   | 逻辑表达式     | 简称    | 描述                                       |
| ----- | --------- | ----- | ---------------------------------------- |
| `and` | `x and y` | 布尔"与" | 如果`x`为`False`，`x and y`返回`False`，否则它返回`y`的计算值 |
| `or`  | `x or y`  | 布尔"或" | 如果`x`是`非0`，它返回`x`的值，否则它返回`y`的计算值         |
| `not` | `not x`   | 布尔"非" | 如果`x`为`True`，返回`False` 。如果`x`为`False`，它返回`True` |

> **说明：**
>
> - `or`是一个短路操作符，也就是说，只有第一个参数的评估结果为`False`时，第二个参数才会被评估；
> - `and`也是一个短路操作符，也就是说，只有第一个参数的评估结果为`True`时，第二个参数才会被评估；
> - `not`操作符比非布尔操作符优先级低，因此，`not a == b` 被解释为 `not (a == b)`；如果写成 `a == not b`会报语法错误。

如下实例：

```python
# Python中的布尔值和逻辑运算非常直接
a = True
b = False
a and b     # False
a or b      # True
not a       # False 
 
a = 10      # True
b = 20      # True
c = 0       # False
a and b     # 20
b and a     # 10
a and c     # 0
a or b      # 10
b or a      # 20
a or c      # 10
c or b      # 20
not a       # False
not b       # False
not c       # True
```

### 位运算符

按位运算是指把数字转换为二进制来进行计算，位运算符包括以下几种：

| 运算符  | 简称   | 描述                                |
| ---- | ---- | --------------------------------- |
| `&`  | 按位与  | 参与运算的两个值,如果两个相应位都为1，则该位的结果为1，否则为0 |
| `|`  | 按位或  | 只要对应的二个二进位有一个为1时，结果位就为1。          |
| `^`  | 按位异或 | 当两对应的二进位相异时，结果为1                  |
| `~`  | 按位取反 | 对数据的每个二进制位取反，即把1变为0，把0变为1         |
| `<<` | 左移动  | 运算数的各二进位全部左移若干位，高位丢弃，低位补0         |
| `>>` | 右移动  | 运算数的各二进位全部右移若干位，低位丢弃，高位补0         |

如下实例：

```python
# 位运算
5 & 2   # 按位与，101 & 010 = 000
5 | 2   # 按位或，101 | 010 = 111
4 ^ 1   # 按位异或，100 ^ 001 = 101
~8      # 按位取反，1000 --> -(1000+1)
8 >> 3  # 右移3位，1000 --> 0001
1 << 3  # 左移3位，0001 --> 1000

a = 60        # 60 = 0011 1100  
b = 13        # 13 = 0000 1101  

a & b;        # 12 = 0000 1100
a | b;        # 61 = 0011 1101 
a ^ b;        # 49 = 0011 0001
c = ~a;       # -61 = 1100 0011
c = a << 2;   # 240 = 1111 0000
c = a >> 2;   # 15 = 0000 1111
```

### 三目运算

result = 值1 if 条件 else 值2 

如果条件成立，那么将“值1”赋值给result变量，否则将“值2”赋值给result变量。

如下实例：

```python
a = "James"
b = "Kobo"

a if a > b else b          # 'Kobo'
a if a < b else b          # 'James'
```



### 成员运算

`in`和`not in`支持序列、集合和映射类型的对象。

| 运算符      | 描述                                   |
| -------- | ------------------------------------ |
| `in`     | 如果在指定的序列中找到值返回`True`，否则返回`False`。    |
| `not in` | 如果在指定的序列中没有找到值返回`True`，否则返回 `False`。 |

如下实例：

```python
a = 10
b = 20
list = [1, 2, 10, 4, 5 ]

a in list                  # True
b in list                  # False
```



### 身份运算

`is`和`is not`操作符的行为是不能自定义的；另外，它们可以被应用到两个不同类型的对象，不会引发异常。

| 运算符      | 描述                | 实例                                       |
| -------- | ----------------- | ---------------------------------------- |
| `is`     | 判断两个标识符是不是引用自一个对象 | ``x is y`, 如果`id(x)`等于`id(y)`, `is`返回结果`1` |
| `is not` | 判断两个标识符是不是引用自不同对象 | `x is not y`, 如果`id(x)`不等于`id(y)`. `is not`返回结果`1` |

如下实例：

```python
a = 20
b = 20
c = 0
d = None

a is b        # True
b is c        # False
c is not a    # True
c is b        # False
d is None     # True
c is None     # False
```

### 运算优先级

**运算符优先级（从低到高）**

| 运算符                        | 描述        |
| -------------------------- | --------- |
| `lambda`                   | Lambda表达式 |
| `or`                       | 布尔“或”     |
| `and`                      | 布尔“与”     |
| `not x`                    | 布尔“非”     |
| `in not in`                | 成员测试      |
| `is is not`                | 同一性测试     |
| `= %= /= //= -= += *= **=` | 赋值运算符     |
| `< <= > >= != ==`          | 比较        |
| `|`                        | 按位或       |
| `^`                        | 按位异或      |
| `&`                        | 按位与       |
| `<< >>`                    | 移位        |
| `+ -`                      | 加法与减法     |
| `* / %`                    | 乘法、除法与取余  |
| `+x -x`                    | 正负号       |
| `~x`                       | 按位翻转      |
| `**`                       | 指数        |
| `x.attribute`              | 属性参考      |
| `x[index]`                 | 下标        |
| `x[index:index]`           | 寻址段       |
| `f(arguments...)`          | 函数调用      |
| `(experession,...)`        | 绑定或元组显示   |
| `[expression,...]`         | 列表显示      |
| `{key:datum,...}`          | 字典显示      |
| `'expression,...'`         | 字符串转换     |

如下实例：

```python
a = 20
b = 10
c = 15
d = 5
e = 0

(a + b) * c / d       # 90.0：(20 + 10) * 15 / 5
((a + b) * c) / d     # 90.0：((20 + 10) * 15) / 5
(a + b) * (c / d);    # 90.0：(20 + 10) * (15 / 5)
a + (b * c) / d;      # 50.0：20 + (10 * 15) / 5
```

## 流程控制

> 人们常说人生就是一个不断做选择题的过程：有的人没得选，只有一条路能走；有的人好一点，可以二选一；有些能力好或者家境好的人，可以有更多的选择；还有一些人在人生的迷茫期会在原地打转，找不到方向。对于相信有上帝的人来讲，这就好像是上帝事先为我们制定好了人生路线，也好像是那些神仙为唐曾师徒的取经之路提前设置的重重磨难，上帝和神仙掌控了一切。编程语言可以模拟人类生活的方方面面，**程序员就像上帝和神仙一样可以通过编程语言中特殊的关键字控制程序的执行过程，这些关键字组成的就是流程控制语句**。

编程语言中的流程控制语句分为以下几类：

- 顺序语句
- 分支语句
- 循环语句

其中顺序语句不需要单独的关键字来控制，就是一行行的执行，不需要特殊的说明。

### 代码块

==**强行缩进**来表明成块的代码，这是Python中一个让人爱恨交织的特点==！这样做的好处是代码十分清晰工整，还有助于防止写出过长的函数或者过深的嵌套，坏处是有时候不知为什么tab和空格就一起出现了，又或是多重if-else不知怎得就没对齐，还是挺麻烦的。

### 分支语句

条件分支语句是通过一条或多条语句（判断条件）的执行结果(`True/False`)来决定执行哪个分支的代码块。Python中提供的分支语句为：`if..else`语句，没有提供`switch..case`语句。`if..else`语句有以下几种形式：

- 单分支`if condition: do something `
- 双分支`if condition: do something else do other thing`
- 多分支`if condition: do something elif do another thing ... else do other thing`

```python
# 单分支。如果单分支语句的代码块只有一条语句，可以把if语句和代码写在同一行。
if 判断条件:
    代码块
 
if 判断条件: 一句代码
  
# 双分支。
if 判断条件:
    代码块
else:
    代码块

# 多分支：
if 判断条件1:
    代码块1
elif 判断条件2:
    代码块2
...
elif 判断条件n:
    代码块n
else:
    默认代码块    
    
```

> **说明：**
>
> 当上面的“判断条件”中的表达式可以是任意的表达式，也可以是任意类型的数据对象实例。只要判断条件的最终返回结果的“真”值测试为True时，就表示该条件成立，相应的代码块就会被执行；否则表示条件不成立，需要判断下一个条件。

Python的条件控制主要是三个关键字：if-elif-else，其中elif就是else if的意思。

```python
pets =['dog', 'cat', 'droid', 'fly']

for pet in pets:
    if pet == 'dog':        # 狗粮
        food = 'steak'      # 牛排
    elif pet == 'cat':      # 猫粮
        food = 'milk'       # 牛奶
    elif pet == 'droid':    # 机器人
        food = 'oil'        # 机油
    elif pet == 'fly':      # 苍蝇
        food = 'sh*t'       # 
    else:
        pass
    print(food)

# 需要提一下的是pass，这就是个空语句，什么也不做，占位用。

# Python并没有switch-case的语法，等效的用法要么是像上面一样用if-elif-else的组合，要么可以考虑字典：
pets = ['dog', 'cat', 'droid', 'fly']
food_for_pet = {
    'dog': 'steak', 
    'cat': 'milk', 
    'droid': 'oil', 
    'fly': 'sh*t'
}

for pet in pets:
    food = food_for_pet[pet] if pet in food_for_pet else None
    print(food)
# 这里还用到了一个if-else常见的行内应用，就是代替三元操作符，如果键在字典中，则food取字典的对应值，否则为None。

# 通过链式比较让语句简洁：
if -1 < x < 1:  # 相较于 if x > -1 and x < 1:
    print('The absolute value of x is < 1')
    
# 判断一个值是不是等于多个可能性中的一个：
if x in ['piano', 'violin', 'drum']:    # 相较于 if x == 'piano' or x == 'violin' or x =='drum':
    print("It's an instrument!")
    
# Python中的对象都会关联一个真值，所以在if表达式中判断是否为False或者是否为空的时候，是无需写出明确的表达式的：
a = True
if a:		# 判断是否为真，相较于 a is True
    print('a is True')

if 'sky':	# 判断是否空字符串，相较于 len('sky') > 0
    print('birds')
	
if '':		# 判断是否空字符串，同上
    print('Nothing!')

if {}:		# 判断是否空的容器(字典)，相较于len({}) > 0
    print('Nothing!')
```



### 循环语句

------

当我们需要多次执行一个代码语句或代码块时，可以使用循环语句。Python中提供的循环语句有：`while`循环和`for`循环。需要注意的是Python中没有`do..while`循环。此外，还有几个用于控制循环执行过程的循环控制语句：`break`、`continue`和`pass`。

#### While循环

while的就是循环和if的综合体，是一种单纯的基于条件的循环，本身没有遍历的意思，这是和for_each的本质差别，这种区别比起C/C++中要明确得多，用法如下：

```python
# while循环的基本形式
while 判断条件:
    代码块

# while循环基本形式    
i = 0
while i < 10:  # 笑10遍
    i+=1
    print("ha")

# while死循：当while的判断条件一直为True时，while循环体中代码就会永远循环下去。
while True:     # 一直笑
    print("ha")
    
# while..else
while 判断条件:
    代码块
else:
    代码块    
# else中的代码块会在while循环正常执行完的情况下执行，如果while循环被break中断，else中的代码块不会执行。    
 
# while循环正常执行结束的情况（else中的语句会被执行）    
count = 0
while count <=9:
    print(count, end=' ')
    count += 1
else:
    print('end')

# while循环被中断的情况（else中的语句不会被执行）
count = 0
while count <=9:
    print(count, end=' ')
    if count == 5:
        break
    count += 1
else:
    print('end')    

```



#### for循环

Python支持for_each风格的遍历方式。`for`循环通常用于遍历序列(如`list`、`tuple`、`range`、`str`)、集合(如`set`)和映射对象(如`dict`)。

`enumrate`：为可迭代的对象添加序号

```python
# for循环的基本格式：
for 临时变量 in 可迭代对象:
    代码块
# for...else
    
a = ['This', 'is', 'a', 'list', '!']
b = ['This', 'is', 'a', 'tuple', '!']
c = {'This': 'is', 'an': 'unordered', 'dict': '!'}

# 依次输出：'This' 'is' 'a' 'list' '!'
for x in a:
    print(x)

# 依次输出：'This' 'is' 'a' 'tuple' '!'
for x in b:
    print(x)

# 键的遍历。不依次输出：('This', 'is') ('dict', '!') ('an', 'unordered')
for key,value in c:
    print(key, value)

# 依次输出0到9
for i in range(10):
    print(i)
    
# 下标可以用enumerate
names = ["Rick", "Daryl", "Glenn"]
# 依次输出下标和名字
for i, name in enumerate(names):
    print(i, name)
# (0, 'Rick') (1, 'Daryl') (2, 'Glenn')

# 通过取下标遍历是可行的，比如用len()获得列表长度，然后用range()/xrange()函数获得下标，但是并不推荐这样做：
words = ["This", "is", "not", "recommended"]
# not pythonic :(
for i in xrange(len(words)):
    print(words[i]) 
```

在使用for循环时，有时会遇到这样一种场景：我们需要对遍历的每个元素进行某种判断，如果符合这种判断的情况没有发生，则执行一个操作。举个例子某神秘部门要审核一个字符串列表，如果没有发现不和谐的字眼，则将内容放心通过，一种解决办法是下面这样：

```python
# 这样需要设置一个标记是否发现不和谐因素的状态变量hexie，循环结束后再根据这个变量判断内容是否可以放心通过。
wusuowei = ["I", "don't", "give", "a", "shit"]  # 无所谓
hexie = True                                    # 默认和谐社会
for x in wusuowei:
    if x == "f**k":
        print("What the f**k!")                 # 发现了不该出现的东西，WTF！
        hexie = False                           # 不和谐了
        break                                   # 赶紧停下！不能再唱了

if hexie:                                       # 未发现不和谐元素！
    print("Harmonious society!")                # 和谐社会！

# 一种更简洁不过有些小众的做法是直接和else一起，如果for循环中的if块内的语句没有被触发，则通过else执行指定操作：
wusuowei = ["I", "don't", "give", "a", "shit"]
for x in wusuowei:
    if x == "f**k":
        print("What the f**k!")
        break
else:                            # for循环中if内语句未被触发
    print("Harmonious society!") # 和谐社会！
# 这样不需要一个标记是否和谐的状态变量，语句简洁了很多。
```



#### 循环控制语句

循环控制语句可以更改循环体中程序的执行过程，如中断循环、跳过本次循环。

| 循环控制语句  | 说明                                       |
| ------- | ---------------------------------------- |
| break   | 终止整个循环                                   |
| contine | 跳过本次循环，执行下一次循环                           |
| pass    | pass语句是个空语句，只是为了保持程序结构的完整性，没有什么特殊含义。pass语句并不是只能用于循环语句中，也可以用于分支语句中。 |

```python
# 遍历0-9范围内的所有数字，并通过循环控制语句打印出其中的奇数
for i in range(10):
    if i % 2 == 0:
        continue
    print(i, end=' ')
# 输出结果：1 3 5 7 9

# 通过循环控制语句打印一个列表中的前3个元素
names = ['Tom', 'Peter', 'Jerry', 'Jack', 'Lilly']
for i in range(len(names)):
    if i >= 3:
        break
    print(names[i])
```

#### 循环嵌套

循环嵌套是指：在一个循环体里面嵌入另一循环。

```python
# 通过while循环打印99乘法表
j = 1
while j <= 9:
    i = 1
    while i <= j:
        print('%d*%d=%d' % (i, j, i*j), end='\t')
        i += 1
    print()
    j += 1

# 通过for循环打印99乘法表
for j in range(1, 10):
    for i in range(1, j+1):
        print('%d*%d=%d' % (i, j, i*j), end='\t')
        i += 1
    print()
    j += 1
    
# 输出结果：
1*1=1   
1*2=2   2*2=4   
1*3=3   2*3=6   3*3=9   
1*4=4   2*4=8   3*4=12  4*4=16  
1*5=5   2*5=10  3*5=15  4*5=20  5*5=25  
1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36  
1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49  
1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64  
1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81  s    
```



#### 迭代器iterator

迭代器相当于一个函数，每次调用都返回下一个元素，从遍历的角度来看就和列表没有区别了。iteritems()就是一个迭代器，所以效果一样，区别是迭代器占用更少内存，因为不需要一上来就生成整个列表。一般来说，如果只需要遍历一次，用迭代器是更好的选择，若是要多次频繁从一个可遍历结构中取值，且内存够，则直接生成整个列表会更好。当然，用迭代器生成一个完整列表并不麻烦，所以有个趋势是把迭代器作为默认的可遍历方式，比如前面我们使用过用来生成等差数列列表的range()，在Python 2中对应的迭代器形式是xrange()。在Python 3中，range()就不再产生一个列表了，而是作为迭代器，xrange()直接没了。

range和xrange：指定范围，生成指定的数字



## 函数Functions

### 函数介绍及其作用

编程语言中的函数与数学中的函数是有区别的：数学中的函数有参数（输入），就会有相应的结果（输出）。编程语言中的函数有输入，不一定会返回结果。**编程语言中的函数其实就是一个用于完成某个特定功能的相关代码的代码段** 。那么哪些代码语句应该被整合到一起定义为一个函数呢？这取决于你想让这个函数完成的功能是什么。

为什么要将这个代码段定义成一个函数呢？这其实就是函数的作用。假设我们在编写一个可供用户选择的菜单程序，程序启动时需要打印一遍菜单列表，而且程序运行过程中用户也可以随时打印菜单列表，也就是说打印菜单列表的代码段可能要多次被用到，假设每次打印的菜单列表都是一样的，而且列表很长，那么我们是否应该每次在需要打印菜单的时候重复执行相同的代码呢？那么当我们需要增加或者减少一个菜单项时怎么办呢？显然我们需要在每个打印菜单的代码点都进行修改。如果我们把打印菜单的相关代码拿出来定义为一个函数，又会出现这样的场景呢？我们只需要在需要打印菜单列表的地方使用这个函数；当需要添加或减少一个菜单项时，只需要修改这个函数中的内容即可，程序的维护和扩展成本大大降低；同时，我们这个程序的代码会更加简洁，而且有条理性更加便于阅读，而不是一坨乱糟糟的让人看着就想重写的东西。当然，如果你要打印的是多级菜单，你可以通过函数的参数或全部变量通知该函数要打印的是几级菜单。总结一下，**编程语言中的函数的作用就是实现代码的可重用性，提高代码可维护性、扩展性和可读性**。

### 函数的定义

高级编程语言通常会提供很多内置的函数来屏蔽底层差异，向上暴露一些通用的接口，比如我们之前用到的`print()`函数和`open()`函数。除此之外，我们也可以自定义我们需要的函数。由于函数本身也是程序代码的一部分，因此为了标识出这段代码是一个函数通常需要使用特定的格式或关键字。另外还涉及到参数、方法名称、返回值等相关问题的约束。

#### Python中定义函数的规则：

- 函数代码块以`def`关键字开头，后接函数标识符（函数名称）和圆括号`()`；
- 函数名称以数字、小写字母和下划线组成并且不能以数字开头；
- 圆括号中可用于定义可接收的参数；
- 函数内容以圆括号`()`之后的冒号换行后起始，并且缩进；
- 函数的第一行通常用于写一个字符串`--`函数使用方式、参数说明等文档信息
- 函数中可以用`return`关键字返回一个值给函数调用方`--return [表达式]`，如果不写`return`相当于返回`None`。

> **说明：** 函数名称可以使用大写字母，但是不符合PEP8规范；另外Python3中函数名可以使用中文，但是还是不要给自己找麻烦为好。另外`return`语句不一定要写在函数末尾，而可以写在函数体的任意位置。`return`语句代表着函数的结束，函数在执行过程中只要遇到`return`语句，就会停止执行并返回结果。

Python中函数的调用方式与其他大部分编程语言都一样（其实我目前使用过的编程语言当中，只有Shell是个另类；好吧，其实它只是个脚本语言）：函数名(参数)

#### Python中定义函数的语法：

```python
def 函数名称( 参数 ):
    """
    函数使用说明、参数介绍等文档信息
    """
    代码块
    return [表达式]
```

#### 实例:

```python
# 写一个求和函数
def add(a, b):
    """
    计算并返回两个数的和
    a: 被加数
    b: 加数
    """
    c = a + b
    return c

# 通常写成这个样子：
def add(a, b):
    """
    计算并返回两个数的和
    a: 被加数
    b: 加数
    """
    return a + b
```

### 函数的参数说明

先来说下形参和实参的概念：

- **形参**：即形式参数，函数定义时指定的可以接受的参数即为形参，比如上面定义的add(a, b)函数中的a和b就是形参；
- **实参**：即实际参数，调用函数时传递给函数参数的实际值即为实参，比如上面都用add(1, 9)函数中的1和9就是实参；

重点需要说下函数的各种不同种类的参数。函数的参数可以分为以下几种：

- 位置参数
- 默认参数
- 关键字参数
- 可变(长)参数

不同编程语言对以上几种函数参数的支持各不相同，但是位置参数是最基本的参数类型，基本上所有的编程语言都支持。以下是一个常见编程语言的对比表格（Y表示支持，N表示不支持）：

|  参数类型   |  C   | C++  |   Java    |    PHP    | Python |  Go  |
| :-----: | :--: | :--: | :-------: | :-------: | :----: | :--: |
|  位置参数   |  Y   |  Y   |     Y     |     Y     |   Y    |  Y   |
|  默认参数   |  N   |  Y   |     N     |     Y     |   Y    |  N   |
| 可变(长)参数 |  Y   |  Y   | Y(JDK1.5) | Y(PHP5.6) |   Y    |  Y   |
|  关键字参数  |  N   |  N   |     N     |     N     |   Y    |  N   |

可见只有Python支持全部参数类型，而且只有Python支持关键字参数；另外，C、Java和Go都不支持默认参数，其中Java和Go与它们支持的方法重载特性有关（具体可以看下[这个帖子](https://www.zhihu.com/question/29891411)），并且它们可以通过方法重载实现默认参数的功能。

#### 位置参数

位置参数，顾名思义是和参数的顺序位置和数量有关的。函数调用时，实参的位置和个数要与形参对应，不然会报错。

```python
# 函数定义：两个位置参数
def my_print(name, age):
    print('NAME: %s' % name)
    print('AGE: %d' % age)

# 正确调用：参数位置和个数都正确
my_print('Tom', 18)
# NAME: Tom
# AGE: 18

# 错误调用：参数位置不正确
my_print(18, 'Tom')
# NAME: 18
# TypeError: %d format: a number is required, not str

# 错误调用：参数个数不正确
my_print('Tom')
# TypeError: my_print() missing 1 required positional argument: 'age'
```

#### 默认参数

**默认参数**：是指给函数的形参赋一个默认值，它是一个有默认值的位置参数。当调用函数时，如果为该参数传递了实参则该形参取实参的值，如果没有为该参数传递实参则该形参取默认值。

**默认参数的应用场景**：参数值在大部分情况下是固定/相同的。比如这里打印一个班中学生的姓名和年龄，这个班大部分为同龄人（年龄相同），这时我们就可以给“年龄”这个形参赋一个默认的值。

> **说明：** 默认参数只是一个有默认值的位置参数，因此它还是受到位置参数的限制。默认参数可以避免位置参数的一个限制：传递实参的个数，但是参数位置（顺序）仍然还是要一一对应。另外，默认参数必须放在位置参数后面（自己想想为什么）。

```python
# 函数定义：两个位置参数，后面一个是默认参数（有默认值）
def my_print(name, age=12):
    print('NAME: %s' % name)
    print('AGE: %d' % age)

# 正确调用：按照位置参数传值
my_print('Tom', 18)
# NAME: Tom
# AGE: 18
# age取的是函数调用时传递过来的实参

# 正确调用：不给age形参传值，age将取默认值
my_print('Tom')
# NAME: Tom
# AGE: 12
# 函数调用时没有给形参age传值，因此age取的是默认值

# 错误调用：试图跳过前面的位置参数直接给后面的默认参数传值
my_print(18)
# NAME: 18
# AGE: 12
# 可见，我们明明是想传递18给形参age的，结果18被赋给了name，而age仍然取得是默认值。
# 上面已经提到过，位置参数只是可以让我们少传一些参数，但是不能改变参数的位置和顺序。
# 另外，这也说明了默认参数为什么一定要放在后面：因为实参与形参是从前到后一一有序的对应关系，
# 也就是说在给后面参数传值的时候，不论前面的参数是否有默认值，必须要先给前面的参数先赋值。

# 错误调用：实参个数超过形参个数
my_print('Tom', 18, 'F')
# TypeError: my_print() takes from 1 to 2 positional arguments but 3 were given
# 这里要说明的是：默认参数只能相应的减少实参的个数，但是不能增加实参的个数。
```

#### 可变(长)参数

**可变(长)参数**：顾名思义，是指长度可以改变的参数。通俗点来讲就是，可以传任意个参数（包括0个）。

**可变(长)参数的应用场景**：通常在写一个需要对外提供服务的方法时，为了避免将来添加或减少什么新的参数使得所有调用该方法的代码点都要进行修改的情况发生，此时就可以用一个可变长的形式参数。

> **说明：** 默认参数允许我们调用函数时，可以少传递一些实参；而可变(长)参数则允许我们调用函数时，可以多传递任意个实参。另外，可变长参数应该定义在默认参数之后，因为调用函数时传递的实参会按照顺序一一赋值给各个形参，如果可变(长)参数定义在前面，那么后面的参数将永远无法取得传递的值。可变(长)参数名称通常用args，且参数名称前要有个"*"号，表示这是一个可变长参数。

```python
# 函数定义：一个位置参数、一个默认参数、一个可变长参数
def my_print(name, age=12, *args):
    print('NAME: %s' % name)
    print('AGE: %d' % age)
    print(args)
# 再次强调：位置参数、默认参数、可变长参数在函数定义中的位置不能变。

# 正确调用：只传递一个实参
my_print('Tom')
# NAME: Tom
# AGE: 12
# ()
# 方法调用时，只传递了一个实参，该实参会按照函数中参数的定义位置赋值给形参name，因此name的值为‘Tom’；
# 而形参age没有接收到实参，但是它有默认值，因此它取的是默认值12；
# 需要注意的是可变参数args也没有接收到传递值，但是打印出来的是一对小括号()，
# 说明args是一个tuple(元组)类型，当没有接收到实参时便是一个空tuple。

# 正确调用：传递两个实参
my_print('Tom', 18)
# NAME: Tom
# AGE: 18
# ()
# 与值传递一个实参的情况基本相同，只是默认参数接收到了传递值，不再取默认值。

# 正确调用：传递两个以上的实参
# 比如，现在需要多接收并打印一个人的性别(F: 表示女，M: 表示男)，可以这样用：
my_print('Tom', 18, 'F')
# NAME: Tom
# AGE: 18
# ('F',)

# 比如，现在需要多接收并打印一个人的性别(F: 表示女，M: 表示男)和籍贯信息，可以这样用：
my_print('Tom', 18, 'F', 'Hebei')
# NAME: Tom
# AGE: 18
# ('F', 'Hebei')

# 当然，我们也可以直接将一个tuple实例传递给形参args，但是tuple实例前也要加上*号作为前缀：
t = ('F', 'Hebei')
my_print('Tom', 19, *t)
# NAME: Tom
# AGE: 19
# SEX: F
# ADDRESS: Hebei

# 你甚至可以将传递给形参name和age的实参也放到要传递的tuple实例中，但是最好不要这样做，因为很容易发生混乱：
t = ('Jerry', 10, 'F', 'Hebei')
my_print(*t)
# NAME: Jerry
# AGE: 10
# SEX: F
# ADDRESS: Hebei
```

**实际应用说明**：

由于args接收到实参之后会被转换成一个tuple(元祖)的实例，而tuple本身是一个序列（有序的队列），因此我们可以通过下标(args[n])来获取相应的实参。但是我们需要在函数使用文档中写明args中各实参的传递顺序及意义，并且在获取args中的元素之前应该对args做非空判断。因此函数的定义及调用结果应该是这样的：

```python
# 函数定义：
def my_print(name, age=12, *args):
    """
    Usage: my_print(name[, age[, sex[, address]]])
    :param name: 姓名
    :param age: 年龄
    :param args: 性别、籍贯
    :return: None
    """
    print('NAME: %s' % name)
    print('AGE: %d' % age)
    if len(args) >= 1:
        print('SEX: %s' % args[0])
    if len(args) >= 2:
        print('ADDRESS: %s' % args[1])

# 函数调用及结果：
>>> my_print('Tom')
NAME: Tom
AGE: 12
>>> my_print('Tom', 18)
NAME: Tom
AGE: 18
>>> my_print('Tom', 18, 'F')
NAME: Tom
AGE: 18
SEX: F
>>> my_print('Tom', 18, 'F', 'Hebei')
NAME: Tom
AGE: 18
SEX: F
ADDRESS: Hebei
>>> t = ('F', 'Hebei')
>>> my_print('Tom', 19, *t)
NAME: Tom
AGE: 19
SEX: F
ADDRESS: Hebei
```

#### 关键字参数

**关键字参数**：顾名思义，是指调用函数时通过关键字来指定是为哪个形参指定的实参，如name="Tom", age=10。

> **说明：** 这个地方很容易发生思维混淆，所以需要特别说明一下：这里所说的关键字参数可以理解为以key=value的形式传递给函数的实参，注意是实参不是函数定义时声明的形参。而且在函数调用时可以通过关键字参数给函数定义时所声明的位置参数和默认参数传值（但是不能通过关键参数给可变长参数*args传值）。如果想实现像可变长参数那样在函数调用时传递任意个关键字参数给函数，则需要在函数定义时声明一个接受“可变长关键词参数”的形参，该形参名称通常为`kwargs`，且前面需要带"`**`"前缀--`**kwargs`。

**关键字参数应用场景**：关键字参数一方面可以允许函数调用时传递实参的顺序与函数定义时声明形参的顺序不一致，提高灵活性；另一方面，它弥补了可变长参数的不足。想一下，如果想为上面定义了可变长参数的函数只传递“籍贯”参数就必须同时传递“性别”参数；另外还要不断地判断tuple的长度，这是相当不方便的。而关键参数可以通过关键字来判断某个参数是否有传递值并获取该参数的实参值。

```python
# 函数定义：位置参数、默认参数、可变(长)参数、关键字参数
def my_print(name, age=12, *args, **kwargs):
    print('NAME: %s' % name)
    print('AGE: %d' % age)
    print(args)
    print(kwargs)

# 正确调用：只传递一个实参
>>> my_print('Tom')
NAME: Tom
AGE: 12
()
{}
# 方法调用时，只传递了一个实参，该实参会按照函数中参数的定义位置赋值给形参name，因此name的值为‘Tom’；
# 而形参age没有接收到实参，但是它有默认值，因此它取的是默认值12；
# 可变参数args也没有接收到传递值，因此args的值是一个空元组；
# 重点需要注意的是关键字参数kwargs也没有接收到传递值，但是其打印值为一个空字典(dict)实例。

# 正确调用：传递两个实参
>>> my_print('Tom', 18)
NAME: Tom
AGE: 18
()
{}
# 与值传递一个实参的情况基本相同，只是默认参数接收到了传递值，不再取默认值。

>>> my_print(age=18, name='Tom')
NAME: Tom
AGE: 18
()
{}
# 可以不按照形参声明的顺序传递实参

# 正确调用：传递两个以上的实参
# 以非key=value的形式传递所有参数：
>>> my_print('Tom', 18, 'F', 'Hebei')
NAME: Tom
AGE: 18
('F', 'Hebei')
{}
# 可见后面多余的两个实参都传递给了可变长参数args
# 最后一个addr参数以key=value的形式传递：

>>> my_print('Tom', 18, 'F', addr='Hebei')
NAME: Tom
AGE: 18
('F',)
{'addr': 'Hebei'}
>>>

# 最后两个参数sex和addr都以key=value的形式传递：
>>> my_print('Tom', 18, sex='F', addr='Hebei')
NAME: Tom
AGE: 18
()
{'sex': 'F', 'addr': 'Hebei'}
# 由以上两个示例可见，对于除去传递给位置参数和默认参数之外多余的参数，
# 如果是直接以value的形式提供实参，则会被传递给可变长参数args而成为一个元组中的元素；
# 如果是以key=value的形式提供实参，则会被传递给关键字参数kwargs而成为一个字典中的元素。

# 纳尼？你还想试试其他传参方式？看看下面有没有你想要的
>>> t=('Jerry', 19, 'F', 'Hebei')
>>> my_print(*t)
NAME: Jerry
AGE: 19
('F', 'Hebei')
{}

>>> d={'name':'Tom', 'age':18, 'sex':'F', 'addr':'Hebei'}
>>> my_print(**d)
NAME: Tom
AGE: 18
()
{'sex': 'F', 'addr': 'Hebei'}

>>> d={'sex':'F', 'addr':'Hebei'}
>>> my_print(age=18, name='Tom', **d)
NAME: Tom
AGE: 18
()
{'sex': 'F', 'addr': 'Hebei'}

>>> t=('Tom', 18, 'abc')
>>> d={'sex':'F', 'addr':'Hebei'}
>>> my_print(*t, **d)
NAME: Tom
AGE: 18
('abc',)
{'sex': 'F', 'addr': 'Hebei'}

>>> my_print(name='Tom', 18, sex='F', addr='Hebei')
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument
```

关于Python中的函数参数说了这么多，我觉得很多必要来个总结：

- Python中函数的参数有4中：位置参数、默认参数(有默认值的位置参数)、可变(长)参数、关键字参数(特殊的、优化过的可变长参数)；
- 无论是函数定义时声明形参，还是函数调用时传递实参，都必须按照上面的顺序进行(允许只包含一种或几种不同种类的参数)；简单点来说就是，调用函数时key=value形式的关键参数必须在value形式的参数后面；
- Python函数调用时，传递的实参会对应的传递给相应的形参，同一个形参接收到的实参不能多也不能少；


### 递归函数

------

函数是可以被调用的，且一个函数内部可以调用其他函数。如果一个函数在内部调用本身，这个函数就是一个递归函数。函数递归调用的过程与循环相似，而且理论上，所有的递归函数都可以写成循环的方式，但是递归函数的优点是定义简单，逻辑清晰。递归和循环都是一个重复的操作的过程，这些重复性的操作必然是需要有一定的规律性的。另外，很明显递归函数也需要一个结束条件，否则就会像死循环一样递归下去，直到由于栈溢出而被终止（这个下面介绍）。

可见，要实现一个递归函数需要确定两个要素：

- 递归规律
- 结束条件

#### 实例：计算正整数n的阶乘 n! = 1 * 2 * 3 * ... * n

##### 循环实现

思路有两个：

- 从1乘到n，需要额外定义一个计数器存放n当前的值
- 从n乘到1，无需额外定义计数器，直接对n进行减1操作，直到n=0返回1结束

```python
def fact(n):
    if n == 0:
        return 1
    
    result = 1
    while n >= 1:
        result *= n
        n -= 1
    return result
```

##### 递归实现

先来确定递归函数的两个要素：

- 递归规律：n!=1 * 2 * 3 * ... * n = (n-1)! * n，也就是说fact(n) = fact(n-1) * n，且n逐一减小
- 结束条件：当n==0时返回1结束

```python
def fact(n):
    if n == 0:
        return 1
    return fact(n-1) * n
```

怎么样？递归函数的实现方式是不是既简单、又清晰。

#### 递归函数优缺点

**递归函数的优点：**
 定义简单、逻辑清晰。

**递归函数的缺点：**
 效率并不高且需要注意防止栈溢出。

**其他特点：**
 大家会发现上面实现的递归函数在运算的过程中n是逐渐减小的，也就是说问题规模应该是逐层减少的。

#### 递归特性总结

下面我们来总结写递归的特性：

- 必须有一个明确的结束条件
- 每次进入更深一层的递归时，问题规模相比上次递归都应有所减少
- 递归效率不高，递归层次过多会导致栈溢出。

> 因为在计算中，函数调用时通过栈（stack，特点是后进先出--LIFO）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈针，每当函数返回，栈就会减少一层栈针。由于栈的大小不是无限的，所有递归调用的次数过多，会导致栈溢出。关于堆栈的介绍可以看下这里：[<<内存堆和栈的区别>>](http://www.cnblogs.com/lln7777/archive/2012/03/14/2396164.html)。

每种编程语言都对递归函数可递归的深度有限制（[可以看看这里](http://rosettacode.org/wiki/Find_limit_of_recursion)），有些是跟相应内存空间的分配有关（因为栈是在内存空间中的），如Java。Python中对递归的深度限制默认为1000，可以通过`sys.getrecursionlimit()`函数来获取该值，超过这个深度会报错：`RecursionError: maximum recursion depth exceeded in comparison`。当然也可以通过`sys.setrecursionlimit(n)`来设置新的限制值。

### 嵌套函数与闭包

------

#### 嵌套函数

嵌套函数是指在函数内部定义一个函数，这些函数都遵循各自的作用域和生命周期规则。

来看个例子：

```python
def outer():
    level = 1
    print('outer', level)
    def inner():
        level = 2
        print('inner', level)
    inner()
```

嵌套函数查找变量的顺序是：先查找自己函数体内部是否包含该变量，如果包含则直接应用，如果不包含则查找外层函数体内是否包含该函数，依次向外。

#### 闭包

首先要说明一个问题：**函数名其实也是一个变量**，我们通过def定义一个函数时，实际上就是在定义一个变量，函数名就是变量名称，函数体就是该变量的值。我们知道，变量是可以赋值给其他变量的，因此函数也是可以被当做返回值返回的，并且可以赋值给其他变量。

```python
def outer(x):
    def inner(y):
        print(x+y)
    return inner

f1 = outer(10)
f2 = outer(20)

f1(100) # 110
f2(100) # 120
```

我们知道局部变量的作用域是在定义它的函数体内部，局部变量在函数执行时进行声明，函数执行完毕则会被释放。上面也提到过了，函数也是一个变量，那么嵌套函数内部定义的函数也是一个局部变量，也就是说嵌套函数每调用一次，其内部的函数都会被定义一次。因此，在上面的示例中

```python
f1 = outer(10)
f2 = outer(20)
```

对于f1和f2而言，两次调用嵌套函数outer并返回的内部函数inner是不同的，且它们取到的x值也是不同的。从表面上来看f1和f2相当于把x分别替换成了10和20：

```python
def f1(y):
    print(10+y)

def f2(y):
    print(20+y)
```

但实际上不是这样的，f1和f2还是这样的：

```python
def f1(y):
    print(x+y)

def f2(y):
    print(x+y)
```

f1和f2被调用时，y的值是通过参数传递进来的（100），而x还是个变量。inner函数会在自己的函数体内部查找该局部变量x，发现没找到，然后去查找它外层的函数局部变量x，找到了。这里好像出现问题了，因为之前说过了局部变量会在函数执行结束后被释放，那么f1和f2被调用时outer函数已经执行完了，理论上x的值应该被释放了才对啊，为什么还能引用x的值？其实，这就是闭包的作用。

##### 闭包的定义

> 如果在一个内部函数中，引用了外部非全局作用域中的变量，那么这个内部函数就被认为是闭包(closure)。

在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数应用了外部函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在该内部函数被多次调用的过程中，这些私有变量能够保持其持久性。在支持将函数作为对象使用的编程语言中，一般都支持闭包，比如：Python、PHP、Javascript等。

闭包就是根据不同的配置信息得到不同的结果。专业解释是：闭包（closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的应用环境组合而成的实体。

##### 闭包的工作原理

Python支持一种特性叫做函数闭包（function closres），它的工作原理是：在非全局（global）作用域（函数）中定义inner函数时，这个inner函数会记录下外层函数的namespaces（外层函数作用域的locals，其中包括外层函数局部作用域中的所有变量），可以称作：定义时状态，inner函数可以通过__closure__（早期版本中为func_closure）这个属性来获得inner函数外层嵌套函数的namespaces。其实我们可以通过打印一个函数的__closesure__属性值是否为None来判断闭包是否发生。

###### 闭包与装饰器

其实装饰器就是一种闭包，或者说装饰器是闭包的一种经典应用。区别在于，装饰器的参数（配置信息）是一个函数或类，专门对类或函数进行加工、处理和功能增强。关于装饰器，我们会在后面详细介绍。

### 匿名函数

------

在Python中有两种定义函数的方式：

- 通过def关键字定义的函数：这是最常用的方式，前面已经介绍过
- 通过lambda关键字定义的匿名函数：这是本次要说的主角

lambda作为一个关键字，作为引入表达式的语法。与def定义的函数相比较而言，lambda是单一的表达式，而不是语句块。也就是说，我们仅仅能够在lambda中封装有限的业务逻辑（通常只是一个表达式），这样设计的目的在于：让lambda纯粹为了编写简单的函数（通常称为小函数）而设计，def则专注于处理更大的业务。

#### 匿名函数的定义

##### 语法：

```python
lambda argument1, argument2, ... argumentN :expression using argments
```

冒号左边是函数的参数，冒号右边是一个整合参数并计算返回值的表达式。

##### 实例：定义一个求两个数之和的函数

def函数

```python
def add(x, y):
    return x + y
```

lambda函数

```python
lambda x, y: x+y
```

#### 匿名函数的调用方式：

调用方式1：匿名函数也是一个函数对象，可以将匿名函数赋值给一个变量，然后通过在这个变量后加上一对小括号来调用：

```python
add = lambda x, y: x+y
sum = add(1, 2)
```

调用方式2：直接在lambda函数后加上一堆小括号调用：

```python
sum = (lambda x, y: x+y)(1, 3)
```

#### 匿名函数的特性：

- 函数体只能包含一个表达式
- 不能有return语句（表达式的值就是它的返回值）
- 参数个数不限，可以有0个、1个或多个

#### 什么时候用匿名函数

从上面提到的“匿名函数的调用方式”来看，匿名函数貌似没有什么卵用，反而可读性更差了。那么匿名函数在Python中存在的意义是什么呢？匿名函数一般应用于函数式编程中，在Python中通常是指与高阶函数的配合使用--把匿名函数当做高阶函数的参数来使用，下面的高阶函数实例中会用到。

### 高阶函数

------

我们上面已经提到过：函数名也是变量，函数名就是指向函数的变量。并且我们已经知道：变量是可以作为参数传递给函数的。由此，我们得出一个结论：函数是一个接受另外一个函数作为参数的，而这种函数就称为高阶函数（Higher-order function）。

#### 自定义高阶函数

我们来自定义一个高阶函数，这个函数用于求两个数的和，同时接收一个函数用于在求和之前对两个数值参数做一些额外的处理（如：取绝对值、求平方或其他任意操作）

```python
def nb_add(x, y, f):
    return f(x) + f(y)
```

其中x，y是用于求和的两个数值参数，f是对x，y进行处理的函数。我们试着先给f传递一个内置的abs(取绝对值)函数，也就是说先对x和y分别取绝对值，然后再相加：

```python
result = nb_add(10, -20, abs)
print(result)
```

运行结果是：`30`

我们来自定义一个求平方的方法，然后传递给f试试：

```python
def pow2(x):
    return pow(x, 2)

result = nb_add(10, -20, pow2)
print(result)
```

输出结果是：`500`

我们发现上面定义的pow2(x)函数的函数体只有一个表达式，因此我们完全可以不单独定义该函数而使用匿名函数来实现，这样可以使diamante变得更简洁：

```python
def nb_add(x, y, f):
    return f(x) + f(y)

result = nb_add(10, 20, lambda x: pow(x, 2))
print(result)
```



Python内置了一些非常有用的高阶函数，下面我们来看看常见的几个：

#### map, reduce和filter

需要注意的是，对于filter和map，在Python 2中返回结果是列表，Python 3中是生成器。

```python
# map可以用于对可遍历结构的每个元素执行同样的操作，批量操作：
map(lambda x: x**2, [1, 2, 3, 4])                 # [1, 4, 9, 16]
map(lambda x, y: x + y, [1, 2, 3], [5, 6, 7])     # [6, 8, 10]

# reduce则是对可遍历结构的元素按顺序进行两个输入参数的操作，
# 并且每次的结果保存作为下次操作的第一个输入参数，还没有遍历的元素作为第二个输入参数。
# 这样的结果就是把一串可遍历的值，减少（reduce）成一个对象：
reduce(lambda x, y: x + y, [1, 2, 3, 4])          # ((1+2)+3)+4=10

# filter顾名思义，根据条件对可遍历结构进行筛选：
filter(lambda x: x % 2, [1, 2, 3, 4, 5])          # 筛选奇数，[1, 3, 5]
```

至于列表生成和map/filter应该优先用哪种，这个问题很难回答，不过**Python创始人Guido似乎不喜欢map/filter/reduce**，他曾在表示过一些从函数式编程里拿来的特性是个错误。

#### map函数

```python
map(function, iterable, ...)
```

**map函数的参数说明：**

- map函数接收两类参数：函数和可迭代对象（Iterable）
- 第一个参数是函数，后面的参数都是可迭代对象。
- 处理函数的参数个数需要与传入的可迭代对象参数的个数对应，否则会报错。
- 如果传入的可迭代对象参数有多个，且每个iterable元素数量不相等时，结果中的元素个数与最短的那个iterable的元素个数一致。

**map函数的作用是：**

将传入的函数依次作用到可迭代对象的每个元素，并把结果作为新的迭代器对象（Iterator）返回（Python2.x中会直接返回一个列表）。

**实例1：计算给定列表中的每个元素的平方值并放回一个新的列表**

```python
def pow2(x):
    return x * x
    
L = [1, 2, 3, 4, 5, 6]

list1 = list(map(pow2, L))
print(list1)
```

输出结果为：`[1, 4, 9, 16, 25, 36]`

上面已经演示过，pow2()可以直接使用匿名函数：

```python
L = [1, 2, 3, 4, 5, 6]

list1 = list(map(lambda x: pow(x, 2), L))
print(list1)
```

可见map函数作为高阶函数，事实上是把运算规则抽象了，因此，我们不仅可以计算简单的f(x)=x*x，还可以计算任意复杂的函数。

**实例2：计算两个序列中对应元素的和并保存至一个新的列表中**

```python
L = [1, 2, 3, 4, 5, 6]
T = (7, 8, 9, 10)

list1 = list(map(lambda x, y: x+y, L, T))
print(list1)
```

输出结果为：`[8, 10, 12, 14]`

#### reduce函数

> 这里需要说明一下：reduce函数在Python 2.x中跟map函数一样都是Python内置函数，Python 3.x中已经被转移到functools模块了。

```python
reduce(function, sequence, initializer=None)
```

**reduce函数的参数说明：**

- 接收一个函数参数、一个序列参数和一个可选的initalizer参数
- 如果可选参数initializer被提供，则相当于把它作为sequence的一个元素插入sequence的首部

**reduce函数的作用是：**

把一个函数作用在指定的序列上，这个函数必须接收两个参数，然后把计算结果继续和序列的下一个元素做累计计算，最终返回一个结果。简单来讲，就是对一个序列中的元素做聚合运算。

**实例1：计算指定数列中所有元素的和**

```
from functools import reduce

L = [1, 2, 3, 4, 5]
sum1 = reduce(lambda x, y: x + y, L)
print(sum1)

sum2 = reduce(lambda x, y: x + y, L, 6)
print(sum2)
```

输出结果为：

```
15
21
```

这个过程相当于：`(((1 + 2) + 3) + 4) + 5`

**实例2：将数字字符串转成int**

```
from functools import reduce

def fn(x, y):
    return int(x)*10 + int(y)

num = reduce(lambda x, y: int(x)*10 + y, '12345')
print(num)
```

也可以封装成一个函数：

```
from functools import reduce

def str2int(s):
    return reduce(lambda x, y: int(x)*10 + int(y), s)

num = str2int('12345')
print(num)
```

也可以先通过map函数将字符串中的字符转成int，然后再通过reduce进行运算:

```
from functools import reduce

def str2int(s):
    def char2num(c):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[c]
    return reduce(lambda x, y: x*10 + y, map(char2num, s))

num = str2int('12345')
print(num)
```

其实char2sum也可以用匿名函数来实现，但是可读性不太好。另外我举这个例子的本义不是为了单纯的演示map/reduce/匿名函数的使用，而是想说明嵌套函数与高阶函数综合使用的场景，这在某些场景下可以使代码逻辑变得更清晰。

#### filter函数

```
filter(function, iterable)
```

**filter函数的参数说明：**

- filter函数接收一个函数参数和一个可迭代对象参数，函数参数可以为None
- 函数的返回值（True或False）用于判断可迭代对象的当前元素是否要保留

**filter函数的作用是：**

用于过滤可迭代对象，具体过程是：把传入的函数依次作用于可迭代对象的每个元素，如果函数返回值为Ture则保留该元素，如果返回值为False则丢弃该元素，并最终把保留的元素作为一个iterator（迭代器）返回。如果function是None，则根据可迭代对象各元素的真值测试结果决定是否保留该元素。

> 与Python内置的filter函数作用刚好相反的函数是`itertools.filterfalse(function, sequence)`，它用于过滤出序列中通过function函数计算结果为False的元素。

**实例1：分别打印出指定列表中的奇数和偶数**

```
from itertools import filterfalse

L = [1, 2, 3, 4, 5, 6, 7, 8, 9]

odd_num = list(filter(lambda x: x % 2 == 1, L))
even_num = list(filterfalse(lambda x: x%2 == 1, L))
print('奇数：', odd_num)
print('偶数：', even_num)
```

输出结果：

```
奇数： [1, 3, 5, 7, 9]
偶数： [2, 4, 6, 8]
```

**实例2：删除序列中的空字符串**

```
L = ['ABC', '', 'DEF', '  ', '1233', None]

list1 = list(filter(None, L))
print(list1)
```

输出结果为：`['ABC', 'DEF', '  ', '1233']`

由于第4个由3个空白字符组成的字符串的真值测试结果为True，因此它还是会被保留。被看来还是需要传递个函数参数才行：

```
L = ['ABC', '', 'DEF', '  ', '1233', None]

list1 = list(filter(lambda s: s and s.strip(), L))
print(list1)
```

输出结果：`['ABC', 'DEF', '1233']`

#### sorted函数

```python
sorted(iterable[, key][, reverse])
```

**sorted函数的参数说明：**

- sorted函数可以接收一个可迭代对象iterable作为必选参数，还可以接收两个可选参数key和reverse，但是这两个可选参数如果要提供的话，需要作为关键字参数进行传递；
- 参数key接收的是一个函数名，该函数用来实现自定义排序；如，要按照绝对值大小进行排序：key=abs
- 参数reverse接收的是一个布尔值：如果reverse=Ture，表示倒叙排序，如果reverse=False，表示正序排序；reverse默认值为False

> **关于参数key的进一步说明：** 排序的核心是比较两个元素的大小。如果要比较的是两个数字，我们可以直接比较；如果是字符串，也可以按照ASCII码的大小进行比较。但是，如果要比较的元素是两个序列或dict等复杂数据呢？这时，我们可能需要指定一个计算“用于比较的值”的运算规则，比如我们指定取两个dict中的某个共同的key对应的值来进行比较，又比如我们指定用将两个字符串都转换为小写或者大写后的结果值进行比较。其实说简单点，参数key这个函数作用是：计算/获取用来进行比较的值。如果我们需要自定义这个函数时，需要注意该函数应该有一个参数，这个参数接收的就是可迭代对象中每个元素的值。

**sorted函数的作用是：**

对可迭代对象iterable中的元素进行排序，并将排序结果作为一个新的list返回。

**实例1：数字列表排序**

```python
list1 = sorted([10, 9, -21, 13, -30])
list2 = sorted([10, 9, -21, 13, -30], key=abs)
list3 = sorted([10, 9, -21, 13, -30], key=abs, reverse=True)

print(list1)
print(list2)
print(list3)
```

输出结果：

```
[-30, -21, 9, 10, 13]
[9, 10, 13, -21, -30]
[-30, -21, 13, 10, 9]
```

**实例2：字符串列表排序**

```python
list1 = sorted(['how', 'What', 'check', 'Zero'])
list2 = sorted(['how', 'What', 'check', 'Zero'], key=lower)
list3 = sorted(['how', 'What', 'check', 'Zero'], key=lower, reverse=True)

print(list1)
print(list2)
print(list3)
```

输出结果：

```
['What', 'Zero', 'check', 'how']
['check', 'how', 'What', 'Zero']
['Zero', 'What', 'how', 'check']
```

**实例3：tuple列表排序**
 假设我们用一组tuple表示姓名和年龄，然后用sorted()函数分别按姓名升序和年龄降序进行排序：

```python
def sort_by_name(t):
    return t[0]

def sort_by_age(t):
    return t[1]

L = [('Tom', 18), ('Jerry', 15), ('Peter', 16), ('John', 20)]
list1 = sorted(L, key=sort_by_name)
list2 = sorted(L, key=sort_by_age, reverse=True)
print('sort by name asc: ', list1)
print('sort by age desc: ', list2)
```

输出结果：

```
sort by name asc:  [('Jerry', 15), ('John', 20), ('Peter', 16), ('Tom', 18)]
sort by age desc:  [('John', 20), ('Tom', 18), ('Peter', 16), ('Jerry', 15)]
```

**实例4：字典内容排序**

对字典排序的方法有很多中，但核心思想都是一样的：把dict中的key或value或item分离出来放到一个list中，然后在对这个list进行排序，从而间接实现对dict的排序。

```python
D = {'Tom': 18, 'Jerry': 15, 'Peter': 16, 'John': 20}

list1 = sorted(D.items(), key=lambda d: d[0])
list2 = sorted(D.items(), key=lambda d: d[1], reverse=True)

print('sort by key asc:', list1)
print('sort by value desc:', list2)
```

输出结果：

```
sort by key asc: [('Jerry', 15), ('John', 20), ('Peter', 16), ('Tom', 18)]
sort by value desc: [('John', 20), ('Tom', 18), ('Peter', 16), ('Jerry', 15)]
```

### 内置函数

------

Python解释器有许多内置的函数和类型，有一些之前已经用到过，比如：

- 数学函数：abs()、max()、min()、pow()、sum()
- 类型转换函数：int()、float()、str()、bool()、list()、tuple()、dict()、set()
- 进制转换函数：bin()、oct()、hex()
- 高阶函数：map()、filter()、sorted()
- 打开文件用的函数：的open()
- 输入与输出函数：input()、raw_input()、print()
- 获取对象内存地址的函数：id()

这些函数我们在之前的文章中基本都演示了，不在此赘述。关于他们的详细说明以及其它内置函数的使用可以参考下面给出的列表及官方文档连接地址。

Python 3相对于Python 2的内置函数有些变动：

- 新增了一些内置方法，如：ascii()、bytes()、exec()
- 删除了一些内置方法, 如：cmp()、execfile()
- 移动了一些内置方法，如：reduce()被移动到了functools模块下
- 修改了一些内置方法，如：sorted()函数在Python 3.5的文档中么有再提到cmp参数了（貌似用不到这个参数）

> Python 3中的高阶函数还有一个比较大的改变，如map()和filter()在Python 2中是直接返回一个列表(list)，而在Python 3中是返回一个迭代器(Iterator)。

##### Python 3.5内置函数列表（[官方文档地址](https://docs.python.org/3.5/library/functions.html)）

![img](http://images2015.cnblogs.com/blog/1063221/201701/1063221-20170106115338066-1870088631.png)

##### Python 2.7内置函数列表（[官方文档地址](https://docs.python.org/2.7/library/functions.html)）

![img](http://images2015.cnblogs.com/blog/1063221/201701/1063221-20170106115613956-360080900.png)
















其实和很多语言差不多，括号里面定义参数，参数可以有默认值，且默认值不能在无默认值参数之前。Python中的返回值用return定义，如果没有定义返回值，默认返回值是None。参数的定义可以非常灵活，可以有定义好的固定参数，也可以有可变长的参数(args: arguments)和关键字参数(kargs: keyword arguments)。如果要把这些参数都混用，则固定参数在最前，关键字参数在最后。

Python中万物皆对象，所以一些情况下函数也可以当成一个变量似的使用。

Lambda表达式在Python中是一种匿名函数，lambda关键字后面跟输入参数，然后冒号后面是返回值（的表达式）。

```python
def say_hello():
    print('Hello!')

def greetings(x='Good morning!'):
    print(x)

say_hello()                 		# Hello!
greetings()                 		# Good morning!
greetings("What's up!")     		# What's up!
a = greetings()             		# a = None

def create_a_list(x, y=2, z=3):	    # 默认参数项必须放后面
    return [x, y, z]

b = create_a_list(1)        		# [1, 2, 3]
c = create_a_list(3, 3)     		# [3, 3, 3]
d = create_a_list(6, 7, 8)  	    # [6, 7, 8]

def traverse_args(*args):
    for arg in args:
        print(arg)

traverse_args(1, 2, 3)              # 依次打印1, 2, 3
traverse_args('A', 'B', 'C', 'D')   # 依次打印A, B, C, D

def traverse_kargs(**kwargs):
    for k, v in kwargs.items():
        print(k, v)

traverse_kargs(x=3, y=4, z=5)       # 依次打印('x', 3), ('y', 4), ('z', 5)
traverse_kargs(fighter1='Fedor', fighter2='Randleman') 
# ('fighter1', 'Fedor') ('fighter2', 'Randleman')

def foo(x, y, *args, **kwargs):
    print(x, y)
    print(args)
    print(kwargs)

# 第一个pring输出(1, 2)
# 第二个print输出(3, 4, 5)
# 第三个print输出{'a': 3, 'b': 'bar'}
foo(1, 2, 3, 4, 5, a=6, b='bar')

# 有个小机器人在坐标(0, 0)处，我们用不同的动作控制小机器人移动：
moves = ['up', 'left', 'down', 'right']
coord = [0, 0]
for move in moves:
    if move == 'up':        # 向上，纵坐标+1
        coord[1] += 1
    elif move == 'down':    # 向下，纵坐标-1
        coord[1] -= 1
    elif move == 'left':    # 向左，横坐标-1
        coord[0] -= 1
    elif move == 'right':   # 向右，横坐标+1
        coord[0] += 1
    else:
        pass
    print(coord)            # 打印当前位置坐标

# 不同条件下对应的是对坐标这个列表中的值的操作，单纯的从字典取值就办不到了，
# 所以就把函数作为字典的值，然后用这个得到的值执行相应动作：
moves = ['up', 'left', 'down', 'right']

def move_up(x):         # 定义向上的操作
    x[1] += 1

def move_down(x):       # 定义向下的操作
    x[1] -= 1

def move_left(x):       # 定义向左的操作
    x[0] -= 1

def move_right(x):      # 定义向右的操作
    x[0] += 1

# 动作和执行的函数关联起来，函数作为键对应的值
actions = {
    'up': move_up,
    'down': move_down,
    'left': move_left,
    'right': move_right
}

coord = [0, 0]

for move in moves:
    actions[move](coord)
    print(coord)

# 把函数作为值取到后，直接加一括号就能使了，这样做之后起码在循环部分看上去很简洁。
# 有点C里边函数指针的意思，只不过更简单。 

# lambda表达式。
def get_val_at_pos_1(x):
    return x[1]

heros = [
    ('Superman', 99),
    ('Batman', 100),
    ('Joker', 85)
]

sorted_pairs0 = sorted(heros, key=get_val_at_pos_1)
sorted_pairs1 = sorted(heros, key=lambda x: x[1])

print(sorted_pairs0)
print(sorted_pairs1)

# 万物皆对象，给lambda表达式取名字也是可以的
some_ops = lambda x, y: x + y + x*y + x**y
some_ops(2, 3)  # 2 + 3 + 2*3 + 2^3 = 19
```



## 生成器（Generator）

生成器是迭代器的一种，形式上看和函数很像，只是把return换成了yield，在每次调用的时候，都会执行到yield并返回值，同时将当前状态保存，等待下次执行到yield再继续：

```python
# 从10倒数到0
def countdown(x):
    while x >= 0:
        yield x
        x -= 1

for i in countdown(10):
    print(i)

# 打印小于100的斐波那契数
def fibonacci(n):
    a = 0
    b = 1
    while b < n:
        yield b
        a, b = b, a + b

for x in fibonacci(100):
    print(x)

# 生成器和所有可迭代结构一样，可以通过next()函数返回下一个值，
# 如果迭代结束了则抛出StopIteration异常：
a = fibonacci(3)
print(next(a))  # 1
print(next(a))  # 1
print(next(a))  # 2
print(next(a))  # 抛出StopIteration异常

# Python 3.3以上可以允许yield和return同时使用，return的是异常的说明信息：
# Python 3.3以上可以return返回异常的说明
def another_fibonacci(n):
    a = 0
    b = 1
    while b < n:
        yield b
        a, b = b, a + b
    return "No more ..."

a = another_fibonacci(3)
print(next(a))  # 1
print(next(a))  # 1
print(next(a))  # 2
print(next(a))  # 抛出StopIteration异常并打印No more消息(仅返回异常信息一次)

```

### 列表推导（list comprehension）

列表生成是Python 2.0中加入的一种语法，可以非常方便地用来生成列表和迭代器，比如上节中map的两个例子和filter的一个例子可以用列表生成重写为：

```python
[x**2 for x in [1, 2, 3, 4]]                      # [1, 4, 9 16]
# zip()函数可以把多个列表关联起来，通过zip()可以按顺序同时输出两个列表对应位置的元素对。
[sum(x) for x in zip([1, 2, 3], [5, 6, 7])]       # [6, 8, 10]
[x for x in [1, 2, 3, 4, 5] if x % 2]             # [1, 3, 5]

# 如果要生成迭代器只需要把方括号换成括号，生成字典也非常容易
iter_odd = (x for x in [1, 2, 3, 4, 5] if x % 2)
print(type(iter_odd))                             # <type 'generator'>
square_dict = {x: x**2 for x in range(5)}   
print(square_dict)                                # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```



## 类（Class）

Python对于类的定义是简单直接的，比较特殊的是protected和private在Python中是没有明确限制的，一个惯例是用单下划线开头的表示protected，用双下划线开头的表示private。

- 类的初始化使用的是__init__(self,)，所有成员变量都是self的，所以以self.开头。
- Python中变量的访问权限都是靠自觉的。
- 单下划线开头的变量是可以直接访问的，而双下划线开头的变量则触发了Python中一种叫做name mangling的机制，其实就是名字变了下，仍然可以通过前边加上“_类名”的方式访问。
- 类定义中紧跟着类名字下一行的字符串叫做docstring，可以写一些用于描述类的介绍，如果有定义则通过“类名.__doc__”访问。这种前后都加双下划线访问的是特殊的变量/方法，除了__doc__和__init__还有很多。
- Python中的继承方式就是定义类的时候把父类放在括号里。

```python
class A:
    """Class A"""
    def __init__(self, x, y, name):
        self.x = x
        self.y = y
        self._name = name

    def introduce(self):
        print(self._name)

    def greeting(self):
        print("What's up!")

    def __l2norm(self):
        return self.x**2 + self.y**2

    def cal_l2norm(self):
        return self.__l2norm()

a = A(11, 11, 'Leonardo')
print(A.__doc__)        	# "Class A"
a.introduce()           	# "Leonardo"
a.greeting()            	# "What's up!"
print(a._name)          	# 可以正常访问
print(a.cal_l2norm())       # 输出11*11+11*11=242
print(a._A__l2norm())       # 仍然可以访问，只是名字不一样
print(a.__l2norm())     	# 报错: 'A' object has no attribute '__l2norm'

# Python中的继承
class B(A):
    """Class B inheritenced from A"""
    def greeting(self):
        print("How's going!")

b = B(12, 12, 'Flaubert')
b.introduce()   # Flaubert
b.greeting()    # How's going!
print(b._name())        # Flaubert
print(b._A__l2norm())   # “私有”方法，必须通过_A__l2norm访问
```





## 文件操作

### I/O操作概述

I/O在计算机中是指Input/Output，也就是Stream(流)的输入和输出。这里的输入和输出是相对于内存来说的，Input Stream（输入流）是指数据从外（磁盘、网络）流进内存，Output Stream是数据从内存流出到外面（磁盘、网络）。程序运行时，数据都是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方（通常是磁盘、网络操作）就需要IO接口。

**那么这个IO接口是由谁提供呢？高级编程语言中的IO操作是如何实现的呢？**

操作系统是个通用的软件程序，其通用目的如下：

- 硬件驱动
- 进程管理
- 内存管理
- 网络管理
- 安全管理
- I/O管理

操作系统屏蔽了底层硬件，向上提供通用接口。因此，操作I/O的能力是由操作系统的提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来供开发者使用，Python也不例外。

### 文件读写实现原理

文件读写就是一种常见的IO操作。那么根据上面的描述，可以推断Python也应该封装操作系统的底层接口，直接提供了文件读写相关的操作方法。事实上，也确实如此，而且Java、PHP等其他语言也是。

**那么我们要操作的对象是什么呢？我们又如何获取要操作的对象呢？**

由于操作I/O的能力是由操作系统提供的，且现代操作系统不允许普通程序直接操作磁盘，所以读写文件时需要请求操作系统打开一个对象（通常被称为文件描述符--`file descriptor`, 简称`fd`），这就是我们在程序中要操作的文件对象。

通常高级编程语言中会提供一个内置的函数，通过接收"文件路径"以及“文件打开模式”等参数来打开一个文件对象，并返回该文件对象的文件描述符。因此通过这个函数我们就可以获取要操作的文件对象了。这个内置函数在Python中叫`open()`，在PHP中叫`fopen()`。

### 文件读写操作步骤

不同的编程语言读写文件的操作步骤大体都是一样的，都分为以下几个步骤：

1）打开文件，获取文件描述符

2）操作文件描述符--读/写

3）关闭文件

只是不同的编程语言提供的读写文件的API是不一样的，有些提供的功能比较丰富，有些比较简陋。

需要注意的是：**文件读写操作完成后，应该及时关闭**。一方面，文件对象会占用操作系统的资源；另外一方面，操作系统对同一时间能打开的文件描述符的数量是有限制的，在Linux操作系统上可以通过`ulimit -n`来查看这个显示数量。如果不及时关闭文件，还可能会造成数据丢失。因为我将数据写入文件时，操作系统不会立刻把数据写入磁盘，而是先把数据放到内存缓冲区异步写入磁盘。当调用`close`方法时，操作系统会保证把没有写入磁盘的数据全部写到磁盘上，否则可能会丢失数据。

### 文件打开模式

我们先来看下在Python、PHP和C语言中打开文件的函数定义

**Python**

```python
# Python2
open(name[, mode[, buffering]])

# Python3
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

**PHP**

```php
resource fopen ( string filename , string mode [, bool use_include_path = false [, resource context ]] )
```

**C语言**

```c
int open(const char * pathname, int flags);
```

会发现以上3种编程语言内置的打开文件的方法接收的参数中，除了都包含一个“文件路径名称”，还会包含一个mode参数（C语言的open函数中的flags参数作用相似）。这么mode参数定义的是打开文件时的模式，常见的文件打开模式有：只读、只写、可读可写、只追加。不同的编程语言中对文件打开模式的定义有些微小的差别，我们来看下Python中的文件打开模式有哪些。

| **文件打开模式** | **描述**                                   |
| ---------- | ---------------------------------------- |
| r          | 以只读模式打开文件，并将文件指针指向文件头；如果文件不存在会报错         |
| w          | 以只写模式打开文件，并将文件指针指向文件头；如果文件存在则将其内容清空，如果文件不存在则创建 |
| a          | 以只追加可写模式打开文件，并将文件指针指向文件尾部；如果文件不存在则创建     |
| r+         | 在r的基础上增加了可写功能                            |
| w+         | 在w的基础上增加了可读功能                            |
| a+         | 在a的基础上增加了可读功能                            |
| b          | 读写二进制文件（默认是t，表示文本），需要与上面几种模式搭配使用，如ab，wb, ab, ab+（POSIX系统，包括Linux都会忽略该字符） |

**思考1：** r+、w+和a+都可以实现对文件的读写，那么他们有什么区别呢？

- r+会覆盖当前文件指针所在位置的字符，如原来文件内容是"Hello，World"，打开文件后写入"hi"则文件内容会变成"hillo, World"
- w+与r+的不同是，w+在打开文件时就会先将文件内容清空，不知道它有什么用
- a+与r+的不同是，a+只能写到文件末尾（无论当前文件指针在哪里）

**思考2：** 为什么要定义这些模式呢？为什么不能像我们用word打开一篇文档一样既可以读，又可以写，还可修改呢？

关于这个问题，我查了很多资料，也没找到很权威的说明。在跟同行朋友交流过程中，发现大家主要有两种观点：

- **跟安全有关**，有这种观点的大部分是做运维的朋友，他们认为这就像linux上的rwx（读、写、执行）权限。
- **跟操作系统内核管理I/O的机制有关**，有这种观点的大部分是做C开发的，特别是与内核相关的开发人员。为了提高读写速度，要写入磁盘的数据会先放进内存缓冲区，之后再回写。由于可能会同时打开很多文件，当要回写数据时，需要遍历以打开的文件判断是否需要回写。他们认为如果打开文件时指定了读写模式，那么需要回写时，只要去查找以“可写模式”打开的文件就可以了。

### Python文件操作步骤示例

我们来读取这样一个文本文件：song.txt，该文件的字符编码为utf-8。

```
匆匆那年我们 究竟说了几遍 再见之后再拖延
可惜谁有没有 爱过不是一场 七情上面的雄辩
匆匆那年我们 一时匆忙撂下 难以承受的诺言
只有等别人兑现
```

#### 菜鸟实现：

```python
# Python3实现：
# 第一步：（以只读模式）打开文件
f = open('song.txt', 'r', encoding='utf-8')

# 第二步：读取文件内容
print(f.read())

# 第三步：关闭文件
f.close()

# Python2的实现
# 第一步：（以只读模式）打开文件
f = open('song.txt', 'r')

# 第二步：读取文件内容
print(f.read().decode('utf-8'))

# 第三步：关闭文件
f.close()
```

**说明：**

Python3中已经内置对Unicode的支持，字符串str已经是真正的Unicode字符串。也就是说Python3中的文件读取方法已经自动完成了解码处理，因此无需再手动进行解码，可以直接将读取的文件中的内容进行打印；Python2中的字符串str是字节串，读取文件得到的也是字节串，在打印之前应该手动将其解码成Unicode字符串。关于这部分的说明，可以参考之前这篇文章[<<再谈Python中的字符串与字符编码>>](http://www.cnblogs.com/yyds/p/6171340.html)。

#### 中级实现

在实现基本功能的前提下，考虑一些可能的意外因素。因为文件读写时都有可能产生IO错误（IOError），一旦出错，后面包括f.close()在内的所有代码都不会执行了。因此我们要保证文件无论如何都能被关闭。那么可以用try...finally来实现，这实际上就是try...except..finally的简化版（我们只用Python3来进行示例演示）：

```python
f = ''
try:
    f = open('song.txt', 'r', encoding='utf-8')
    print(f.read())
    num = 10 / 0
finally:
    print('>>>>>>finally')
    if f:
        f.close()
```

尽管`try`代码块中出现了异常，但是”>>>>>>finally“ 信息还是被打印了，说明`finally`代码块被执行，即文件关闭操作被执行。但是结果中错误信息还是被输出了，因此还是建议用一个完成的`try...except...finally`语句对异常信息进行捕获和处理。

#### 最佳实践

为了避免忘记或者为了避免每次都要手动关闭文件，我们可以使用with语句（一种语法糖，语法糖语句通常是为了简化某些操作而设计的）。with语句会在其代码块执行完毕之后自动关闭文件。因此我们可以这样来改写上面的程序：

```python
with open('song.txt', 'r', encoding='utf-8') as f:
    print(f.read())
print(f.closed)
```

是不是变得简介多了，代码结构也比较清晰了。`with`之后打印的`f.closed`属性值为`True`，说明文件确实被关闭了。

**思考:**

`with`语句会帮我们自动处理异常信息吗？

要回答这个问题就要提到“上下文管理器” 和`with`语句的工作流程。

`with`语句不仅仅可以用于文件操作，它实际上是一个很通用的结构，允许使用所谓的上下文管理器（`context manager`）。上下文管理器是一种支持`__enter__()`和`__exit__()`这两个方法的对象。`__enter__()`方法不带任何参数，它在进入`with`语句块的时候被调用，该方法的返回值会被赋值给`as`关键字之后的变量。`__exit__()`方法带有3个参数：`type`（异常类型）, `value`（异常信息）, `trace`（异常栈），当`with`语句的代码块执行完毕或执行过程中因为异常而被终止都会调用`__exit__()`方法。正常退出时该方法的3个参数都为`None`，异常退出时该方法的3个参数会被分别赋值。如果`__exit__()`方法返回值（真值测试结果）为`True`则表示异常已经被处理，命令执行结果中就不会抛出异常信息了；反之，如果`__exit__()`方法返回值（真值测试结果）为`False`，则表示异常没有被处理并且会向外抛出该异常。

现在我们应该明白了，异常信息会不会被处理是由`with`后的语句返回对象的`__exit__()`方法决定的。文件可以被用作上下文管理器。它的`__enter__`方法返回文件对象本身，`__exit__`方法会关闭文件并返回`None`。我们看下`file`类中关于这两个方法的实现：

```python
def __enter__(self): # real signature unknown; restored from __doc__
    """ __enter__() -> self. """
    return self
    
def __exit__(self, *excinfo): # real signature unknown; restored from __doc__
    """ __exit__(*excinfo) -> None.  Closes the file. """
    pass
```

可见，`file`类的`__exit__()`方法的返回值为`None`，`None`的真值测试结果为`False`，因此用于文件读写的`with`语句代码块中的异常信息还是会被抛出来，需要我们自己去捕获并处理。

```python
with open('song.txt', 'r', encoding='utf-8') as f:
    print(f.read())
    num = 10 / 0
```

**注意：** 上面所说的`__exit__()`方法返回值（真值测试结果）为`True`则表示异常已经被处理，指的是`with`代码块中出现的异常。它对于`with`关键字之后的代码中出现的异常是不起作用的，因为还没有进入上下文管理器就已经发生异常了。因此，无论如何，还是建议在必要的时候在`with`语句外面套上一层`try...except`来捕获和处理异常。

有关“上下文管理器”这个强大且高级的特性的更多信息，请参看Python参考手册中的上下文管理器部分。或者可以在Python库参考中查看上下文管理器和`contextlib`部分。

### Python文件读取相关方法

我们知道，对文件的读取操作需要将文件中的数据加载到内存中，而上面所用到的`read()`方法会一次性把文件中所有的内容全部加载到内存中。这明显是不合理的，当遇到一个几个G的的文件时，必然会耗光机器的内存。这里我们来介绍下Python中读取文件的相关方法：

| **方法**        | **描述**                                   |
| ------------- | ---------------------------------------- |
| `read()`      | 一次读取文件所有内容，返回一个`str`                     |
| `read(size)`  | 每次最多读取指定长度的内容，返回一个`str`；在Python2中`size`指定的是字节长度，在Python3中`size`指定的是字符长度 |
| `readlines()` | 一次读取文件所有内容，按行返回一个`list`                  |
| `readline()`  | 每次只读取一行内容                                |

此外，还要两个与文件指针位置相关的方法

| **方法**    | **描述**          |
| --------- | --------------- |
| `seek(n)` | 将文件指针移动到指定字节的位置 |
| `tell()`  | 获取当前文件指针所在字节位置  |

下面来看下操作实例

#### 读取指定长度的内容

```python
# Python2
with open('song.txt', 'r') as f:
    print(f.read(12).decode('utf-8'))
# 匆匆那年
    
# Python3
with open('song.txt', 'r', encoding='utf-8') as f:
    print(f.read(12))  
# 匆匆那年我们 究竟说
```

- Python2中read(size)方法的size参数指定的要读取的字节数，而song.txt文件是UTF-8编码的内容，一个汉字占3个字节，因此12个字节刚好是4个汉字。
- Python3中read(size)方法的size参数指定的要读取的字符数，这与文件的字符编码无关，就是返回12个字符。

#### 读取文件中的一行内容

```python
# Python2
with open('song.txt', 'r', encoding='utf-8') as f:
    print(f.readline())
# 匆匆那年我们 究竟说了几遍 再见之后再拖延

# Python3
with open('song.txt', 'r') as f:
    print(f.readline().decode('utf-8'))
# 匆匆那年我们 究竟说了几遍 再见之后再拖延
```

#### 遍历打印一个文件中的每一行

这里我们只以Python3来进行实例操作，Python2仅仅是需要在读取到内容后进行手动解码而已，上面已经有示例。

```python
# 方式一：先一次性读取所有行到内存，然后再遍历打印
with open('song.txt', 'r', encoding='utf-8') as f:
    for line in f.readlines():
        print(line)
# 这种方式的缺点与read()方法是一样的，都是会消耗大量的内存空间。

# 方式二：通过迭代器一行一行的读取并打印
with open('song.txt', 'r', encoding='utf-8', newline='') as f:
    for line in f:
        print(line)
```

另外，发现上面的输出结果中行与行之间多了一个空行。这是因为文件每一行的默认都有换行符，而`print()`方法也会输出换行，因此就多了一个空行。去掉空行也比较简单：可以用`line.rstrip()`去除字符串右边的换行符，也可以通过`print(line, end='')`避免`print`方法造成的换行。

`file`类的其他方法：

| **方法**                 | **描述**                                   |
| ---------------------- | ---------------------------------------- |
| `flush()`              | 刷新缓冲区数据，将缓冲区中的数据立刻写入文件                   |
| `next()`               | 返回文件下一行，这个方法也是`file`对象实例可以被当做迭代器使用的原因    |
| `truncate([size])`     | 截取文件中指定字节数的内容，并覆盖保存到文件中，如果不指定`size`参数则文件将被清空; Python2无返回值，Python3返回新文件的内容字节数 |
| `write(str)`           | 将字符串写入文件，没有返回值                           |
| `writelines(sequence)` | 向文件写入一个字符串或一个字符串列表，如果字符串列表中的元素需要换行要自己加入换行符 |
| `fileno()`             | 返回一个整型的文件描述符，可以用于一些底层IO操作上（如，`os`模块的`read`方法） |
| `isatty()`             | 判断文件是否被连接到一个虚拟终端，是则返回`True`，否则返回`False`  |

### 文件读写与字符编码

**读写文件时怎样指定字符编码呢？**

Python2中的对文件的`read`和`write`操作都是字节，也就说Python2中文件的`read`相关方法读取的是字节串（如果包含中文字符，会发现`len()`方法的结果不等于读取到的字符个数，而是字节数）。如果我们要得到正确的字符串，需要手动将读取到的结果`decode`（解码）为字符串；相反，要以特定的字符编码保存要写入的数据时，需要手动`encode`（编码）为字节串。这个`encode()`和`decode()`函数可以接收一个字符编码参数。

```python
# 读操作
with open('song.txt', 'r') as f:
     print(f.read().decode('utf-8'))

# 写操作
with open('song2.txt', 'w') as f:
    # f.write(u'你好'.encode('utf-8'))
    # f.write('你好'.decode('utf-8').encode('utf-8'))
    f.write('你好')
```

Python3的`open`函数包括一个encoding参数用来指定被操作文件的字符编码。Python3中`read`和`write`操作的都是字符串，实际上是Python解释器帮我们自动完成了写入时的`encode`（编码）和读取时的`decode`（解码）操作，因此我们只需要在打开文件(`open`函数)时指定字符编码就可以了。

**文件读写时有没有默认编码呢？**

Python3中`open`函数的`encoding`参数显然是可以不指定的，这时候就会用一个“默认字符编码”。

看下Python3中`open`函数文档对`encoding`参数的说明：

```python
encoding is the name of the encoding used to decode or encode the
file. This should only be used in text mode. The default encoding is
platform dependent, but any encoding supported by Python can be
passed.  See the codecs module for the list of supported encodings.
```

也就是说，`encoding`参数的默认值是与平台有关的，比如Window上默认字符编码为GBK，Linux上默认字符编码为UTF-8。

而对于Python2来说，在进行文件写操作时，字节会被直接保存；在进行文件读操作时，如果不手动进行来`decode`操作自然也就用不着默认字符编码了。但是这时候在不同的字符终端打印的时候，会用当前平台的字符编码自动将字节解码为字符，此时可能会出现乱码。如song.txt文件时UTF-8编码的，在windows（字符编码为GBK）的命令行终端进行如下操作就会出现乱码。我们应该尽可能的获取被操作文件的字符编码，并明确指定encoding参数的值。



在Python中，推荐用上下文管理器（with-as）来打开文件，IO资源的管理更加安全，而且不用老惦记着给文件执行close()函数。

```python
# 考虑有个文件name_age.txt，里面存储着名字和年龄的关系
# 读取文件内容并全部显示
with open('name_age.txt', 'r') as f: 	    # 打开文件，读取模式
    lines = f.readlines()              	    # 一次读取所有行
    for line in lines:                  	# 按行格式化并显示信息
        name, age = line.rstrip().split(',')
        print('{} is {} years old.'.format(name, age))
        
# 要读取文件内容，并把年龄和名字的顺序交换存成新文件
with open('name_age.txt', 'r') as fread, open('age_name.txt', 'w') as fwrite:
    line = fread.readline()
    while line:
        name, age = line.rstrip().split(',')
        fwrite.write('{},{}\n'.format(age, name))
        line = fread.readline()

# 对象序列化，可以用pickle模块：      
import pickle

lines = [
    "I'm like a dog chasing cars.",
    "I wouldn't know what to do if I caught one...",
    "I'd just do things."
]

with open('lines.pkl', 'wb') as f: 	    # 序列化并保存成文件
    pickle.dump(lines, f)

with open('lines.pkl', 'rb') as f: 	    # 从文件读取并反序列化
    lines_back = pickle.load(f)

print(lines_back)                   	# 和lines一样       
```

注意到，序列化的时候就得使用b模式了。Python 2中有个效率更高的pickle叫cPickle，用法和pickle一样，在Python 3中就只有一个pickle。



## 异常

相比起其他一些语言，在Python中我们可以更大胆地使用异常，因为异常在Python中是非常常见的存在，比如下面这种简单的遍历：

```python
a = ['Why', 'so', 'serious', '?']

for x in a:
    print(x)
```

当用for进行遍历时，会对要遍历的对象调用iter()。这需要给对象创建一个迭代器用来依次返回对象中的内容。为了能成功调用iter()，该对象要么得支持迭代协议(定义__iter__())，要么得支持序列协议(定义__getitem__())。当遍历结束时，__iter__()或者__getitem__()都需要抛出一个异常。__iter__()会抛出StopIteration，而__getitem__()会抛出IndexError，于是遍历就会停止。

在深度学习中，尤其是数据准备阶段，常常遇到IO操作。这时候遇到异常的可能性很高，采用异常处理可以保证数据处理的过程不被中断，并对有异常的情况进行记录或其他动作：

```python
for filepath in filelist:   # filelist中是文件路径的列表
    try:
        with open(filepath, 'r') as f:
            # 执行数据处理的相关工作
            ...
        
        print('{} is processed!'.format(filepath))
    except IOError:
        print('{} with IOError!'.format(filepath))
        # 异常的相应处理
        ...
```



## 多进程（multiprocessing）

深度学习中对数据高效处理常常会需要并行，这时多进程就派上了用场。考虑这样一个场景，在数据准备阶段，有很多文件需要运行一定的预处理，正好有台多核服务器，我们希望把这些文件分成32份，并行处理：

```python
from multiprocessing import Process  #, freeze_support

def process_data(filelist):
    for filepath in filelist:
        print('Processing {} ...'.format(filepath))
        # 处理数据
        ...

if __name__ == '__main__':
    # 如果是在Windows下，还需要加上freeze_support()
    # freeze_support()
    
    # full_list包含了要处理的全部文件列表
    ...

    n_total = len(full_list) # 一个远大于32的数
    n_processes = 32

    # 每段子列表的平均长度
    length = float(n_total) / float(n_processes)
    
    # 计算下标，尽可能均匀地划分输入文件列表
    indices = [int(round((i+1)*length)) for i in range(-1, n_processes)]
    
    # 生成每个进程要处理的子文件列表
    sublists = [full_list[indices[i]:indices[i+1]] for i in range(n_processes)]
    
    # 生成进程
    processes = [Process(target=process_data, args=(x,)) for x in sublists]

    # 并行处理
    for p in processes:
        p.start()

    for p in processes:
        p.join()
```

其中**if** __name__ **==** '__main__'用来标明在import时不包含，但是作为文件执行时运行的语句块。

为什么不用多线程呢？简单说就是Python中线程的并发无法有效利用多核。

如果有兴趣的读者可以从下面这个链接看起：

[GlobalInterpreterLock - Python Wiki](https://link.zhihu.com/?target=https%3A//wiki.python.org/moin/GlobalInterpreterLock)



## 模块

模块就是一个包含了所有你定义的函数和变量的文件，模块必须以`.py`为扩展名。模块可以从其他程序中‘输入’(`import`)以便利用它的功能。

在Python程序中导入其他模块使用'`import`', 所导入的模块必须在`sys.path`所列的目录中，因为`sys.path`第一个字符串是空串''即当前目录，所以程序中可导入当前目录的模块。

### 字节编译的`.pyc`文件

导入模块比较费时，Python做了优化，以便导入模块更快些。一种方法是创建字节编译的文件，这些文件以`.pyc`为扩展名。

`pyc`是一种二进制文件，是`py`文件经编译后产生的一种`byte code`，而且是跨平台的（平台无关）字节码，是由Python虚拟机执行的，类似于Java或.Net虚拟机的概念。`pyc`的内容，是跟Python的版本相关的，不同版本编译后的`pyc`文件是不同的。

### from .. import

如果想直接使用其他模块的变量或其他，而不加'模块名+.'前缀，可以使用`from .. import`。

例如想直接使用`sys`的`argv`，`from sys import argv`或`from sys import *`

### 模块的`__name__`

每个模块都有一个名称，`py`文件对应模块名默认为`py`文件名，也可在`py`文件中为`__name__`赋值；如果是`__name__`，说明这个模块被用户单独运行。

### dir()函数

`dir(sys)`返回`sys`模块的名称列表；如果不提供参数，即`dir()`，则返回当前模块中定义名称列表。

`del `-> 删除一个变量/名称，`del`之后，该变量就不能再使用。



Python内置的核心模块提供的功能无法满足我们的需求时就需要导入外部模块，而导入模块的功能有两种方式：

- import MODULE ：导入整个模块
- from MODULE import XX ：导入模块中的一部分（方法、变量、或常量等）

例如，要想查看或更改python查找模块的路径列表就需要使用sys模块下的path变量；若需要执行系统命令可以使用os模块下的system()方法。

```python
import sys
from os import system

print(sys.path)
print(system("ping www.baidu.com"))
```

**获取python脚本执行时传入的参数**

我们在写shell脚本时，经常会通过接受执行脚本时传入的变量来做相应的操作，来保证脚本的灵活性。比如我们要写一个脚本来调用ping命令对指定的域名进行ping测试，这时候显然将域名当做参数传递给脚本要比把域名写死在脚本中灵活的多。shell中可以只用$1,$2这样的特殊变量来获取传入的参数，而python中需要用sys模块下的argv变量来获取。

> sys.argv是一个列表，与shell相同，其第一个元素是当前脚本的名称，之后才是传入的参数。

编写一个ping.py，内容如下：

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

import sys
import os

print(type(sys.argv))
print(sys.argv)
```

在shell中执行如下：

```shell
$ cd /Users/Bolik/PycharmProjects/PythonDemo
$ python ping.py 1 2 3 test
<type 'list'>
['ping.py', '1', '2', '3', 'test']
```



### os模块

深度学习中的数据多是文件，所以数据处理阶段和文件相关的操作就非常重要。除了文件IO，Python中一些操作系统的相关功能也能够非常方便地帮助数据处理。想象一下我们有一个文件夹叫做data，下边有3个子文件夹叫做cat，dog和bat，里面分别是猫，狗和蝙蝠的照片。为了训练一个三分类模型，我们先要生成一个文件，里面每一行是文件的路径和对应的标签。定义cat是0，dog是1，bat是2，则可以通过如下脚本：

```python
import os

# 定义文件夹名称和标签的对应关系
label_map = {
    'cat': 0,
    'dog': 1,
    'bat': 2
}

with open('data.txt', 'w') as f:

    # 遍历所有文件，root为当前文件夹，dirs是所有子文件夹名，files是所有文件名
    for root, dirs, files in os.walk('data'):
        for filename in files:
            filepath = os.sep.join([root, filename])   	    # 获得文件完整路径
            dirname = root.split(os.sep)[-1]            	# 获取当前文件夹名称
            label = label_map[dirname]                  	# 得到标签
            line = '{},{}\n'.format(filepath, label)
            f.write(line)
            
# os.sep是当前操作系统的路径分隔符，在Unix/Linux中是'/'，Windows中是'\'。
# 获取所有文件的名称
filenames = os.listdir('data')
```

os也提供了诸如拷贝，移动和修改文件名等操作。同时因为大部分深度学习框架最常见的都是在Unix/Linux下使用，并且Unix/Linux的shell已经非常强大（比Windows好用太多），所以只需要用字符串格式化等方式生成shell命令的字符串，然后通过os.system()就能方便实现很多功能，有时比os，还有Python中另一个操作系统相关模块shutil还要方便：

```python
import os, shutil

filepath0 = 'data/bat/IMG_000001.jpg'
filepath1 = 'data/bat/IMG_000000.jpg'

# 修改文件名
os.system('mv {} {}'.format(filepath0, filepath1))
# os.rename(filepath0, filepath1)

# 创建文件夹
dirname = 'data_samples'
os.system('mkdir -p {}'.format(dirname))
# if not os.path.exists(dirname):
#    os.mkdir(dirname)

# 拷贝文件
os.system('cp {} {}'.format(filepath1, dirname))
# shutil.copy(filepath1, dirname)
```



# Python单元测试

## 软件测试

大型软件系统的开发是一个很复杂的过程，其中因为人的因素而所产生的错误非常多，因此软件在开发过程必须要有相应的质量保证活动，而软件测试则是保证质量的关键措施。正像软件熵（software entropy）所描述的那样：一个程序从设计很好的状态开始，随着新的功能不断地加入，程序逐渐地失去了原有的结构，最终变成了一团乱麻（其实最初的"很好的状态"得加个问号）。测试的目的说起来其实很简单也极具吸引力，那就是写出高质量的软件并解决软件熵这一问题。

可惜的是，软件开发人员很少能在编码的过程中就进行软件测试，大部分软件项目都只在最终验收时才进行测试，有些项目甚至根本没有测试计划！随着软件质量意识的增强，许多软件开发组织开始转向UML、CMM、RUP、XP等软件工程方法，以期提高软件质量，并使软件开发过程更加可控，好在这些方法对测试都提出了很严格的要求，从而使得测试在软件开发过程的作用开始真正体现出来。

软件测试作为一种系统工程，涉及到整个软件开发过程的各个方面，需要管理人员、设计人员、开发人员和测试人员的共同努力。作为软件开发过程中的主要力量，现今的程序员除了要编写实现代码外，还承担着单元测试这一艰巨任务，因此必须采用新的工作模式：

- 编写和维护一套详尽的单元测试用例；
- 先构造单元测试和验收测试用例，然后再编写代码；
- 根据构造的测试用例来编写代码。

单元测试负责对最小的软件设计单元（模块）进行验证，它使用软件设计文档中对模块的描述作为指南，对重要的程序分支进行测试以发现模块中的错误。由于软件模块并不是一个单独的程序，为了进行单元测试还必须编写大量额外的代码，从而无形中增加了开发人员的工作量，目前解决这一问题比较好的方法是使用测试框架。测试框架是在用XP方法进行单元测试时的关键，尤其是在需要构造大量测试用例时更是如此，因为如果完全依靠手工的方式来构造和执行这些测试，肯定会变成一个花费大量时间并且单调无味的工作，而测试框架则可以很好地解决这些问题。

使用Python语言的开发人员可以使用==Steve Purcell编写的PyUnit==作为单元测试框架，通过将单元测试融合到PyUnit这一测试框架里，Python程序员可以更容易地增加、管理、执行测试用例，并对测试结果进行分析。此外，使用PyUnit还可以实现自动单元测试（回归测试）。

## 规范Python单元测试

测试是一个贯穿于整个开发过程的连续过程，从某个意义上说，软件开发的过程实际上就是测试过程。正如**Martin Fowler**所说的"==在你不知道如何测试代码之前，就不该编写程序。而一旦你完成了程序，测试代码也应该完成。除非测试成功，你不能认为你编写出了可以工作的程序==。"

测试最基本的原理就是比较预期结果是否与实际执行结果相同，如果相同则测试成功，否则测试失败。为了更好地理解PyUnit这一自动测试框架的作用，先来看一个简单的例子，假设我们要对例1中的Widget类进行测试：

```python
# 例1. widget.py
# 将要被测试的类
class Widget:
    def __init__(self, size = (40, 40)):
        self._size = size
    def getSize(self):
        return self._size
    def resize(self, width, height):
        if width < 0  or height < 0:
            raise ValueError, "illegal size"
        self._size = (width, height)
    def dispose(self):
        pass
```

采用手工方式进行单元测试的Python程序员很可能会写出类似例2的测试代码来，

```python
# 例2. manual.py
from widget import Widget
# 执行测试的类
class TestWidget:
    def testSize(self):
        expectedSize = (40, 40);
        widget = Widget()
        if widget.getSize() == expectedSize:
            print "test [Widget]: getSize works perfected!"
        else:
            print "test [Widget]: getSize doesn't work!"
# 测试
if __name__ == '__main__':
    myTest = TestWidget()
    myTest.testSize()
```

稍一留心你不难发现这种手工测试方法存在许多问题。首先，测试程序的写法没有一定的规范可以遵循，十个程序员完全可能写出十种不同的测试程序来，如果每个Python程序员都有自己不同的设计测试类的方法，光维护被测试的类就够麻烦了，谁还顾得上维护测试类。其次，需要编写大量的辅助代码才能进行单元测试，例1中用于测试的代码甚至比被测试的代码还要多，而这毫无疑问将增大Python程序员的工作量。

为了让单元测试代码能够被测试和维护人员更容易地理解，最好的解决办法是让开发人员遵循一定的规范来编写用于测试的代码，具体到Python程序员来讲，则是要采用PyUnit这一自动测试框架来构造单元测试用例。目前PyUnit已经得到了大多数Python开发人员的认可，成了事实上的单元测试标准。如果采用PyUnit来进行同样的测试，则测试代码将如例3所示：

```python
# 例3. auto.py
from widget import Widget
import unittest
# 执行测试的类
class WidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget()
    def tearDown(self):
        self.widget = None
    def testSize(self):
        self.assertEqual(self.widget.getSize(), (40, 40))
# 构造测试集
def suite():
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase("testSize"))
    return suite
# 测试
if __name__ == "__main__":
    unittest.main(defaultTest = 'suite')
```

在采用PyUnit这一单元测试框架后，用于测试的代码做了相应的改动：

- 用`import`语句引入`unittest`模块。
- 让所有执行测试的类都继承于`TestCase`类，可以将`TestCase`看成是对特定类进行测试的方法的集合。
- 在`setUp()`方法中进行测试前的初始化工作，并在`tearDown()`方法中执行测试后的清除工作，`setUp()`和`tearDown()`都是`TestCase`类中定义的方法。
- 在`testSize()`中调用`assertEqual()`方法，对`Widget`类中`getSize()`方法的返回值和预期值进行比较，确保两者是相等的，`assertEqual()`也是`TestCase`类中定义的方法。
- 提供名为`suite()`的全局方法，PyUnit在执行测试的过程调用`suit()`方法来确定有多少个测试用例需要被执行，可以将`TestSuite`看成是包含所有测试用例的一个容器。

虽然看起来有点复杂，但PyUnit使得所有的Python程序员都可以使用同样的单元测试方法，测试过程不再是杂乱无章的了，而是在同一规范指导下进行的有序行为，这就是使用PyUnit这一自动单元测试框架所带来的最大好处。

## **自动**测试框架PyUnit

在Python中进行单元测试时需要用到PyUnit模块，Python 2.1及其以后的版本都将PyUnit作为一个标准模块。

### 测试用例**TestCase**

软件测试中最基本的组成单元是测试用例（test case），PyUnit使用`TestCase`类来表示测试用例，并要求所有用于执行测试的类都必须从该类继承。`TestCase`子类实现的测试代码应该是自包含（self contained）的，也就是说测试用例既可以单独运行，也可以和其它测试用例构成集合共同运行。

TestCase类中常用的函数或方法有：

- **setUp：**进行测试前的初始化工作。
- **tearDown：**执行测试后的清除工作。
- **failedinfo：**表示不成立打印信息faliedinfo，为可选参数。
- **self.assertEqual(value1, value2, failedinfo)：**会无条件的导致测试失败，不推荐使用。
- **self.assertTrue(, failedinfo)：**断言value1 == value2。
- **self.assertFalse(, failedinfo)：**断言value为真。
- **self.assertRaises(ValueError, self.widget.resize, -1, -1)：**断言肯定发生异常，如果没发生异常，则为测试失败。参数1为异常，参数2为抛出异常的调用对象，其余参数为传递给可调用对象的参数。

`TestCase`在PyUnit测试框架中被视为测试单元的运行实体，Python程序员可以通过它派生自定义的测试过程与方法（测试单元），利用Command和Composite设计模式，多个TestCase还可以组合成测试用例集合。PyUnit测试框架在运行一个测试用例时，TestCase子类定义的`setUp()`、`runTest()`和`tearDown()`方法被依次执行，最简单的测试用例只需覆盖`runTest()`方法来执行特定的测试代码就可以了。

```python
# 例4. static_single.py
import unittest
# 执行测试的类
class WidgetTestCase(unittest.TestCase):
    def runTest(self):
        widget = Widget()
        self.assertEqual(widget.getSize(), (40, 40))
        
# 而要在PyUnit测试框架中构造上述WidgetTestCase类的一个实例，应该不带任何参数调用其构造函数:
testCase = WidgetTestCase()
```

一个测试用例通常只对软件模块中的一个方法进行测试，采用覆盖`runTest()`方法来构造测试用例在PyUnit中称为静态方法，如果要对同一个软件模块中的多个方法进行测试，通常需要构造多个执行测试的类，如例5所示：

```python
# 例5. static_multi.py
import unittest
# 测试getSize()方法的测试用例
class WidgetSizeTestCase(unittest.TestCase):
    def runTest(self):
        widget = Widget()
        self.assertEqual(widget.getSize(), (40, 40))
# 测试resize()方法的测试用例
class WidgetResizeTestCase(unittest.TestCase):
    def runTest(self):
        widget = Widget()
        widget.resize(100, 100)
        self.assertEqual(widget.getSize(), (100, 100))
```

采用静态方法，Python程序员不得不为每个要测试的方法编写一个测试类（该类通过覆盖`runTest()`方法来执行测试），并在每一个测试类中生成一个待测试的对象。在为同一个软件模块编写测试用例时，很多时候待测对象有着相同的初始状态，因此采用上述方法的Python程序员不得不在每个测试类中为待测对象进行同样的初始化工作，而这往往是一项费时且枯燥的工作。

一种更好的解决办法是采用PyUnit提供的动态方法，只编写一个测试类来完成对整个软件模块的测试，这样对象的初始化工作可以在`setUp()`方法中完成，而资源的释放则可以在`tearDown()`方法中完成，如例6所示：

```python
# 例6. dynamic.py
import unittest
# 执行测试的类
class WidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget()
    def tearDown(self):
        self.widget.dispose()
        self.widget = None
    def testSize(self):
        self.assertEqual(self.widget.getSize(), (40, 40))
    def testResize(self):
        self.widget.resize(100, 100)
        self.assertEqual(self.widget.getSize(), (100, 100))
```

采用动态方法最大的好处是测试类的结构非常好，用于测试一个软件模块的所有代码都可以在同一个类中实现。动态方法不再覆盖`runTest()`方法，而是为测试类编写多个测试方法（按习惯这些方法通常以`test`开头），在创建TestCase子类的实例时必须给出测试方法的名称，来为PyUnit测试框架指明运行该测试用例时究竟应该调用测试类中的哪个方法：

```python
sizeTestCase = WidgetTestCase("testSize")
resizeTestCase = WidgetTestCase("testResize")
```

### 测试用例集TestSuite

完整的单元测试很少只执行一个测试用例，开发人员通常都需要编写多个测试用例才能对某一软件功能进行比较完整的测试，这些相关的测试用例称为一个测试用例集，在PyUnit中是用TestSuite类来表示的。

在创建了一些TestCase子类的实例作为测试用例之后，下一步要做的工作就是用TestSuit类来组织它们。PyUnit测试框架允许Python程序员在单元测试代码中定义一个名为`suite()`的全局函数，并将其作为整个单元测试的入口，PyUnit通过调用它来完成整个测试过程。

```python
def suite():
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase("testSize"))
    suite.addTest(WidgetTestCase("testResize"))
    return suite

# 也可以直接定义一个TestSuite的子类，并在其初始化方法（__init__）中完成所有测试用例的添加：
class WidgetTestSuite(unittest.TestSuite):
    def __init__(self):
        unittest.TestSuite.__init__(self, map(WidgetTestCase,
                                              ("testSize",
                                               "testResize")))
# 这样只需要在suite()方法中返回该类的一个实例就可以了：
def suite():
    return WidgetTestSuite()
        
# 如果用于测试的类中所有的测试方法都以test开始，
# Python程序员甚至可以用PyUnit模块提供的makeSuite()方法来构造一个TestSuite：
def suite():
    return unittest.makeSuite(WidgetTestCase, "test")        
        
    
        
        
        
```

在PyUnit测试框架中，TestSuite类可以看成是TestCase类的一个容器，用来对多个测试用例进行组织，这样多个测试用例可以自动在一次测试中全部完成。事实上，TestSuite除了可以包含TestCase外，也可以包含TestSuite，从而可以构成一个更加庞大的测试用例集：    

```python
suite1 = mysuite1.TheTestSuite()
suite2 = mysuite2.TheTestSuite()
alltests = unittest.TestSuite((suite1, suite2))
```



## 实施测试

编写测试用例（TestCase）并将它们组织成测试用例集（TestSuite）的最终目的只有一个：实施测试并获得最终结果。PyUnit使用TestRunner类作为测试用例的基本执行环境，来驱动整个单元测试过程。Python开发人员在进行单元测试时一般不直接使用TestRunner类，而是使用其子类TextTestRunner来完成测试，并将测试结果以文本方式显示出来：

```python
runner = unittest.TextTestRunner()
runner.run(suite)

# 例7. text_runner.py
from widget import Widget
import unittest
# 执行测试的类
class WidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget()
    def tearDown(self):
        self.widget.dispose()
        self.widget = None
    def testSize(self):
        self.assertEqual(self.widget.getSize(), (40, 40))
    def testResize(self):
        self.widget.resize(100, 100)        
        self.assertEqual(self.widget.getSize(), (100, 100))        
# 测试
if __name__ == "__main__":
    # 构造测试集
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase("testSize"))
    suite.addTest(WidgetTestCase("testResize"))
    
    # 执行测试
    runner = unittest.TextTestRunner()
    runner.run(suite)
```

默认情况下，TextTestRunner将结果输出到`sys.stderr`上，但如果在创建TextTestRunner类实例时将一个文件对象传递给了构造函数，则输出结果将被重定向到该文件中。在Python的交互环境中驱动单元测试时，使用TextTestRunner类是一个不错的选择。

PyUnit模块中定义了一个名为main的全局方法，使用它可以很方便地将一个单元测试模块变成可以直接运行的测试脚本，`main()`方法使用TestLoader类来搜索所有包含在该模块中的测试方法，并自动执行它们。如果Python程序员能够按照约定（以`test`开头）来命名所有的测试方法，那就只需要在测试模块的最后加入如下几行代码即可：

```python
if __name__ == "__main__":
    unittest.main()
    
# 例8. main_runner.py
from widget import Widget
import unittest
# 执行测试的类
class WidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget()
    def tearDown(self):
        self.widget.dispose()
        self.widget = None
    def testSize(self):
        self.assertEqual(self.widget.getSize(), (40, 40))
    def testResize(self):
        self.widget.resize(100, 100)
        self.assertEqual(self.widget.getSize(), (100, 100))   
# main()测试
if __name__ == "__main__":
    unittest.main()
```

要执行该单元测试，可以使用如下命令：

```shell
# 测试类WidgetTestCase中的所有测试方法都将被自动执行
$ python main_runner.py

# 只执行testSize()方法
$ python main_runner.py WidgetTestCase.testSize

# 如果在单元测试脚本中定义了TestSuite，还可以指定要运行的测试集。使用-h参数可以查看运行该脚本所有可能用到的参数：
$ python main_runner.py -h

# 为了使单元测试更具亲合力，PyUnit软件包中还提供了一个图形界面测试脚本unittestgui.py，
# 将其复制到当前目录后，可以执行下面的命令来启动该测试工具，对main_runner.py脚本中的所有测试用例进行测试：
$ python unittestgui.py main_runner
```

PyUnit对于没有通过的测试会进行区分，指明它是失败（`failure`）还是错误（`error`），失败是被`assert`类方法（如`assertEqual`）检查到的预期结果，而错误则是由意外情况所引起的。



## Pytest 

pytest 是 Python 的一种单元测试框架，与 Python 自带的 unittest 测试框架类似，但是比 unittest 框架使用起来更简洁，效率更高。根据 pytest 的官方网站介绍，它具有如下特点：

- 成熟全功能的Python测试工具

- - 支持POSIX / Windows， Python的2.5-3.6， PyPy和Jython - 2.5.1
  - 1000测试用例自测零bug。
  - pytest升级时有很好的向后兼容性
  - 丰富的在线和PDF文档
  - 大量的第三方插件和内置帮助
  - 在许多小型和大型项目和组织使用
  - 许多测试实例

- 灵活

- - 易学，有多种用法
  - assert语句断言
  - 追踪和失败断言报告
  - 打印调试和测试执行期间可以捕获标准输出

- 适合简单的单元测试到复杂的功能测试

- - 模块化和参数化的平台
  - 参数化的测试函数
  - 支持属性
  - Skip和xfail处理失败的用例
  - xdist插件分发测试给多个CPU
  - 不断地重新运行失败的测试
  - 灵活的Python测试发现

- 集成

- - 多范式：可以执行nose, unittest 和doctest风格的测试用例，甚至Django和trial。
  - 支持良好的集成实践
  - 支持扩展的xUnit风格setup
  - 支持非python测试
  - 支持生成测试覆盖率报告
  - 支持PEP8兼容的编码风格

- 扩展插件和定制系统：

- - 所有的收集，报告，运行方面都委派给hook函数
  - 定制可以是每个目录，每个项目或每个PyPI上发布的插件
  - 很容易添加命令行选项或定制现有的行为

安装与执行单元测试命令如下：

```shell
# 使用pip安装PyTest
$ pip install -U pytest
# 验证安装的版本
$ py.test --version

# 运行测试
$ cd /path/to/test/
$ py.test               # run all tests below current dir
$ py.test test_mod.py   # run tests in module
$ py.test somepath      # run all tests below somepath
$ py.test -k stringexpr  
# only run tests with names that match the the "string expression", e.g. 
# "MyClass and not method" will select TestMyClass.test_something
# but not TestMyClass.test_method_simple
$ py.test test_mod.py:
    :
        test_func  # only run tests that match the "node ID",
        # e.g "test_mod.py::test_func" will select
        # only test_func in test_mod.p
        
# 生成 HTML 格式报告：
$ py.test --resultlog=test.html
# 生成 XML 格式的报告：
$ py.test --junitxml=test.xml        
```

单元测试写法如下：

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

# 编写 pytest 测试样例需要按照下面的规则：
#     测试文件以 test_ 开头（以 _test 结尾也可以）
#     测试类以 Test 开头，并且不能带有 __init__ 方法
#     测试函数以 test_ 开头
#     断言使用基本的 assert 即可

def func(x):
    return x + 1
def test_func():
    assert func(3) == 5

class TestClass:

    def test_one(self):
        x = "this"
        assert 'h' in x

    def test_two(self):
        x = "hello"
        assert hasattr(x, 'check')
```

**使用和调用**

- python -m pytest调用：

- - python -m pytest [...] 效果和py.test [...] 一样

- 获取版本，选项名，环境变量

- - py.test --version 看版本
  - py.test --fixtures 查看内置参数
  - py.test -h | --help 命令行和配置文件帮助

- 失败后停止

- - 首次失败后停止执行：py.test -x
  - py.test --maxfail=2 两次失败之后停止执行

- 执行选择用例

- - py.test test_mod.py，执行模块中的用例
  - py.test somepath，执行路径中用例
  - py.test -k stringexpr，执行字符串表达式中的用例，比如"MyClass?and not method"，选择TestMyClass.test_something，排除了TestMyClass.test_method_simple。
  - py.test --pyargs pkg，导入pkg，使用其文件系统位置来查找和执行用例。执行pypkg目录下的所有用例。

- 调试输出：

- - py.test --showlocals 在traceback中显示本地变量
  - py.test --showlocals 在traceback中显示本地变量（快捷方式）
  - py.test --tb=long 默认的traceback信息格式化形式
  - py.test --tb=native 标准库格式化形式
  - py.test --tb=short 更短的格式
  - py.test --tb=line 每个错误一行

- 失败时调用PDB (Python Debugger)：

Python带有一个内置的Python调试器称为PDB。pytest可以在命令行选项指定调用：

py.test --pdb

这将每次失败时调用Python调试器。通常，您可能只希望这样做的第一个失败的测试，以 了解某些故障情况： py.test-X - PDB＃下降到PDB上的第一次失败，然后结束测试阶段 py.test - PDB - maxfail=3＃下降到PDB前三失败

# Python 常用包介绍

IPython：IPython 为 [NumPy](http://www.numpy.org/)、[SciPy](https://www.scipy.org/)、[Pandas](http://pandas.pydata.org/)、[Matplotlib](http://matplotlib.org/) 等包提供一个交互式接口，它本身并不提供科学计算的功能。这些工具组合在一起，形成了可以匹敌如 Matlab、Mathmatic 这些复杂工具的科学计算框架。



[NumPy](http://www.numpy.org/)：NumPy 主要提供基础的数组数据结构和矩阵运算。快速高效的多维数组对象可执行向量化计算提供线性代数等矩阵可集成 C 代码



[SciPy](https://www.scipy.org/)：基于 NumPy 提供了大量的科学计算算法（信号处理、最优化求解等等），解决标准问题。

- ①数值积分和微分方程求解

- ②扩展的矩阵计算功能

- ③最优化工具

- ④概率分布计算和统计函数

- ⑤信号处理函数

  ​

[Pandas](http://pandas.pydata.org/)：提供 data frames 数据结构，便于处理真实数据集。

- 易用、高效的数据操作函数库
- 执行 join 以及其他 SQL 类似的功能来重塑数据
- 提供包括 dataframe 在内的数据结构
- 支持各种格式（包括数据库）输入输出
- 支持时间序列



[Matplotlib](http://matplotlib.org/)擅长数据绘图，绘制交互式可视化图像。

- 提供一套和 matlab 相似的命令 API
- 十分适合交互式绘图
- 可以作为绘图控件嵌入 GUI



其他常用工具包

- [Seaborn](http://seaborn.pydata.org/)：统计绘图
- [StatsModels](http://statsmodels.sourceforge.net/)：统计模型
- [scikit-learn](http://scikit-learn.org/)：机器学习
  - 建立在 NumPy，SciPy 基础上
  - 通过统一接口来使用，可以迅速在数据集上实现流行的算法
  - 包含许多用于标准机器学习任务的工具，如：聚类、分类和回归等
- Requests：网页数据抓取
- Beautiful Soup：解析网页数据
- Flask：轻量级的 web 框架
- sqlite3：轻量级数据库接口
- Pyspark： Spark 的 Python 接口
- nltk：自然语言处理
- networkx：社交网络分析
- theano：深度学习

## IPython

IPython 为 [NumPy](http://www.numpy.org/)、[SciPy](https://www.scipy.org/)、[Pandas](http://pandas.pydata.org/)、[Matplotlib](http://matplotlib.org/) 等包提供一个交互式接口，它本身并不提供科学计算的功能。这些工具组合在一起，形成了可以匹敌如 Matlab、Mathmatic 这些复杂工具的科学计算框架。

[IPython](http://ipython.org/) (Interactive Python 的简写) 是一个强大的交互式 Python Shell，由 Fernando Perez 在 2001 发起。它的目标是提供 “Tools for the entire life cycle of research computing.” 如果说 Python 是数据科学操作的引擎，那么 IPython 就是交互式的控制面板。

IPython 的优点：

- 交互式和批处理功能
- 提高编写、测试速度，执行结果立即可见，方便调试
- 同时保存脚本和计算过程，可重复可互动
- 丰富的数据可视化工具
- 能在本地计算机上对远程服务器中的数据进行分析
- 兼容 markdown 语法，满足数据分析、课程教学、博客写作等需求

使用 IPython 有两种方式：

- 在命令行中使用

- 在 Jupyter Notebook 中使用

  Jupyter Notebook 是基于浏览器的 IPython shell 图形界面，非常适合用于开发、协同、分享甚至是发布数据科学研究成果。Notebook 以 JSON 格式保存整个交互式会话，可以兼容 Python 代码，文本标记语言如 Markdown，图片，视频，媒体内容等。 IPython Notebook 在 Python 社区中越来越普遍，特别是在科学研究与教育领域，很多课程/博客/书籍都是用 Notebook 写的。

参考资料

- [Python Data Science Handbook](http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/Index.ipynb)
- [IPython.org](http://ipython.org/)
- [学习IPython进行交互式编程和数据可视化](https://www.gitbook.com/book/itacey/learning_ipython)
- [使用IPython有哪些好处？ - 知乎](https://www.zhihu.com/question/51467397)
- [为什么要使用IPython？ - 简书](http://www.jianshu.com/p/61f8f7a68bbe)

## Numpy

Numpy（**Num**erical **Py**thon extensions）是一个第三方的Python包，用于科学计算。这个库的前身是1995年就开始开发的一个用于数组运算的库。经过了长时间的发展，基本上成了绝大部分Python科学计算的基础包，当然也包括所有提供Python接口的深度学习框架。它提供了高性能的多维数组对象，以及相关工具。

网址：[Obtaining NumPy & SciPy libraries](https://link.zhihu.com/?target=http%3A//www.scipy.org/scipylib/download.html)

Numpy（**Num**erical **Py**thon extensions）是一个第三方的Python包，是Python的一种开源的数值计算扩展，用于科学计算的核心库。可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix））。包括：

1. 一个强大的N维数组对象Array；
2. 比较成熟的（广播）函数库；
3. 用于整合C/C++和Fortran代码的工具包；
4. 实用的线性代数、傅里叶变换和随机数生成函数。

numpy和稀疏矩阵运算包scipy配合使用更加方便。提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。

### 数组

一个numpy数组是一个由不同数值组成的网格。网格中的数据都是同一种数据类型，可以通过非负整型数的元组来访问。维度的数量被称为数组的阶，数组的大小是一个由整型数构成的元组，可以描述数组不同维度上的大小。

## Python CoCo

[高并发IM系统架构优化实践>>>](http://click.aliyun.com/m/9002/)  ![img](https://my.oschina.net/img/hot3.png)

CoCo(Code Convert) 是一个简单的文件编码识别和转换的命令行工具，使用python编写，具有很好的跨平台特性。

### 项目地址

[https://github.com/buptmiao/CoCo](https://github.com/buptmiao/CoCo)

### 安装及使用

```shell
# 安装
$ pip install cocov
# 源码安装
$ git clone git@github.com:buptmiao/CoCo.git  
$ cd CoCo
$ python setup.py install

usage: CoCo [-h] [--version] [-i I [I ...]] [-o O] [src] [dst]

positional arguments:
  src            input file
  dst            output file

optional arguments:
  -h, --help     show this help message and exit
  --version, -v  show program's version number and exit
  -i I [I ...]   print the encoding of the input files
  -o O           specify the encoding of output file, utf-8 by default

# 识别文件编码
$ coco -i foo.csv
foo.csv utf-8
$ coco -i foo.csv bar.csv
foo.csv utf-8
bar.csv gb2312

# 转换文件编码
$ coco -i foo.csv
foo.csv utf-8
$ coco -o gb2312 foo.csv bar.csv
$ coco -i bar.csv
bar.csv gb2312
$ coco -o utf-8 bar.csv utf.csv
$ coco -i bar.csv utf.csv
bar.csv gb2312
utf.csv utf-8
```

## Hypergolix

[Hypergolix](https://github.com/Muterra/py_hypergolix) 是一个使用 Python 语言实现的可编程的云同步库。它类似于 Dropbox，但是你可以将其集成到应用程序中，而不是从文件系统中使用它。a作为一个后台服务在本地运行，最初目的是为了简化嵌入式、IoT、 Raspberry Pi应用程序及设备的开发。







