---
layout: post
title: Docker
lead: null
date: 2016-09-08T00:00:00.000Z
categories: Docker
tagline: Docker
tags:
  - Docker
  - 容器
  - Linux
---

# 介绍

初识Docker

[大白话Docker入门（一）](https://yq.aliyun.com/articles/63035)

[大白话Docker入门（二）](https://yq.aliyun.com/articles/63517)

Docker学习路线

[Docker学习路线图 (持续更新中)](https://yq.aliyun.com/articles/40494)

Docker基础学习

[Docker基础之一: Docker架构](https://yq.aliyun.com/articles/130)

[Docker基础之二: Linux快速入门](https://yq.aliyun.com/articles/131)

[Docker基础之三: 安装docker＋HelloWorld](https://yq.aliyun.com/articles/132)

[Docker基础之四: Docker入门](https://yq.aliyun.com/articles/133)

[Docker基础之五: 使用Docker容器](https://yq.aliyun.com/articles/134)

[Docker基础之六: Docker基础命令](https://yq.aliyun.com/articles/135)

[Docker基础之七: 镜像操作](https://yq.aliyun.com/articles/136)

[Docker基础之八: 容器的网络](https://yq.aliyun.com/articles/137)

[Docker基础之九: 管理容器的数据](https://yq.aliyun.com/articles/138)

[Docker基础之十: 存储镜像到Docker Hub](https://yq.aliyun.com/articles/139)

[Docker基础之十一: 镜像操作（Dockerfile）](https://yq.aliyun.com/articles/140)

关于Docker的优秀图书

[【好书试读】Docker全攻略](https://yq.aliyun.com/articles/63160)

[【好书试读】高性能Docker](https://yq.aliyun.com/articles/63161)

[《自己动手写Docker》书摘之一： Linux Namespace](https://yq.aliyun.com/articles/64928)

[《自己动手写Docker》书摘之二： Linux Cgroups](https://yq.aliyun.com/articles/64965)

[《自己动手写Docker》书摘之三： Linux UnionFS](https://yq.aliyun.com/articles/65034)

[《自己动手写Docker》书摘之四： 构造简单容器](https://yq.aliyun.com/articles/65118)

Docker的现在和未来

[2016中国容器技术调研报告全景解读](https://yq.aliyun.com/articles/64791)

[Docker技术趋势解读](https://yq.aliyun.com/articles/64282)

[阿里巴巴眼中的Docker](https://yq.aliyun.com/articles/62468)

Docker最佳实践

[Docker的Windows容器初体验](https://yq.aliyun.com/articles/62375)

[蚂蚁金服Docker网络技术实践](https://yq.aliyun.com/articles/62628)

[构建基因数据应用生态系统：Docker在基因数据的应用实践](https://yq.aliyun.com/articles/62630)

[Docker助力韵达大规模云上调度实践](https://yq.aliyun.com/articles/62580)

[阿里超大规模Docker化之路](https://yq.aliyun.com/articles/64890)

[学霸君基于Docker的微服务架构设计](https://yq.aliyun.com/articles/62631)

[在阿里云上进行Docker集群的自动弹性伸缩](https://yq.aliyun.com/articles/61826)

[一键部署自动感知服务的Docker集群](https://yq.aliyun.com/articles/61888)

关于阿里云容器服务

[阿里云容器服务官网](https://www.aliyun.com/product/containerservice)

[解析阿里云容器服务](https://yq.aliyun.com/articles/64315)

[阿里云容器镜像服务](https://dev.aliyun.com/)（截止发稿，共计11,062个镜像，2,618,490次发布）

[容器服务帮助文档](https://help.aliyun.com/product/25972.html)

[Docker常见故障排查指南](https://yq.aliyun.com/articles/59144)

使用阿里云容器服务的正确姿势

[使用阿里云容器服务Jenkins 2.0实现持续集成之Pipeline篇](https://yq.aliyun.com/articles/64970)

[使用阿里云容器服务Jenkins实现持续集成之GitLab篇](https://yq.aliyun.com/articles/61836)

[利用阿里云容器服务打通TensorFlow持续训练链路](https://yq.aliyun.com/articles/62429)

[利用阿里云容器轻松实现Serverless服务](https://yq.aliyun.com/articles/62715)

[利用Docker和阿里云容器服务轻松搭建TensorFlow Serving集群](https://yq.aliyun.com/articles/60894)

[利用Docker和容器服务轻松实现云原生应用 - 可用性篇](https://yq.aliyun.com/articles/62893)

[在阿里云容器服务中运行离线作业](https://yq.aliyun.com/articles/59066)

[在阿里云容器服务中使用定时任务](https://yq.aliyun.com/articles/62315)

## 容器技术

容器技术作为目前一项炙手可热的新技术，具有以下优势：

- 极其轻量级的虚拟化技术，大大提高IT资源的利用率；
- 标准化的打包、封装、搬运机制，有效提高开发运维效率，降低成本；
- 秒级启动速度，保障业务的稳定性与高可用性；
- 类似于积木的分层机制，提供灵活组合微服务；
- 简化开发版本管理。

容器技术与虚拟机技术对比图

|   特性   | 容器技术                          | 虚拟机技术           |
| :----: | :---------------------------- | --------------- |
| 占用磁盘空间 | 小，甚至几十KB（镜像层的情况）              | 非常大，上GB         |
|  启动速度  | 快，几秒钟                         | 慢，几分钟           |
|  运行形态  | 直接运行于宿主机的内核上，不同容器共享同一个Linux内核 | 运行于HyperVisior上 |
|  并发性   | 一台宿主机可以启动成千上百个容器              | 最多几十个虚拟机        |
|   性能   | 接近宿主机本地进程                     | 逊于宿主机           |
| 资源利用率  | 高                             | 低               |

## Docker的特性：

Docker是一个开源的应用容器引擎，提供了一种在安全、可重复的环境中自动部署软件的方式，允许开发者将他们的应用和依赖包打包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器完全使用沙箱机制，相互之间不会有任何接口。几乎没有性能开销，可以很容易地在机器和数据中心中运行。重要的是，它不依赖于任何语言、框架或包装系统。

正如Docker的logo一样，Docker的思想就是源于集装箱，集装箱解决了各种型号、规格的货物在各种运输工具上进行运输的问题，而集装箱和集装箱之间不会互相影响。在软件世界中，Docker就是这样的集装箱，它很好地解决了每件货物包装的问题（应用程序配套的环境），以及货物叠放的问题（应用程序依赖环境互相独立）。

- **文件系统隔离**：每个进程容器运行在一个完全独立的根文件系统里。
- **资源隔离**：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。
- **网络隔离**：每个进程容器运行在自己的网络空间，虚拟接口和IP地址。
- **日志记录**：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。
- **变更管理**：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。
- **交互式shell**：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上。

## Docker应用场景

- **加速本地开发**：快速搭建好开发环境和运行环境。
- 自动打包和部署应用。
- 创建轻量级的私有PaaS环境。
- 自动化测试和持续集成。
- 创建安全沙盒。

## 微服务

**微服务架构是一种特定的软件应用程序设计方式**——==将大型软件拆分为多个独立可部署服务组合而成的套件方案==。虽然这种架构风格的确切定义还未统一，但并不妨碍其在众多企业的实际应用中被实践，并体现出了具备通用特征的业务功能、自动化部署、端点智能化以及对语言与数据的离散化控制能力。

许多如Amazon、eBay、NetFlix等公司都采用微服务结构模式，都在尝试改进那些需要频繁更新的，通过网络提供到用户的PC、平板和智能手机上的应用程序和服务的持续交付，将应用分解为小的、互相连接的微服务，而不是开发一个巨大的单体式的应用。

**一个微服务一般完成某个特定的功能**，比如下单管理、客户管理等等，都有自己的业务逻辑和适配器。一些微服务还会发布API给其它微服务和应用客户端使用。其它微服务完成一个Web UI，运行时每一个实例可能是一个云VM或者是Docker容器。这种微服务架构模式深刻影响了应用和数据库之间的关系，==不像传统多个服务共享一个数据库，微服务架构每个服务都可能有自己的数据库==。

Docker作为一种开源的应用容器引擎，帮助开发者将他们的应用以及依赖打包到一个可移植的容器中，便于应用的部署和扩展。而随之产生的==微容器概念和微服务正好相辅相成==，通过Docker封装的应用可以轻松运行在以扩容能力见长的云计算平台上。

围绕着云托管环境的如此多的应用程序和服务部署活动，==微服务架构已经深度依赖于容器化技术的使用==。容器将微服务进程和应用程序隔离到更小的实例里，这些实例仅仅使用虚拟化了的操作系统，而不是整个虚拟机以及VM所包含的整个抽象硬件资源。

==微服务不是Docker，但Docker天然是为实现微服务而存在==，**利用Docker技术可以很方便的对宿主机资源进行隔离、划分，同时因Docker本身极其轻量化的特点，可以做到宿主机的高密度、高可用性、高弹性的应用，从而做到IT资源利用价值的最大化**。

实际上，docker的最佳实践就是每个进程（实际上是指每个运行的应用程序，但一个应用程序本身可能会开好几个工作进程，比如webserver）开一个 容器。 所以在这点上，它与virtualenv还不太一样，对于venv来说，如果两个应用的依赖一样，也完全可以跑在一个venv里，但是docker并不是 这样。

比如nginx开一个容器，[**MySQL**](http://lib.csdn.net/base/mysql)开一个容器，[**Redis**](http://lib.csdn.net/base/redis)开一个容器，每个应用开一个容器。然后把它们互联起来。对host机来说，它的环境是干净的，只是跑着几个docker容器。对于每个容器来说，其中的程序所用的环境也是干净的，只有它们用到的依赖，保证不会有不必要的冲突。每个容器做的事情也是清楚的：对外提供某个服务，或者依赖某个外部服务。所有的服务都是通过docker的虚拟网络建立连接。

其实这种就是所谓的“微服务”[**架构**](http://lib.csdn.net/base/architecture)，每个[**Container**](http://lib.csdn.net/base/docker)就是一个微服务。

## 容器是现代软件供应链中的基础单元。

2016年以“现代化软件供应链变迁”为题的调查结果显示：处于纽带中心的Docker平台是其中一支重要的驱动力量。现代软件开发的策略主要表现有三个方面：**向（混合）云方向的转移**，**向微服务架构的过渡**，**通过DevOps方式进行软件开发模式的实践**。

Docker能满足现代软件供应链中**灵活性**、**可控性**、**可移植性**等这些必需的要求。

Docker通过可量化的方式提高DevOps的实践，以此来改进应用程序的交付过程。

Docker作为混合云策略的中心，满足用户在本地、私有云和公有云等多环境之间==自由切换==。

Docker也支持微服务架构的交付和现代传统整体化应用程序。

在容器管理的供应商中Docker提供了良好的可移植性。

至于编排和管理工具生态系统，被调查者以压倒性的优势都在使用**Docker Swarm**、**Google Kubernetes**和**Amazon EC2**容器服务。除了前三名以外，还存在其他的一些未知的编排工具。

---

# 容器运行在哪里？裸机服务器OR虚拟机？

您知道为什么应该使用容器。但是您知道部署容器得用哪种基础设施吗？ 作为托管Docker和其他容器环境的平台，裸机服务器是否比虚拟机更好？ 

答案当然取决于很多因素，本文将通过列举裸机服务器和虚拟机上运行容器的优缺点来讨论。我将专注于Docker，但这里分享的经验通常适用于任何类型的容器平台。

## 裸机VS虚拟机

权衡裸机服务器和虚拟化主机环境各自的优缺点不是一个新课题，CTO们在21世纪初就开始思考了，当时虚拟化刚开始在数据中心推广，Docker则还没出现。 

简而言之，裸机服务器的主要优点包括： 

- **更高的性能**，因为没有系统资源浪费在硬件模拟上； 
- **充分利用所有机器资源**，高需求期间无闲置； 
- **更简单的管理**，因为主机、网络和磁盘等硬件基础架构更少。 

虚拟机则具有以下优点： 

- 通过在服务器之间传输虚拟机映像，**轻松实现在主机间移动应用程序**； 
- **不同虚拟机中运行的应用程序实现隔离**，不仅有助于安全，也能降低管理复杂度。 
- 通过在同一类型虚拟机上部署所有应用程序，即使底层服务器是异构的，也能**实现软件环境的跨平台一致性**。 

但是虚拟机也有一些缺点，包括： 

- **服务器资源可能未完全使用**。例如，如果您在服务器主机上分配存储空间以创建虚拟机磁盘映像，即使磁盘连接的虚拟机不使用全部空间，该存储空间也不可用于其他用途。 
- **虚拟机无法直接访问物理硬件**。如果您希望虚拟机能够将计算操作转移到主机的GPU上，您很难或无法实现，因为虚拟机是从底层主机环境中抽象出来的。 
- **物理服务器直接访问硬件，虚拟服务器访问软件模拟的硬件**。 

现代虚拟化平台提供了一些技巧，可以帮助管理员解决上述限制。例如，您可以创建动态磁盘映像，该映像随着虚拟机的使用情况的增加而扩展，以避免虚拟机实际使用之前锁定主机上的存储空间。在某些情况下，您还可以利用直通功能为虚拟机提供直接访问主机物理硬件的功能。 

然而，这些功能不是总能生效，例如他们不支持所有的主机或操作系统，他们还会产生额外的管理负担。如果您要运行的应用程序需要裸机访问，最好在裸机服务器上运行这些应用程序。 

或者，您可以在裸机服务器上的容器中运行应用程序，以便充分利用这两个方面。 

## 化圆为方：在裸机上运行容器

裸机上的容器提供虚拟机的许多优点，但没有虚拟化的缺点。当您在裸机服务器上运行容器时，容器允许您： 

- **在应用程序中访问裸机硬件，而不依赖直通技术**，因为（容器中的）应用程序运行在驱动底层硬件的同一个操作系统上。
- **有效利用系统资源**。尽管您也可以设置计算、存储和网络资源的容器使用量，通常这些资源不会被单个容器独占。因此，主机可以按需分配系统资源。 
- **为您的应用程序提供裸机性能**，因为没有硬件模拟层将它们与主机服务器分离。 
- 此外，通过使用裸机容器主机，您**仍然可以获得一般只用虚拟机才可能实现的优点**： 
  - **在便携式环境中部署应用程序的能力**，可在主机服务器之间轻松移动。 
  - **应用程序隔离**。虽然容器可能没法提供与虚拟机相同的隔离级别，但是容器允许管理员阻止应用程序彼此交互，并对与每个容器关联的权限和资源访问性设置严格的限制。 

简而言之，在裸机上运行容器能让您化圆为方。您不仅得到裸机性能和直接访问硬件的所有好处，还能得到虚拟机的可移植性和隔离功能。 

## 您为什么不应该总是将容器托管在裸机上

您可能想知道为什么还有不在裸机上运行容器的情况，一举两得的事情为什么不做？ 

使用裸机服务器托管容器的缺点如下： 

- **升级物理服务器很困难**。如果要将裸机服务器替换为较新的服务器，则必须在新服务器上从头开始创建容器环境。但是，如果容器环境是虚拟机映像的一部分，则可以将映像从旧服务器移动到新服务器。 
- **大多数云需要使用虚拟机**。的确有一些裸机型云主机，例如Rackspace的OnMetal和Oracle的Bare Metal Cloud Service，然而，大多数公有云提供商只提供虚拟机。如果要使用其平台来运行容器，则必须使用虚拟机。 
- **不是所有硬件或软件配置都支持容器**。现在您可以使用虚拟机平台（如VMware或基于内核的虚拟机）托管几乎任何类型的操作系统，也可以在几乎任何类型的服务器上运行该虚拟化平台。但Docker则有限得多。如果直接托管到裸机，Docker只能在Linux和特定版本Windows Server上运行。这意味着如果您既要在裸机服务器运行Windows Server 2012（Docker当前不支持的版本）还想要托管Docker，您只能先在Windows主机上安装一个虚拟机再容纳Docker。 
- **您不能在Windows主机上运行Linux容器，反之亦然**。同样的，Linux容器只能在Linux主机上运行，反之亦然。所以，如果您有一个裸机Windows Server，但您想运行一个Docker容器来托管为Linux编译的应用程序，您将不得不在Windows服务器上安装一个Linux虚拟机，并将其作为托管Docker的基础。 
- **裸机服务器不提供回滚功能**。大多数现代虚拟化平台提供的一个超酷的功能，是能够拍摄虚拟机快照，且以后需要时能回滚到该快照。裸机服务器做不到这一点（当然，技术上可以使用操作系统或文件系统本身的回滚功能，但这些做不到虚拟机镜像回滚那么无缝）。基于容器的快照和回滚则没有意义，因为容器生来就是短暂且没有什么可以回滚的。因此，利用简单系统回滚的唯一方法是将容器跑在虚拟机上。 

## 结论

在裸机服务器上还是在虚拟机上运行容器是一个艰难的决定。您必须权衡各种利弊，以确定哪种方案最适合您的公司。 

好消息是，无论您在何处托管容器，您都可以受益于容器化的所有核心功能，包括简单的应用程序可移植性，可扩展性和敏捷性。



---

# Docker入门 

## Docker是什么?

Docker 是一个开源的平台，设计目标是可以方便开发，方便部署和方便执行应用。使用docker可以快速分发开发好的应用。借助于Docker，你可以将开发平台和应用分离开，并且像管理应用一样管理开发平台。Docker可以帮助你快速开发应用，快速测试应用，快速部署应用，并且缩短开发代码和执行代码之间的周期间隔。

Docker 是凭借一个轻量级容器的虚拟化平台工作流和相关工具来达到上述功能的，并且使用这个轻量化容器来帮助你管理和部署应用。

Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。

Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。

Docker相较于传统的虚拟化方式有众多优势：

- 更高效的利用系统资源；
- 更快速的启动时间；
- 一致的运行环境；
- 持续交付和部署；
- 执行环境一致性，更轻松的迁移；
- 分层存储及镜像技术，使维护和扩展更轻松。

## Docker platform

在Docker核心层，它提供了一种方式来让各种应用运行在各个隔离的容器中。这种方式允许docker同一时间在同一台主机上面运行若干个容器。这种轻量级的容器运行方式，几乎没有额外的运行开销。这意味着你可以充分使用主机的硬件能力。

使用Docker提供的工具和虚拟化平台，你可以完成以下事情：

- 将你的应用或者组件部署到容器中
- 将你的容器分发给你的团队进行下一步的开发或者测试
- 将你开发的应用部署到发布环境中，无论这些环境是本地模式或者云模式

## 快速分发应用

Docker可以帮助你把控开发各个周期。Docker允许你在本地的开发环境中进行代码开发，然后将开发好的应用整合到团队的开发流程中。

### 方便部署和易于管理

Docker基于容器的机制可以很容易进行部署。Docker容器可以在本地主机上面执行，也可以在虚拟机中执行，不论这些虚拟机是在本地或者云中。

Docker快速部署和轻量级的特性也使得管理负载变得很容易。你可以快速启动或者销毁容器。这种时间几乎是实时的。

### 可以执行大量的工作负载

因为Docker具有便于部署和快速启停的方式，同时docker也提供了可行的，符合效益-成本的虚拟机管理机制。使得docker很适合负载要求高的环境。比如:将你的云平台作为PAAS用途时，或者你要求你的环境具有高资源使用率时。

## Docker架构

Docker Engine 采用CS架构。Docker client同Docker daemon通讯，Docker daemon负责维护docker 容器的构建，运行和分发。Client和Daemon可以再同一台主机上面执行，也可以分开执行。本地的client可以连接远程的daemon。Client可以通过socker或者REST API同daemon通讯。

![](https://oss-cn-hangzhou.aliyuncs.com/yqfiles/574478332a680c4ea8c3cf1a57fee4f5f6c217aa.jpeg)

- **Docker Client** : Docker提供给用户的客户端。Docker Client提供给用户一个终端，用户输入Docker提供的命令来管理本地或者远程的服务器。
- **Docker Daemon** : Docker服务的守护进程。每台服务器（物理机或虚机）上只要安装了Docker的环境，基本上就跑了一个后台程序Docker Daemon，Docker Daemon会接收Docker Client发过来的指令,并对服务器的进行具体操作。
- **Docker Images** : Docker image是一个只读类型的模板。比如一个镜像可以是一个包含apache和你的web应用的ubuntu操作系统。我们经常使用镜像来创建容器。Docker提供了一种快捷的方式来构建新镜像或者更新镜像，同时你也可以下载其他人已经创建好的镜像。Docker image是Docker结构中的构建组件。
- **Docker Registry** : Docker registries用来保存镜像。它分为公开仓库和私有仓库，你可以从仓库中上传或者下载镜像。公开的Docker 仓库称之为"Docker Hub".它提供了你可以使用的非常多的镜像。你可以自由的创建镜像或者使用这里面其他人已经创建好的镜像。Docker registries属于Docker中的分发组件。Docker也提供了官方的Registry，叫做Dock Hub([http://hub.Docker.com](http://hub.docker.com/))。Docker Hub是一个分享和管理你所创建的image的SaaS平台。一个Software-as-a-Service平台，用来共享和管理docker容器。
- **Docker Container** : Docker containers同目录有几分相似。Docker containers保存了执行应用所需的所有资源。每一个Docker containers都是由image创建的。Docker containers可以run, started, stopped, moved, and deleted。需要注意的是，Docker containers之间是隔离的。Docker containers属于Docker中的执行组件。俗称Docker的容器，这个是最关键的东西了。Docker Container是真正跑项目程序、消耗机器资源、提供服务的地方，Docker Container通过Docker Images启动，在Docker Images的基础上运行你需要的代码。 **你可以认为Docker Container提供了系统硬件环境，然后使用了Docker Images这些制作好的系统盘，再加上你的项目代码，跑起来就可以提供服务了。** 听到这里，可能你会觉得是不是有点像一个VM利用保存的备份或者快照跑起来环境一样，其实是挺像的，但是实际上是有本质的区别，后面我会细说。

![](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/5d04473994d0b4730f9d03f63f617058.png)



Docker 是一款专门针对程序开发员和系统管理员进行应用开发，应用部署和应用执行的虚拟化平台.Docker 可以让你像使用集装箱一样快速的组合成应用，并且可以像运输标准集装箱一样，尽可能的屏蔽代码层面的差异。

Docker会尽可能的缩短从代码测试到产品部署之间的时间周期。

我们经常希望我们的应用环境可以发挥更高的效率。现在所有的应用都可以放到Docker容器(containers)中。借助于Docker容器，程序开发员，系统管理员甚至QA和版本控制工程师都可以进行协同工作。Docker创建了一套标准的containers数据格式，在这套标准数据格式基础上，当系统管理员管理操作容器时，程序开发员不需要关心容器的变化，这样就可以更专心的关注自己的应用代码。而这种管理和开发的任务隔离，大大的简化了开发和部署的成本。

**Docker容器的创建非常容易**，这样应用程序就可以进行快速迭代开发，从而缩短产品的上市周期。同时因为容器的快速创建特性，你所在团队中的成员可以了解应用每个版本的区别，借以熟悉应用如何工作以及应用如何构建。

**Docker的容器属于轻量级的容器**，因此启动和停止都特别快(fast!).容器启动只需要毫秒级的时间，因此在进行开发、测试和部署各个环境之间切换时几乎感受不到时间的流失。

**Docker容器几乎可以在任何地方执行**，至少在理论层面是可以再任意地方执行。Dokcer可以在桌面操作系统，物理服务器，虚拟机，数据中心或者共有/私有云上面执行。

因为Docker容器可以在各种环境下运行，因此容器之间的迁移也非常方便。你可以非常方便的将容器从测试环境迁移到云环境中。

正如上述，Docker容器属于轻量级的容器，所以它的资源消耗也很低。你可以同时启动多个容器，也可以当容器不再需要工作时，瞬间停止它。

**Docker的容器本身不需要额外创建虚拟机管理系统**，因此你可以启动多套Docker容器，这样就可以充分发挥主机服务器的物理资源，也可以降低因为采购服务器licenses而带来的额外成本。

因为Docker上述轻便，快速的特性。**可以使您的应用达到快速迭代的目的**。每次小的变更，马上就可以看到效果。而不用将若干个小变更积攒到一定程度再变更。每次变更一小部分其实是一种非常安全的方式。

## Docker如何工作？

我们先思考一下，一台服务器给我们开发的项目到底提供了哪些能力让他运行起来呢？cpu、内存、硬盘、网络、操作系统、工具软件还有项目的运行环境（jre等）。当具备了这些能力的机器，我们会说这台机器给项目提供了可以运行的环境。

我们知道VM技术可以将一台物理机器部署为多台虚拟机器，解决了很多物力资源的浪费以及方便的管理能力。那么VM是怎么做到的呢？关键词：Hypervisor，VM在物理机器的操作系统上建立了一个中间软件层Hypervisor，Hypervisor利用物理机器的资源，虚拟出多个新虚拟的硬件环境，这些硬件环境可以共享宿主机的资源。这些新的虚拟的硬件环境，安装操作系统和相应的软件后便形成了一台台的虚拟机器。

那么Docker有什么不同呢？Docker很聪明的利用linux的一些技术走了一条捷径：Docker选择了和虚拟化完全不同的思路，并不去虚拟化任何硬件，而是对硬件资源在不同的docker container之间做了 **“隔离”** 。隔离使每个docker container之间拥有了不同的环境（硬盘空间、网络、系统的工具包），并且又可以共享需要的硬件资源（cpu、内存、系统内核），达到了和虚拟机能提供的同样的功能。

![](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ba6d92b3ee037c9ed576f47ae5edf091.jpg)

Docker使用的Linux核心的组件如下：(截取自[Docker的元件– Linux核心部分](https://joshhu.gitbooks.io/docker_theory_install/content/DockerBible/docker_linux.html?spm=5176.100239.blogcont63517.12.ntKGpX))

- AUFS(chroot) – 用来建立不同的操作系统和隔离运行时的硬盘空间
- Namespace – 用来隔离Container的执行空间
- Cgroup – 分配不同的硬件资源
- SELinux – 用来保护linux的网络安全
- Netlink – 用来让不同的Container之间的进程保持通信
- Netfilter – 建立Container为基础的网络防火墙封装过滤
- AppArmor – 保护Container的网络及执行安全
- Linux Bridge – 让不同Container或不同主机上的Container进行沟通

### Docker Image 工作方式

Docker Image 是只读的模板，并随容器一起启动。每个Image包含了多个层。Docker Image使用的是Union File System来将这些层组合成一个Image。Union File System可以将文件和目录（通常称作Branch）进行透明的层叠组装，然后形成一个单独的文件系统。

Docker为什么轻量，就是因为使用了这些层状的文件系统。当用户修改一个Docker Image的时候（比如更新应用程序）一个新的层就会被建立。因此，这是一种增量式的修改，而不是新建一个全新的Image，这也是区别于传统虚拟机的一点。当你发布一个新的Image时，你只需要发布差异的部分，因此速度就非常快。

每个Image都来自于一个最基础的Image，如：ubuntu是一个基础Image，fedora是一个基础image。你也可以使用自己的Image作为基础Image，比如你可以创建包含了一个Apache 服务器的Image，作为所有web应用的基础Image。

注意：Docker通常从Docker Hub获取基础镜像。

Docker的Image都是从这些基础镜像衍生而来的，在编译Image是由一系列指令组成的，每个指令在我们的Image上创建一个新的曾。指令包括：

- 执行一条命令
- 添加文件或文件夹
- 创建环境变量
- 容器启动时，运行什么程序

这些命令可以再Dockerfile中定义。当你需要新建一个image是，docker可以自动读取Dockerfile中的命令，并且执行这些命令。最终生成一个新的image。

### Docker Registry 工作方式

Docker Registry是Image的仓库，当你编译完成一个Image时，你可以推送到公共的Registry，比如Docker Hub，也可以推送到你自己的私有Registry。 使用Docker Client，你可以搜索已经发布的Image，并从中拉取Image到本地，并在容器中运行。

Docker Hub提供了公有和私有的Registry。所有人都可以搜索和下载公共镜像。私有仓库只有私有用户能够查询和下载。

### 容器工作方式

一个容器由操作系统，用户文件和元数据构成。如我们所见，每个容器都根据镜像来生成。这个镜像告诉Docker 容器包含什么内容，运行什么程序，以及其他配置信息。Docker Image是只读的，当一个容器运行一个Image的时候，容器会在union FS的顶层增加文件层。

假如我们运行下面一条指令：

```shell
$ docker run -i -t ubuntu /bin/bash
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
Digest: sha256:f91f9bab1fe6d0db0bfecc751d127a29d36e85483b1c68e69a246cf1df9b4251
Status: Downloaded newer image for ubuntu:latest
```

我们来做一下拆解，Docker Client通过run命令告诉Daemon启动一个新的容器。这个指令至少需要包括：

- 需要运行什么Image，这里我们使用的是Ubuntu基础镜像
- 需要在容器启动时，运行什么命令，这里我们使用的是/bin/bash 是否需要进入应用程序，这里我们指定的是-i -t，就是进入容器交互模式

那么具体到内部的流程是怎么样的呢？

- 拉取ubuntu镜像：Docker检查本地是否有ubuntu镜像，如果不存在就自动从Docker Hub拉取。如果存在就进入下一步
- 创建一个容器：一旦本地存在ubuntu 镜像，Docker将通过它来创建容器
- 分配文件系统并mount 一个RW层：容器是创建在文件系统中的，并且在其之上增加了一层读写层。由此可以看出容器，并不会改变原始的镜像。
- 分配网络/桥接模式：创建一个桥接网络接口，使容器可以和本地主机进行通信。
- 设置一个IP地址：根据本地网络情况，选取一个可用的IP挂载到容器之上
- 启动一个进程：这里就是/bin/bash
- 抓取应用程序的输出：将程序的stdin, stdout和stderr，进行捕捉，这样我们可以看到程序的运行情况。 至此，你就拥有了一个运行的容器。通过容器，你可以运行程序，并且进行交互，当程序执行完毕，你可以停止和删除程序。

### 底层的技术

Docker是用Go编写的，同时使用了多种内核的功能来实现我们现在所看到的功能。

#### Namespaces

Docker 使用了Namespace这项技术来隔离工作区，也就是我们所说的容器。当容器运行时，Docker创建了一系列的Namespace。 通过Namespaces，容器运行在它自己的独立命名空间之中，而外层没有访问权限。目前，Docker使用了以下Namespace:

- pid namespace: 用于进程的隔离(PID: Process ID)
- net namespace: 用于管理网络接口(NET: Networking)
- ipc namespace: 用于管理进程间通讯(IPC: Inter Process Communication)
- mnt namespace: 用于管理Mount点(MNT: Mount)
- uts namespace: 用于隔离内核和版本信息(UTS: Unix Timesharing System 分时复用系统)

Linux Namespace 是kernel 的一个功能，它可以隔离一系列系统的资源，比如PID(Process ID)，User ID, Network等等。一般看到这里，很多人会想到一个命令`chroot`，就像`chroot`允许把当前目录变成根目录一样(被隔离开来的)，Namesapce也可以在一些资源上，将进程隔离起来，这些资源包括进程树，网络接口，挂载点等等。

比如一家公司向外界出售自己的计算资源。公司有一台性能还不错的服务器，每个用户买到一个tomcat实例用来运行它们自己的应用。有些调皮的客户可能不小心进入了别人的tomcat实例，修改或者关闭了其中的某些资源，这样就会导致各个客户之间互相干扰。也许你会说，我们可以限制不同用户的权限，让用户只能访问自己名下的tomcat，但是有些操作可能需要系统级别的权限，比如root。我们不可能给每个用户都授予root权限，也不可能给每个用户都提供一台全新的物理主机让他们互相隔离，因此这里Linux Namespace就派上了用场。使用Namespace， 我们就可以做到UID级别的隔离，也就是说，我们可以以UID为n的用户，虚拟化出来一个namespace，在这个namespace里面，用户是具有root权限的。但是在真实的物理机器上，他还是那个UID为n的用户，这样就解决了用户之间隔离的问题。当然这个只是Namespace其中一个简单的功能。

![](https://yqfile.alicdn.com/af2c3b0be596297763c88025e1c5d8f130e35aff.png)

除了User Namespace ,PID也是可以被虚拟的。命名空间建立系统的不同视图， 对于每一个命名空间，从用户看起来，应该像一台单独的Linux计算机一样，有自己的init进程(PID为1)，其他进程的PID依次递增，A和B空间都有PID为1的init进程，子容器的进程映射到父容器的进程上，父容器可以知道每一个子容器的运行状态，而子容器与子容器之间是隔离的。从图中我们可以看到，进程3在父命名空间里面PID 为3，但是在子命名空间内，他就是1.也就是说用户从子命名空间 A 内看进程3就像 init 进程一样，以为这个进程是自己的初始化进程，但是从整个 host 来看，他其实只是3号进程虚拟化出来的一个空间而已。

当前Linux一共实现六种不同类型的namespace。

| **Namespace类型**    | **系统调用参数**    | **内核版本** |
| ------------------ | ------------- | -------- |
| Mount namespaces   | CLONE_NEWNS   | 2.4.19   |
| UTS namespaces     | CLONE_NEWUTS  | 2.6.19   |
| IPC namespaces     | CLONE_NEWIPC  | 2.6.19   |
| PID namespaces     | CLONE_NEWPID  | 2.6.24   |
| Network namespaces | CLONE_NEWNET  | 2.6.29   |
| User namespaces    | CLONE_NEWUSER | 3.8      |

Namesapce 的API主要使用三个系统调用

- `clone() `- 创建新进程。根据系统调用参数来判断哪种类型的namespace被创建，而且它们的子进程也会被包含到namespace中
- `unshare()` - 将进程移出某个namespace
- `setns()` - 将进程加入到namespace中

#### Control Groups

Docker也使用了cgroups这项内核技术，通过cgroups可以限制应用程序使用的资源，这项技术可以使用户主机更好的运行多个容器而相互间不受影响。Cgroups可以限定容器使用的硬件资源，比如内存数量，CPU数量等。

Linux Cgroups(Control Groups) 提供了对一组进程及将来的子进程的资源的限制，控制和统计的能力，这些资源包括CPU，内存，存储，网络等。通过Cgroups，可以方便的限制某个进程的资源占用，并且可以实时的监控进程的监控和统计信息。 

Cgroups中的三个组件：

- cgroup

  cgroup 是对进程分组管理的一种机制，一个cgroup包含一组进程，并可以在这个cgroup上增加Linux subsystem的各种参数的配置，将一组进程和一组subsystem的系统参数关联起来。

- subsystem
  subsystem 是一组资源控制的模块，一般包含有：

  - blkio 设置对块设备（比如硬盘）的输入输出的访问控制

  - cpu 设置cgroup中的进程的CPU被调度的策略

  - cpuacct 可以统计cgroup中的进程的CPU占用

  - cpuset 在多核机器上设置cgroup中的进程可以使用的CPU和内存（此处内存仅使用于NUMA架构）

  - devices 控制cgroup中进程对设备的访问

  - freezer 用于挂起(suspends)和恢复(resumes) cgroup中的进程

  - memory 用于控制cgroup中进程的内存占用

  - net_cls 用于将cgroup中进程产生的网络包分类(classify)，以便Linux的tc(traffic controller) 可以根据分类(classid)区分出来自某个cgroup的包并做限流或监控。

  - net_prio 设置cgroup中进程产生的网络流量的优先级

  - ns 这个subsystem比较特殊，它的作用是cgroup中进程在新的namespace fork新进程(NEWNS)时，创建出一个新的cgroup，这个cgroup包含新的namespace中进程。

  每个subsystem会关联到定义了相应限制的cgroup上，并对这个cgroup中的进程做相应的限制和控制，这些subsystem是逐步合并到内核中的，如何看到当前的内核支持哪些subsystem呢？可以安装cgroup的命令行工具(apt-get install cgroup-bin)，然后通过lssubsys看到kernel支持的subsystem。 


    # / lssubsys -a
    cpuset
    cpu,cpuacct
    blkio
    memory
    devices
    freezer
    net_cls,net_prio
    perf_event
    hugetlb
    pids

- hierarchy
  hierarchy 的功能是把一组cgroup串成一个树状的结构，一个这样的树便是一个hierarchy，通过这种树状的结构，Cgroups可以做到继承。比如我的系统对一组定时的任务进程通过cgroup1限制了CPU的使用率，然后其中有一个定时dump日志的进程还需要限制磁盘IO，为了避免限制了影响到其他进程，就可以创建cgroup2继承于cgroup1并限制磁盘的IO，这样cgroup2便继承了cgroup1中的CPU的限制，并且又增加了磁盘IO的限制而不影响到cgroup1中的其他进程。

三个组件相互的关系：

通过上面的组件的描述我们就不难看出，Cgroups的是靠这三个组件的相互协作实现的，那么这三个组件是什么关系呢？ 

- 系统在创建新的hierarchy之后，系统中所有的进程都会加入到这个hierarchy的根cgroup节点中，这个cgroup根节点是hierarchy默认创建，后面在这个hierarchy中创建cgroup都是这个根cgroup节点的子节点。
- 一个subsystem只能附加到一个hierarchy上面
- 一个hierarchy可以附加多个subsystem
- 一个进程可以作为多个cgroup的成员，但是这些cgroup必须是在不同的hierarchy中
- 一个进程fork出子进程的时候，子进程是和父进程在同一个cgroup中的，也可以根据需要将其移动到其他的cgroup中。

#### Union File System

UnionFS用来对文件系统进行分层，通过分层可以使镜像更加轻量级和快速。Docker可以使用多种不同的UnionFS，比如AUFS, btrfs, vfs, DeviceMapper等。

UnionFS是一种为Linux，FreeBSD和NetBSD操作系统设计的把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录“透明地”覆盖，形成一个单一一致的文件系统。这些branches或者是read-only或者是read-write的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件，这是因为unionfs用到了一个重要的资管管理技术叫写时复制。

写时复制（copy-on-write，下文简称CoW），也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时候并不需要立即创建一个新的资源；这个资源可以被新旧实例共享。创建新资源发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著地减少未修改资源复制带来的消耗，但是也会在进行资源修改的时候增减小部分的开销。

用一个经典的例子来解释一下，Knoppix，一个用于Linux演示、光盘教学和商业产品演示的Linux发行版，就是把一个CD-ROM或者DVD和一个存在在可读写设备（eg，U盘）上的叫knoppix.img的文件系统联合起来。这样任何对CD/DVD上文件的改动都会在被应用在U盘上，不改变原来的CD/DVD上的内容。

##### AUFS

AUFS，英文全称是Advanced multi-layered unification filesystem, 曾经也叫 Acronym multi-layered unification filesystem，Another multi-layered unification filesystem。AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS的一些实现已经被纳入UnionFS 2.x版本。

##### Docker是如何使用AUFS的

AUFS是Docker选用的第一种存储驱动。AUFS具有快速启动容器，高效利用存储和内存的优点，直到现在AUFS仍然是Docker支持的一种存储驱动类型。接下来我们要介绍Docker是如何利用AUFS存储images和containers的。

##### image layer和AUFS

每一个Docker image都是由一系列的read-only layers组成。image layers的内容都存储在Docker hosts filesystem的/var/lib/docker/aufs/diff目录下。而/var/lib/docker/aufs/layers目录则存储着image layer如何堆栈这些layer的metadata。

##### container layer和AUFS

Docker使用AUFS的CoW技术来实现image layer共享和减少磁盘空间占用。CoW意味着一旦某个文件只有很小的部分有改动，AUFS也需要复制整个文件。这种设计会对容器性能产生一定的影响，尤其是在待拷贝的文件很大，或者位于很多image layers的下方，或AUFS需要深度搜索目录结构树的时候。不过也不用过度担心，对于一个容器，每一个image layer最多只需要拷贝一次。后续的改动都会在第一次拷贝的container layer上进行。

启动一个Container的时候，Docker会为其创建一个read-only的init layer，用来存储与这个容器内环境相关的内容；Docker还会为其创建一个read-write的layer用来执行所有写操作。

AUFS虽然看起来思路很简单，但是docker却利用这个技术做出了大文章。我们可以想象一下docker的Image，其实也就是一个事先制作好的只读的文件目录，当我们要使用这个系统功能的时候，docker为我们开辟s了一个新的文件夹和这个image做了union，提供给docker container做为系统运行的存储，这个image里面已经包含了系统程序、工具软件、以及程序，当系统启动后产生的运行时文件（如logs、临时目录等）或新安装的软件都在这个新的文件夹内。这样我们在启动一个container的时候，其实并没有加载镜像的过程，也不会像vm一样需要安装一个系统这么负责，只是做了一次unoin，一切就和安装过系统的虚拟机同样使用了。另外docker还提供了一个`docker commit`命令，这个命令可以随时将你现在的运行中的cantainer构建成一个新的image。

#### 容器格式

Docker将上述的多项技术包装在一起，形成了容器的格式。默认的容器格式是libcontainer , Docker也支持传统的 LXC格式。在未来，Docker也许会支持其他的容器格式，比如BSD Jails 或Solaris Zones.

### Docker网络

#### docker Bridge网络

Bridge网络可能是大家最熟悉的网络，如下图所示，HostA和HostB是两个宿主机，docker运行起来就将在宿主机上创建docker0的网桥作为容器的开关。

![](https://yqfile.alicdn.com/bf8e91215ae1f05b6750dce9a40c1a64f647961f.png)

在网桥建立完成之后，同一个宿主机上的不同容器之间就可以通过网桥的转发功能进行通信，但是位于不同宿主机器上的容器无法直接进行通信，他们可以通过iptables SNAT/DNAT和容器外网络进行通信。Bridge网络结构比较简单，但是缺点是不同宿主机之间的容器其实并不在一个共同的网络中，不同宿主机之间的容器无法进行直接的通信。

#### docker Overlay网络

对于应用而言，如果要部署在docker中，基本上都需要面对跨主机互联的问题，docker提供了原生的Overlay网络，对docker具有良好的支持性。

![](https://yqfile.alicdn.com/5be4fbd9c3d77ec96580b89eb8f62f244e196747.png)

这里简单提一下VXLAN协议，下图中的Inner Enthernet Frame是由容器发出的报文，在经过报文一层层封装以后，最后以UDP的方式发送出去。

![](https://yqfile.alicdn.com/4ace1447d40248ceb3b41531f62a02b9df2430d6.png)

在Overlay网络中，每个容器会有两张网卡，其中一张网卡用于与外部网络进行通信，向外部网络传输的数据会经由eth1网卡，并通过docker_gwbridge发送出去。如果是不同宿主机之间的容器想要通信的话，数据将会通过eth0发送出去。每个overlay网络有独立namespace和br0网桥，在节点组件集群进行通讯时，采用的使用gossip协议来管理节点成员关系、并且通过广播L3Miss处理二层ARP的交互。而不同网桥上的VXLAN设备的作用就是帮助不同宿主机的容器通过VXLAN隧道直接通信。

#### docker Weave网络

Weave网络的易用性比较高，所以更容易上手，而且目前而言，Weave网络的产品系也是比较完善的。Weave网络有两种实现方式，一种是用户动态的封装实现，另外一种是内核态的封装实现，这里主要介绍内核态的封装实现。

在下图中Weave Router中有这样的一个插件，这个插件主要实现了两个功能，一个是帮助与其他的宿主机建立gossip协议的链接，从而建立集群的拓扑关系。另外一点就是帮助跨宿主机的容器通过datapath和VXLAN隧道进行通信。

![](https://yqfile.alicdn.com/e9899eefb2ef1d3518f9d99e9978aaca0a6e478e.png)

#### 小结

这三种网路有一些共同点，首先需求是共同的，都要满足容器的跨主机通信的需求，同时ARP的广播会增加网络负担，阿里云自己的产品上这一点就被解决了，这三种网络使用的Gossip协议的运维复杂度，而且无法适应多种docker网络环境，难以满足高性能的网络业务。





---

# Docker for Mac

==Docker for Mac requires macOS 10.10.3 Yosemite or newer running on a 2010 or newer Mac, with Intel’s hardware support for MMU virtualization==. 

```shell
# 安装docker
brew cask install docker
# 安装容器管理GUI工具kitematic
brew cask install kitematic
# 检查并确认版本
docker --version
docker-compose --version
docker-machine --version
# 运行检查安装是否成功
docker run hello-world
# 简单例子建立一个网站
docker run -d -p 80:80 --name webserver nginx
# 访问 http://localhost/ 检查是否成功建立
# 查看当前正在运行的webserver容器
docker ps
# 停止容器运行
docker stop webserver
# 查看停止运行的容器
docker ps -a
# 启动容器
docker start webserver
# 移除容器，移除容器时并不会删除本地镜像
docker rm -f webserver
# 查看本地镜像
docker images
# 删除本地镜像 docker rmi <imageID>|<imageName>
docker rmi nginx
```

Docker for Mac is a Mac native application, that you install in /Applications. At installation time, it creates symlinks in *`/usr/local/bin`* for **docker** and **docker-compose**, to the version of the commands inside the Mac application bundle, in *`/Applications/Docker.app/Contents/Resources/bin`*.

![docker-for-mac-install](https://docs.docker.com/docker-for-mac/images/docker-for-mac-install.png)



```shell
# 轻量级Linux发行版：Alpine Linux，这个发行版的最大优点就是小，只有不到5M。
docker run -it alpine env
docker run -it alpine /bin/sh
```

## Installing bash completion

```shell
# insall bash completion
brew install bash-completion
brew tap homebrew/completions

# Add the following lines to your ~/.bash_profile:
if [ -f $(brew --prefix)/etc/bash_completion ]; then
  . $(brew --prefix)/etc/bash_completion
fi

cd /usr/local/etc/bash_completion.d
ln -s /Applications/Docker.app/Contents/Resources/etc/docker.bash-completion
ln -s /Applications/Docker.app/Contents/Resources/etc/docker-machine.bash-completion
ln -s /Applications/Docker.app/Contents/Resources/etc/docker-compose.bash-completion
```

## Checking the logs


```shell
syslog -k Sender Docker
syslog -k Sender Docker > ~/Desktop/my_docker_logs.txt
```

Open your browser and [browse to the Docker Hub](https://hub.docker.com/?utm_source=getting_started_guide&utm_medium=embedded_MacOSX&utm_campaign=find_whalesay).

```shell
docker run docker/whalesay cowsay boo
```

While still in the command line terminal, type *docker images* command and press RETURN.
The command lists all the images on your local system. You should see docker/whalesay in the list.

```shell
docker images
```

## Build your own image

Write a Dockerfile

```shell
# The FROM keyword tells Docker which image your image is based on.
# Whalesay is cute and has the cowsay program already, so we’ll start there.
FROM docker/whalesay:latest

# The fortunes program has a command that prints out wise sayings for our whale to say.
# So, the first step is to install it. This line installs the software into the image.
RUN apt-get -y update && apt-get install -y fortunes

# This line tells the fortune program to pass a nifty quote to the cowsay program.
CMD /usr/games/fortune -a | cowsay
```

Build an image from your Dockerfile(**don’t forget the . period**).

```shell
docker build -t docker-whale .
```

First Docker checks to make sure it has everything it needs to build.

Then, Docker loads with the whalesay image. It already has this image locally as you might recall from the last page. So, Docker doesn’t need to download it.

Docker moves onto the next step which is to update the apt-get package manager. This takes a lot of lines, no need to list them all again here.

Then, Docker installs the new fortunes software.

Finally, Docker finishes the build and reports its outcome.

Run your new image by typing docker run docker-whale and pressing RETURN.

```shell
docker run docker-whale
```

Use IMAGE ID and the docker tag command to tag your docker-whale image.

```shell
docker tag 0531fe636561 bolik/docker-whale:latest
```

Use the docker login command to log into the Docker Hub from the command line.

```shell
docker login --username=bolik
```

Type the docker push command to push your image to your new repository.

```shell
docker push bolik/docker-whale
```

Use the docker rmi to remove the maryatdocker/docker-whale and docker-whale images.
You can use an ID or the name to remove an image.

```shell
docker rmi -f bolik/docker-whale
docker rmi -f docker-whale
```

## Docker Toolbox Overview

Toolbox includes these Docker tools:

- Docker Machine for running **docker-machine** commands
- Docker Engine for running the **docker** commands
- Docker Compose for running the **docker-compose** commands
- **Kitematic**, the Docker GUI
- a shell preconfigured for a Docker **command-line** environment
- Oracle Vir**tualBox**

## Run a simple application

- docker ps - Lists containers.
- docker logs - Shows us the standard output of a container.
- docker stop - Stops running containers.

```shell
# Usage:  [sudo] docker [subcommand] [flags] [arguments] ..
# Example:
$ docker run -i -t ubuntu /bin/bash
```

You name your container by using the *--name* flag, for example launch a new container called demo:

```shell
$ docker run -i -t --name demo ubuntu /bin/bash
```

Use the docker ps command to check the name:

```shell
$ docker ps -l
```

You can also use docker inspect with the container’s name.

```shell
$ docker inspect demo
```

Container names must be unique. That means you can only call one container demo. If you want to re-use a container name you must delete the old container (with *docker rm*) before you can reuse the name with a new container. Go ahead and stop and remove your old demo container.

```shell
$ docker stop demo
$ docker rm demo
```

Launch a container on the default network

```shell
$ docker network ls
```

he network named bridge is a special network. Unless you tell it otherwise, Docker always launches your containers in this network. Try this now:

```shell
$ docker run -itd --name=networktest ubuntu
```

Inspecting the network is an easy way to find out the container’s IP address.

```shell
$ docker network inspect bridge
```

You can remove a container from a network by disconnecting the container. To do this, you supply both the network name and the container name. You can also use the container id. In this example, though, the name is faster.

```shell
$ docker network disconnect bridge networktest
```

While you can disconnect a container from a network, you cannot remove the builtin bridge network named bridge. Networks are natural ways to isolate containers from other containers or other networks. So, as you get more experienced with Docker, you’ll want to create your own networks.

## Create your own bridge network

Docker Engine natively supports both bridge networks and overlay networks. A bridge network is limited to a single host running Docker Engine. An overlay network can include multiple hosts and is a more advanced topic. For this example, you’ll create a bridge network:

```shell
$ docker network create -d bridge hadoop
```

The -d flag tells Docker to use the bridge driver for the new network. You could have left this flag off as bridge is the default value for this flag. Go ahead and list the networks on your machine:

```shell
$ docker network ls

$ docker network inspect hadoop
```

## Add containers to a network

To build web applications that act in concert but do so securely, create a network. Networks, by definition, provide complete isolation for containers. You can add containers to a network when you first run a container.

Launch a container running a PostgreSQL database and pass it the --network=my-bridge-network flag to connect it to your new network:

```shell
$ docker run -d --network=my-bridge-network --name db training/postgres
```

---

# Docker for Windows

```shell
# 检查并确认版本
docker --version
docker-compose --version
docker-machine --version
# 容器版本信息
docker version
# 查看容器信息
docker info
# 运行经典示例检查安装是否成功
docker run hello-world
# 运行ubuntu命令行
docker run -it ubuntu bash
# 运行经典nginx Web服务
docker run -d -p 80:80 --name webserver nginx
# 访问 http://localhost/ 检查是否成功建立Web服务
# 查看当前正在运行的webserver容器
docker ps
# 停止容器运行
docker stop webserver
# 查看停止运行的容器
docker ps -a
# 启动容器
docker start webserver
# 移除容器，移除容器时并不会删除本地镜像
docker rm -f webserver
# 查看本地镜像
docker images
# 删除本地镜像 docker rmi <imageID>|<imageName>
docker rmi nginx   

# Set up tab completion in PowerShell
Set-ExecutionPolicy RemoteSigned 
Get-Executionpolicy
Import-Module posh-docker
Install-Module -Scope CurrentUser posh-docker -Force
Add-Content $PROFILE "`nImport-Module posh-docker"
Notepad $PROFILE

# Proxies
# You can see from the above output that the HTTP_PROXY, http_proxy and no_proxy environment variables are set
docker run -it alpine env
```

## 开启Windows容器之旅

```shell
docker run microsoft/sample-dotnet
```

构建一个测试Docker镜像，其Dockerfile文件如下

```dockerfile
FROM microsoft/nanoserver
CMD echo Hello World!
```

构建镜像并执行

```shell
# 构建镜像
docker build -t test .
# 执行
docker run test
```

# Docker使用

## 检查安装

```shell
# 容器版本信息
docker version
# 查看容器信息
docker info
# 查看当前正在运行的容器
docker ps
# 运行经典示例检查安装是否成功
docker run hello-world
# 查看所有容器
docker ps -a
```

## Docker Engine 工作机制

![container_explainer](https://docs.docker.com/engine/getstarted/tutimg/container_explainer.png)

当执行`docker run hello-world`命令时，Docker引擎需要做如下工作：

- 检查是否存在名字为`hello-world`的本地镜像
- 如果不存在则从Docker Hub下载最新版本的镜像
- 加载镜像并创建一个新的容器并启动它

### 各种Docker注册中心一览

Docker注册中心包含了一组可以让用户上传和分享Docker镜像的仓库。除了知名度较高的公共仓库，比如[Docker Hub](https://hub.docker.com/)，还有其它不是很知名但很有特点的仓库，它们既可以对外提供服务，也可以被部署成本地仓库。

有些[托管的注册中心](http://rancher.com/comparing-four-hosted-docker-registries/)同时也提供私有仓库，比如Docker Hub，它为免费用户提供了一个私有仓库，而付费用户可以创建更多的私有仓库。Docker Hub的结构模型有点类似Github，支持协作、组织以及组织里的分组。它可以跟Github和Bitbucket很好地集成起来。不过Docker Hub在访问权限控制方面做得不是很好，也不支持与企业常用的LDAP或Active Directory这样的认证/授权系统集成。

越来越多的云平台供应商开始提供容器托管服务，容器注册中心将成为他们的下一个功能关注点。AWS提供了[EC2 Container Registry](https://www.infoq.com/news/2015/10/ecs-update)（ECR），Google云平台提供了[Google Container Registry](https://www.infoq.com/news/2015/01/google-cloud-private-registry)。ECR集成了Elastic Container Service（ECS），为AWS带来了伸缩性，同时提供了私有托管服务。Google的容器注册中心提供了多项安全方面的特性，比如基于时间的认证token以及加密的镜像存储。

还有其它很多容器注册中心，它们既可以提供托管服务，也可以作为本地注册中心。

- CoreOS的[Quay.io](https://www.infoq.com/news/2014/08/coreos-enterprise-registry)。Quay提供了免费的公共仓库，同时也有付费的私有仓库，收费取决于仓库数量的多少。Quay支持仓库按照组织和团队来划分，并提供了相应的访问权限控制。它还为工作流和查看镜像生命周期提供了图形用户界面，为软件交付管道提供了Web应用钩子和事件通知机制。在安全认证方面，Quay支持[Dex](https://github.com/coreos/dex)（一个OpenID和OAuth 2.0的供应商）、LDAP和OpenStack的Keystone。Quay的本地版叫作[Quay Enterprise](https://tectonic.com/quay-enterprise/)。
- JFrog的[Artifactory](http://www.jfrog.com/artifactory/)。Artifactory相比其它产品要贵一些。它支持LDAP、SAML认证和user/group级别的权限控制。
- Gitlab的[容器](https://docs.gitlab.com/ee/user/project/container_registry.html)[注册中心](https://www.infoq.com/news/2016/05/gitlab-docker-registry)。因为是Gitlab提供的，所以这款产品跟Gitlab工具和Gitlab CI工作流可以很好地兼容，而且允许Docker镜像跟项目代码放在同一个地方。

有些容器注册中心在某些方面比较擅长，比如安全。[FlawCheck](https://www.flawcheck.com/)可以扫描Docker镜像的漏洞。VMware的[Harbor](https://github.com/vmware/harbor)是一款提供了安全和标识管理功能的开源容器注册中心，它还可以跟LDAP及其它现有系统集成，还支持活动审计。

Sonatype的Nexus也[支持](https://www.sonatype.com/products-sonatype#Docker)Docker仓库，还可以作为注册中心来使用。

## 从Docker Hub搜索镜像并运行

打开[Docker Hub](https://hub.docker.com/?utm_source=getting_started_guide&utm_medium=embedded_MacOSX&utm_campaign=find_whalesay)并搜索名字为`whalesay`的镜像

运行镜像

```shell
# 运行whalesay
$ docker run docker/whalesay cowsay boo
# 查看本地镜像
$ docker images
# 再次运行一个容器
$ docker run docker/whalesay cowsay boo-boo

# 搜索docker镜像
$ docker search coreos
# 在搜索结果中，你可以看到有的是通过"/"划分的，有的没有。
# 凡是没有"/"分级的就是Docker Hub自带的镜像；否则该镜像就出自于某个Docker Hub用户。
# 从这里你也可以看到，Docker Hub是一个Public仓库，你的任何镜像，别人都可以搜索到。
# 因此，一定要注意安全，不要把敏感信息放上去了。

# 拉取一个镜像
$ docker pull steigr/coreos
$ docker pull centos

# 运行一个可交互的shell终端
$ docker run -i -t ubuntu /bin/bash
# 剖析：
# -i 表示启动一个可交互的容器
# –t 表示使用pseudo-TTY，关联到容器的stdin和stdout
# 在终端中，如果输入exit命令将会停止当前容器；
# 因此如果只是取消关联，可以键入ctrl-p或者ctrl-q
# 你可以在其他终端通过docker ps –a查看已经运行的容器列表

# 运行一个长时间的程序
$ JOB=$(docker run -d ubuntu /bin/sh -c "while true; do echo Hello world; sleep 1; done")
# 本例启动了一个容器，而该容器会每隔1秒输出Helo World
# –d 表示在后台运行
# 查看该容器的日志，就是查看标准输出stdout
$ docker logs $JOB
# Kill the job 表示停掉这个容器
$ docker kill $JOB
# 停止一个容器
$ docker stop $JOB
# 启动一个已经创建的容器
$ docker start $JOB
# 重启一个容器
$ docker restart $JOB
# 停止一个容器
$ docker kill $JOB
# 删除一个容器
$ docker stop $JOB # 必须先停止
$ docker rm $JOB
```

## Docker命令

```shell
$ docker --help
Usage: docker [OPTIONS] COMMAND [arg...]
       docker [ --help | -v | --version ]

A self-sufficient runtime for containers.

Options:

  --config=%USERPROFILE%\.docker              Location of client config files
  -D, --debug                                 Enable debug mode
  -H, --host=[]                               Daemon socket(s) to connect to
  -h, --help                                  Print usage
  -l, --log-level=info                        Set the logging level
  --tls                                       Use TLS; implied by --tlsverify
  --tlscacert=%USERPROFILE%\.docker\ca.pem    Trust certs signed only by this CA
  --tlscert=%USERPROFILE%\.docker\cert.pem    Path to TLS certificate file
  --tlskey=%USERPROFILE%\.docker\key.pem      Path to TLS key file
  --tlsverify                                 Use TLS and verify the remote
  -v, --version                               Print version information and quit

Commands:
    attach    Attach to a running container
    build     Build an image from a Dockerfile
    commit    Create a new image from a container's changes
    cp        Copy files/folders between a container and the local filesystem
    create    Create a new container
    diff      Inspect changes on a container's filesystem
    events    Get real time events from the server
    exec      Run a command in a running container
    export    Export a container's filesystem as a tar archive
    history   Show the history of an image
    images    List images
    import    Import the contents from a tarball to create a filesystem image
    info      Display system-wide information
    inspect   Return low-level information on a container, image or task
    kill      Kill one or more running containers
    load      Load an image from a tar archive or STDIN
    login     Log in to a Docker registry.
    logout    Log out from a Docker registry.
    logs      Fetch the logs of a container
    network   Manage Docker networks
    node      Manage Docker Swarm nodes
    pause     Pause all processes within one or more containers
    port      List port mappings or a specific mapping for the container
    ps        List containers
    pull      Pull an image or a repository from a registry
    push      Push an image or a repository to a registry
    rename    Rename a container
    restart   Restart a container
    rm        Remove one or more containers
    rmi       Remove one or more images
    run       Run a command in a new container
    save      Save one or more images to a tar archive (streamed to STDOUT by default)
    search    Search the Docker Hub for images
    service   Manage Docker services
    start     Start one or more stopped containers
    stats     Display a live stream of container(s) resource usage statistics
    stop      Stop one or more running containers
    swarm     Manage Docker Swarm
    tag       Tag an image into a repository
    top       Display the running processes of a container
    unpause   Unpause all processes within one or more containers
    update    Update configuration of one or more containers
    version   Show the Docker version information
    volume    Manage Docker volumes
    wait      Block until a container stops, then print its exit code
    
# 容器的名称通过--name来进行设置
$ docker run -d -P --name web training/webapp python app.py
# 可以通过docker inspect来查看容器的详细参数
$ docker inspect web

# Docker自身通过网络驱动来管理网络。
# 默认Docker提供两种网络驱动，bridge和overlay。
# 查看docker网络
$ docker network ls
# bridge是一种特殊的网络模式，这是默认的网络模式。我们可以通过inspect来查看详细信息
$ docker network inspect bridge
# Docker原生支持bridge和overlay网络，bridge只能在单个主机上使用。overlay可以在多台主机间使用。
# 创建自己的桥接网络
$ docker network create -d bridge mybridge
# -d 表示使用已有的bridge来创建新的网络，你也可以省略该参数，这个是默认参数。
# 默认情况，容器使用的是同一个bridge网络，这样可能有一定的安全隐患，
# 为了做到完全的隔离，我们可以自己建一个桥接网络，然后在启动容器时将容器加入到自己的网络中。
$ docker run -it --net=mybridge ubuntu /bin/bash
# 如果启动时没有指定网络或想加入多个网络，可以通过connect命令加入。
```

## 自己创建镜像

创建新目录并初始化Dockerfile

```shell
# 创建目录
$ mkdir mydockerbuild
$ cd mydockerbuild
# 创建Dockerfile
$ touch Dockerfile
$ ls
```
Dockerfile 内容如下：
```dockerfile
# 指定创建镜像的基线
FROM docker/whalesay:latest
# 在基线镜像运行基础上执行Shell命令，安装程序
RUN apt-get -y update && apt-get install -y fortunes
# 运行程序
CMD /usr/games/fortune -a | cowsay
```

编译镜像

```shell
# 查看Dockerfile内容
$ cat Dockerfile
# 编译镜像
$ docker build -t docker-whale .
# Usage:	docker build [OPTIONS] PATH | URL | -
# -t 为镜像添加一个tag
# -f 指定 Dockerfile
```

编译过程

- 确认所有信息没有问题，并将信息发送给Docker daemon
- 执行第一步：`FROM docker/whalesay:latest`，获取基线镜像并运行之
- 执行第二步：`RUN apt-get -y update && apt-get install -y fortunes`，执行shell命令
- 执行第三步：`CMD /usr/games/fortune -a | cowsay`，执行shell命令
- 执行完成无错则完成镜像编译

执行新镜像

```shell
# 检查并确认新镜像成功建立
$ docker images
# 运行新镜像
$ docker run docker-whale
```

## 提交镜像到Docker Hub

首先需要创建Docker Hub账户

```shell
# 检查并确认新镜像成功建立，并查看镜像docker-whale的IMAGE ID
$ docker images
# 为新建的镜像打上标签
$ docker tag 71bf45a14221 bolik/docker-whale:latest
# 检查标签结果
$ docker images
# 在命令行登录docker hub账户，需要输入用户名和密码
$ docker login
# 推送镜像
$ docker push bolik/docker-whale
# 删除本地镜像
$ docker rmi -f 71bf45a14221
$ docker rmi -f docker-whale
# 测试推送镜像
$ docker run bolik/docker-whale
```

![Docker tag command](https://docker.github.io/engine/getstarted/tutimg/tagger.png)

## Dockerfile格式

如果你的编译目录下有一些文件是不需要打包进Image的，你可以使用"dockerignoe file"文件进行过滤。重要涉及的指令是ADD和COPY。

```dockerfile
# Dockerfile指令是不区分大小写的，不过一般都使用大写来区分指令和参数。
# Dockerfile的第一句指令，必须是'FROM'，这个后面紧跟的是基础镜像名称。
# '#'可以用来注释。
FROM <image>
FROM <image>:<tag>
FROM <image>@<digest>
# FROM指令指定了目标Image的基础镜像。
# tag是某个特定版本的镜像, digest是最新引入的一种ID，类似于唯一标示符。

MAINTAINER <name>
# 这个字段一目了然，就是设置作者。

# 环境变量指令是ENV，这个类似于编程语言的变量，只能在Dockerfile中使用。
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar
ADD . $foo       # ADD . /bar
COPY \$foo /quux # COPY $foo /quux
# 其中支持变量应用的指令包括：
ADD
COPY
ENV
EXPOSE
LABEL
USER
WORKDIR
VOLUME
STOPSIGNAL
ONBUILD

# RUN包含两种格式：
# RUN (shell格式，这种命令运行在shell中 /bin/sh -c)
# RUN ["executable", "arg1", "arg2"] (exec格式) 
# RUN指令可以执行任何命令，并在当前image的顶层添加一个文件层，并提交到新的image中。
# 由此我们可以看出，每一个RUN指令都会新加一层文件系统，
# 虽然这个并不占多少空间，不过还是推荐尽可能多的减少指令。
# 因此我们可以使用\来做换行处理。
# 换行模式
RUN /bin/bash -c 'source $HOME/.bashrc ; \
echo $HOME'
# 不换行模式
RUN /bin/bash -c 'source $HOME/.bashrc ; echo $HOME'
# exec模式
RUN apt-get dist-upgrade -y
```

### 制定CentOS镜像

#### 交互式方式

```shell
# 下载centos镜像
$ docker pull centos
# 启动容器
$ docker run -it -d --name test-centos1 centos
# 进入容器
$ docker exec -it test-centos1 /bin/bash
# 检查工具
$ ifconfig
# 安装 net-tools 
$ yum install net-tools -y
# 安装 openssh-server
$ yum install openssh-server -y
# 创建ssh 所需的目录
$ mkdir -pv /var/run/sshd
# 在根目录创建sshd 启动脚本
cat /auto_sshd.sh
#!/bin/bash
/usr/sbin/sshd -D
# 给启动脚本权限
$ chmod +x /auto_sshd.sh
# 修改容器内root 的账户密码
$ echo "root:iloveworld" | chpasswd
# 生成ssh 主机dsa 密钥（不然ssh 该容器时，会出现错误。）
$ ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
$ ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key
# history记录的时间
$ echo 'export HISTTIMEFORMAT="%F %T `whoami` "' >> /etc/profile

# 打包成新的镜像
$ docker commit test-centos1 centos_sshd:7.0
# 这条命令更方便以后启动
$ docker commit --change='CMD ["/auto_sshd.sh"]' -c "EXPOSE 22" test-centos1 centos_sshd:7.0
# --change : 将后期使用此镜像运行容器时的命令参数、开放的容器端口提前设置好。

# 启动新的容器
$ docker run -d -it --name centos_7.0-1 centos_sshd:7.0
# 查看容器ip
$ docker exec centos_7.0-1 hostname -I
# ssh连接容器
$ ssh root@172.17.0.2
```

#### Dockerfile方式

dockerfile内容如下：

```dockerfile
# The dockerfile has Change add sshd services on Centos7.0
#centos7:latest image
FROM centos:latest

MAINTAINER Yifeng,http://www.cnblogs.com/hanyifeng

#Install sshd net-tools
RUN yum install openssh-server net-tools -y
RUN mkdir /var/run/sshd

#Set password for root
RUN echo 'root:iloveworld' | chpasswd
RUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config

#Set history record
ENV HISTTIMEFORMAT "%F %T  "

#Fix sshd service:Read from socket failed: Connection reset by peer?
RUN ssh-keygen -A

#Change timezone CST
RUN \cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime

#Open 22 port
EXPOSE 22

#Auto running sshd service
CMD ["/usr/sbin/sshd","-D"]

```

构建

```shell
# 使用docker build命令来创建镜像
$ docker build -t centos_sshd_1 .
# -t 选项来docker build新的镜像以便于标记构建的镜像，
# . 表示当前目录，也可以指定dockerfile 文件所在目录。

# 查看镜像列表
$ docker images
# 创建容器
$ docker run -d -it --name centos-two centos_sshd_1
# 查看容器ip
$ docker exec centos-two hostname -I
# ssh
$ ssh root@172.17.0.2
```

### Dockerfile注意事项

#### 准则

1. 尽量将Dockerfile放在空目录中，如果目录中必须有其他文件，则使用.dockerignore文件。
2. 避免安装不必须的包。
3. 每个容器应该只关注一个功能点。
4. 最小化镜像的层数。
5. 多行参数时应该分类。这样更清晰直白，便于阅读和review，另外，在每个换行符\前都增加一个空格。
6. 固定软件版本。固定所有依赖的版本是实现良好实践最佳途径。这包括基本映象，从GitHub中提取的代码，代码依赖的库等等。通过版本控制，您可以简化应用程序已知的工作版本。
7. 对构建缓存要有清楚的认识。自我清理。确保所有的清理语句在同一个部分运行，否则它们将看起来清除，但最终仍然存在于Docker容器成为残留。
8. 组合运行语句。把逻辑上属于一起操作步骤的语句合并进入Dockerfile中，这样以避免类似缓存和不必要地使用磁盘空间有关常见问题。 
9. 使用启动脚本。创建和调试比较大型的项目，不要直接使用CMD命令运行，建立一个开始脚本，每次调用运行。
10. 创建 Non-Root User。`RUN useradd --user-group --shell /bin/false docker ` ` USER docker`

#### 指令注意事项

##### FROM

[Dockerfile reference for the FROM instruction](https://docs.docker.com/engine/reference/builder/#from)

任何时候，尽量使用官方镜像源作为你镜像的基础镜像。我们建议使用[Debian Image](https://hub.docker.com/_/debian/)，因为其被很好地管理着，并且作为一个完整的发布包，但体积却保持着最小化（当前不足150MB）。

　　1. FROM必须是除了注释以外的第一行；

　　2. 可以有多个FROM语句，来创建多个image；

##### LABEL

[Dockerfile reference for the LABEL instruction](https://docs.docker.com/engine/reference/builder/#label)

##### RUN

[Dockerfile reference for the RUN instruction](https://docs.docker.com/engine/reference/builder/#run)

　　RUN语句有两种格式：

###### apt-get

尽量避免使用RUN apt-get upgrade或者dist-upgrade，因为基础镜像的很多核心包不会再未授权的容器中升级。

要结合RUN apt-get update和apt-get install在同一个RUN语句下一起使用。如：

```dockerfile
RUN apt-get update && apt-get install -y \
        package-bar \
        package-baz \
        package-foo
```

如果将update和install分开使用，执行多个Dockerfile时，会引起缓存问题，导致后面执行的install语句会失败。

另外，执行完apt-get语句后，最后最好加上删除安装包的语句，以减小镜像的体积。如：

```
RUN apt-get update && apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
 && rm -rf /var/lib/apt/lists/*
```

**注意**：官方的Debian和Ubuntu镜像会自动执行“`RUN apt-get clean`”，所以不需要明确地删除指令。

###### 管道使用

很多RUN命令都需要使用到管道，如：

`RUN wget -O - https://some.site | wc -l > /number`

Docker使用`/bin/sh -c`解释器来执行这些命令，该解释器只评估管道最后一个操作的返回值来判断整个命令是否成功。在上面的例子中，只要`wc -l`命令成功了，即使`wget`命令失败了，也会创建一个新镜像。为了避免上述情况，可以在语句首部加上`set -o pipefail &&`。比如：

`RUN set -o pipefail && wget -O - https://some.site | wc -l > /number`

**注意**：并非所有的shell都支持`-o pipefail`选项，比如说基于Debian的镜像下的模式`shell：dash shell`。这种情况下，我们可以使用`exec`格式的RUN命令来显示地选择shell来支持pipefail选项。如：

`RUN ["/bin/bash", "-c", "set -o pipefail && wget -O - https://some.site | wc -l > /number"]`

##### CMD

[Dockerfile reference for the CMD instruction](https://docs.docker.com/engine/reference/builder/#cmd)

CMD语句与RUN不同，RUN是在build镜像的时候运行，而CMD语句是在build结束后运行。一个Dockerfile钟可以有多个RUN语句，虽然也可以有多个CMD语句，但是却只有最后一条CMD语句会执行。CMD语句格式为：

`CMD [“executable”, “param1”, “param2”…]`

##### EXPOSE

[Dockerfile reference for the EXPOSE instruction](https://docs.docker.com/engine/reference/builder/#expose)

EXPOSE指令指明容器会监听链接的端口。因此，最好使用常用的、传统的应用端口。比如，Apache web服务器使用EXPOSE 80等。

为了给外部链接使用，你需要使用`docker run`命令来制定容器端口和host端口的映射。

##### ENV

[Dockerfile reference for the ENV instruction](https://docs.docker.com/engine/reference/builder/#env)

用于设置环境变量，设置后，后面的RUM指令就可以使用之前的环境变量了。同时，还可以通过`docker run --env key=value`，在容器启动时设置环境变量。如：

```dockerfile
ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …
ENV PATH /usr/local/postgres-PG_MAJOR/bin:PATH
```

##### ADD和COPY

[Dockerfile reference for the ADD instruction](https://docs.docker.com/engine/reference/builder/#add)

[Dockerfile reference for the COPY instruction](https://docs.docker.com/engine/reference/builder/#copy)

虽然ADD和COPY功能相似，但一般来讲，更建议使用COPY。因为COPY比ADD更透明，COPY只支持从本地文件到容器的拷贝，但是ADD还有一些其他不明显的特性（比如本地tar包解压缩和远程URL支持）。因此，ADD的最优用处是本地tar包自动解压缩到镜像中。如：ADD rootfs.tar.xz /。

如果有多个Dockerfile步骤用于处理不同的文件，建议分开COPY它们，而不是一次性拷贝。这可以保证每个步骤的build缓存只在对应的文件改变时才无效。比如：

```dockerfile
COPY requirements.txt /tmp/
RUN pip install --requirement /tmp/requirements.txt
COPY . /tmp/
```

镜像的大小很重要，因此不鼓励使用ADD从远端URL获取包；可以使用curl或者wget来代替。这种方式你可以删除不再需要的文件，如解压缩后的tar包，从而不需要再添加额外的layer到镜像中。

```dockerfile
# 你应该避免这样使用：
ADD http://example.com/big.tar.xz /usr/src/things/
RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
RUN make -C /usr/src/things all


# 而应该如此：
RUN mkdir -p /usr/src/things \
    && curl -SL http://example.com/big.tar.xz | tar -xJC /usr/src/things \
    && make -C /usr/src/things all
```

对于不需要使用ADD命令tar包自动解压缩功能的文件和目录，你应该总是使用COPY。

##### ENTRYPOINT

[Dockerfile reference for the ENTRYPOINT instruction](https://docs.docker.com/engine/reference/builder/#entrypoint)

使用ENTRYPOINT来设置镜像的主命令，就像这个镜像运行时就是这条命令一样（然后再使用CMD作为默认的flag）。

我们使用s3cmd命令作为镜像的主命令。

```dockerfile
ENTRYPOINT ["s3cmd"]
CMD ["--help"]
```

##### VOLUME

[Dockerfile reference for the VOLUME instruction](https://docs.docker.com/engine/reference/builder/#volume)

VOLUME指令一般用于数据库的存储区域，配置存储，或者docker容器创建的文件和目录。

##### USER

[Dockerfile reference for the USER instruction](https://docs.docker.com/engine/reference/builder/#user)

如果服务可以在不需要特权的情况下运行，那么就应该使用USER来切换用户至非root用户。可以用RUN命令创建用户组和用户如：

`RUN groupadd -r postgres && useradd -r -g postgres postgres`

应该避免安装和使用sudo，因为它有不可预知的TTY和信号转移特性，会产生很多问题。如果的确一定要使用类似sudo的功能（如root下初始化daemon，非root下运行），可以使用“gosu”。

##### WORKDIR

[Dockerfile reference for the WORKDIR instruction](https://docs.docker.com/engine/reference/builder/#workdir)

为了Dockerfile内容更加清晰和可靠，最好总是使用绝对路径。同样地，应该使用WORKDIR，而不是使用类似“`cd … && do-something`”这样的指令，因为那样会导致难以阅读、查找错误和维护。

##### ONBUILD

[Dockerfile reference for the ONBUILD instruction](https://docs.docker.com/engine/reference/builder/#onbuild)

##### 其他资源

[Dockerfile Best Practices](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)

[Dockerfile Reference](https://docs.docker.com/engine/reference/builder/)

[https://github.com/docker-library/buildpack-deps/blob/master/jessie/Dockerfile](https://github.com/docker-library/buildpack-deps/blob/master/jessie/Dockerfile)

[.dockerignore file](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

[http://dockone.io/article/2034](http://dockone.io/article/2034)

[https://docs.resin.io/deployment/build-optimisation/](https://docs.resin.io/deployment/build-optimisation/)



## 管理容器的数据

### 数据卷

数据卷是一个经过特殊设计的文件夹，提供给容器使用。数据卷并不由UnionFS管理，因此数据卷可以用作持久化和数据分享，它具有以下特性：

- 数据卷在容器创建的时候进行初始化。如果容器的镜像在特定的Mount点下有数据，那么已有的数据将被拷贝到指定目录。
- 数据卷可以在容器间共享和复用
- 对数据卷的改变是直接操作，不会回滚。
- 当你更新镜像时，数据卷的改变不会被保存。
- 即使容器被删除了，数据卷也不会丢失。

因此，数据卷是用来持久化数据的，跟容器本身的生命周期是无关的。Docker删除容器的时候，不会自动删除数据卷，因此当你使用数据卷的时候也要注意不要产生过多的垃圾数据。

###  使用数据卷

数据卷是通过-v来指定的，在docker create和docker run的时候可以使用多个-v参数，指定多个数据卷。

```shell
# 在docker create和docker run的时候可以使用多个-v参数，指定多个数据卷。
$ docker run -d -P --name web -v /webapp training/webapp python app.py
# 这条命令在创建容器时，会创建一个/webapp目录。 
# 注意:我们也可以通过VOLUME指令在Dockerfile中指定需要Mount的数据卷。 
# 默认情况下，数据卷是可读可写的，但是你也可以设置为只读：
$ docker run -d -P --name web -v /opt/webapp:ro training/webapp python app.py

# 定位卷的位置
$ docker inspect web
...
 "Mounts": [
     {
         "Name": "b40b91f75aeaa558207083de91b33a43d4f2c3c94b8e956960f9f55db21a1c19",
         "Source": "/var/lib/docker/volumes/b40b91f75aeaa558207083de91b33a43d4f2c3c94b8e956960f9f55db21a1c19/_data",
         "Destination": "/webapp",
         "Driver": "local",
         "Mode": "",
         "RW": true,
         "Propagation": ""
     }
...
# 其中source是文件系统在主机上的地址(注意这个地址是随机分配的，因此一定要注意垃圾回收)，
# Destination是容器中的地址。

# 通过-v我们可以给容器添加一个随机的数据卷，但是这种卷是不好控制的。
# 我们可以Mount一个本地文件夹作为数据卷。
$ docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
# 将本地的/src/webapp映射到了容器的/opt/webapp目录。
# 由于将主机的文件系统映射到了容器中，因此容器有了主机的完全访问权限，因此一定要注意安全。

# -v参数除了可以Mount文件夹，还可以做文件的映射。
$ docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash
# 这条命令，将把主机的~/.bash_histroy映射到容器中，因此主机和容器可以共享Bash命令的历史数据。
# 如果将~/.bash_profile映射进去，那就可以共享Bash的配置。

# 如果你希望在容器间共享卷，那么就可以使用数据型容器。我们可以先创建一个命名容器：
$ docker create -v /dbdata --name dbdata ubuntu
# 通过--volumes-from选项来进行数据卷的复用：
$ docker run -it --volumes-from dbdata --name db1 ubuntu
# 然后再建一个容器：
$ docker run -it --volumes-from dbdata --name db2 ubuntu
# 之后我们就可以在db1和db2中同时对/dbdata进行操作了。

# 可以通过下面的命令进行数据备份：
$ docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
# --volumes-from将把dbdata容器的数据卷Mount到当前容器；
# -v 将当前目录映射到/backup目录
# tar命令将/dbdata打包

# 可以对容器进行数据恢复：
$ docker run -v /dbdata --name dbdata2 ubuntu /bin/bash
$ docker run --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "cd /dbdata && tar xvf /backup/backup.tar"
```

由于数据卷的共享，会出现多个容器同时写一个卷的情况，因此可能会导致数据丢失，这里面一定要特别注意。可以采取一定的同步机制来保证数据的一致性。

## Docker Compose 使用

创建测试目录

```shell
$ mkdir composetest
$ cd composetest
```

创建`app.py` 文件，内容如下：

```python
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host='redis', port=6379)

@app.route('/')
def hello():
    redis.incr('hits')
    return 'Hello World! I have been seen %s times.' % redis.get('hits')

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
```

创建`requirements.txt`文件，内容如下：

```
flask
redis
```

创建`Dockerfile`文件，内容如下：

```dockerfile
FROM python:2.7
ADD . /code
WORKDIR /code
RUN pip install -r requirements.txt
CMD python app.py
```

编译容器

```shell
 $ docker build -t web .
```

创建`docker-compose.yml`文件，内容如下：

```yaml
version: '2'
services:
  web:
    build: .
    ports:
     - "5000:5000"
    volumes:
     - .:/code
    depends_on:
     - redis
  redis:
    image: redis
```

本Compose文件定义了两个服务`web` 和`redis`。

其中Web服务：

- 通过当前目录的`Dockerfile`构建
- 映射容器的5000端口到宿主机的5000端口
- 把本地目录映射到容器的`/code` 目录，使得我们修改代码而不用重新构建镜像
- 将Web服务链接到Redis服务

Redis服务通过拉取Docker Hub最新的redis镜像构建

运行应用并通过[localhost](http://localhost:5000/)访问Web服务

```shell
# 运行应用
$ docker-compose up
# 可以通过访问http://localhost:5000/

# 以后台方式运行web服务 -d flag (for “detached” mode) 
$ docker-compose up -d
# 查看当前正在运行的compose
$ docker-compose ps
# 停止后台服务
$ docker-compose stop

# The docker-compose run command allows you to run one-off commands for your services. 
# For example, to see what environment variables are available to the web service:
$ docker-compose run -d web env
```
# Docker镜像

**使用Docker Hub Mirror加速Docker官方镜像下载**

https://mirrors.ustc.edu.cn/dockerhub/

使用 DaoCloud团队 ([https://www.daocloud.io/](https://www.daocloud.io/)) 提供的服务Docker Hub Mirror。

http://3cf4ace6.m.daocloud.io

`curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://3cf4ace6.m.daocloud.io`

### 操作系统

#### [Alpine](https://hub.docker.com/_/alpine/)

Alpine Linux 是一个社区开发的面向安全应用的轻量级Linux发行版。          

适合用来做Docker镜像、路由器、防火墙、VPNs、VoIP 盒子 以及服务器的操作系统，基于 [uClibc](http://baike.baidu.com/view/2946499.htm) 和 [Busybox](http://baike.baidu.com/view/1429588.htm)。                                                                                                                                                                                                                                                                                                    A super small Docker image based on [Alpine Linux](http://alpinelinux.org/). The image is only 5 MB and has access to a package repository that is much more complete than other BusyBox based images.

```shell
# 拉取最新版镜像
$ docker pull alpine
```

使用Alpine

```dockerfile
FROM alpine:3.3
RUN apk add --no-cache mysql-client
ENTRYPOINT ["mysql"]
```

#### [Debian](https://hub.docker.com/_/debian/)

**Debian**的发行及其软件源有五个分支：旧稳定分支（oldstable）、稳定分支（stable）、测试分支（testing）、不稳定分支（unstable）、实验分支（experimental）。

当前的稳定分支即Jessie（即下一个旧稳定分支），所有开发代号均出自[Pixar](http://baike.baidu.com/view/430098.htm)的电影《[玩具总动员](http://baike.baidu.com/view/229314.htm)》。

| 版本号以及代号     | 发布日期            | 玩具总动员的对应角色          | 主要特点                         |
| ----------- | --------------- | ------------------- | ---------------------------- |
| 0.01至0.91   | 1993年8月至1994年1月 |                     |                              |
| 0.93R5      | 1995年3月         |                     |                              |
| 0.93R6      | 1995年11月        |                     |                              |
| 1.1 Buzz    | 1996年6月17日      | 巴斯光年                | 使用Linux内核2.0                 |
| 1.2 Rex     | 1996年12月12日     | 暴龙                  |                              |
| 1.3 Bo      | 1997年6月2日       | 放羊的女孩               |                              |
| 2.0 Hamm    | 1998年7月24日      | 小猪扑满                |                              |
| 2.1 Slink   | 1999年3月9日       | 玩具狗                 | APT问世                        |
| 2.2 Potato  | 2000年8月15日      | Potato Head先生       |                              |
| 3.0 Woody   | 2002年7月19日      | 胡迪，电影主角之一的牛仔        |                              |
| 3.1 Sarge   | 2005年6月6日       | 绿色塑胶玩具士兵的首领         |                              |
| 4.0 Etch    | 2007年4月8日       | 玩具黑板                |                              |
| 5.0.0 Lenny | 2009年2月14日      | 望远镜                 |                              |
| 6 squeeze   | 2011年2月16日      | 三只眼睛的绿色大嘴玩具外星人      |                              |
| 7 wheezy    | 2013年5月4日       | 一只带着领结的玩具企鹅         | 加强MultiArch，稳定版本             |
| 8 Jessie    | 2015年4月26日      | 玩具总动员第二部中的角色，是一个女牛仔 | 禁用了旧版不安全的SSLv3协议默认使用 Systemd |
| Sid         | 每日更新            | 席德，隔壁的男孩，玩具终结者      | 软件较新，适合桌面和软件测试               |

```shell
# 拉取最新镜像
$ docker pull debian
```

使用

```dockerfile
# 最新版 
FROM debian:latest 		# debian8
FROM debian:jessie 		# debian8
FROM debian:wheezy 		# debian7
FROM debian:squeeze 	# debian6
```

#### [Ubuntu](https://hub.docker.com/_/ubuntu/)

Ubuntu（乌班图）是一个以[桌面](http://baike.baidu.com/view/79807.htm)应用为主的[Linux操作系统](http://baike.baidu.com/view/46577.htm)，其名称来自非洲南部[祖鲁语](http://baike.baidu.com/view/400103.htm)或豪萨语的“ubuntu”一词，意思是“人性”、“**我的存在是因为大家的存在**”，是非洲传统的一种价值观，类似华人社会的“仁爱”思想。Ubuntu基于Debian发行版和[GNOME](http://baike.baidu.com/view/281766.htm)桌面环境，而从11.04版起，Ubuntu发行版放弃了Gnome桌面环境，改为[Unity](http://baike.baidu.com/subview/1097775/5930556.htm)，与Debian的不同在于它每6个月会发布一个新版本。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由[自由软件](http://baike.baidu.com/view/20965.htm)构建而成的操作系统。Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助。2013年1月3日，Ubuntu正式发布面向智能手机的移动操作系统。

Ubuntu共有五个长期支持版本（Long Term Support，LTS）：Ubuntu 6.06、8.04、10.04、12.04与14.04。Ubuntu 12.04和14.04桌面版与服务器版都有5年支持周期。而之前的长期支持版本为桌面版3年，服务器版5年。

Ubuntu每6个月发布一个新版本，而每个版本都有代号和版本号，其中有LTS是长期支持版。版本号基于发布日期，例如第一个版本，4.10，代表是在2004年10月发行的。

| Version                                  | Code name                                | Release date                             | Supported until                          |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| [12.04 LTS](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_12.04_LTS_.28Precise_Pangolin.29) | Precise Pangolin                         | 2012-04-26                               | Older version, yet still supported: 2017-04-26 |
| [12.10](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_12.10_.28Quantal_Quetzal.29) | Quantal Quetzal                          | 2012-10-18                               | Old version, no longer supported: 2014-05-16 |
| [13.04](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_13.04_.28Raring_Ringtail.29) | Raring Ringtail                          | 2013-04-25                               | Old version, no longer supported: 2014-01-27[[20\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-omgubuntu.co.uk-20) |
| [13.10](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_13.10_.28Saucy_Salamander.29) | Saucy Salamander                         | 2013-10-17                               | Old version, no longer supported: 2014-07-17 |
| [14.04 LTS](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_14.04_LTS_.28Trusty_Tahr.29)[[70\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-70) | Trusty Tahr                              | 2014-04-17                               | Older version, yet still supported: 2019-04 |
| [14.10](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_14.10_.28Utopic_Unicorn.29) | Utopic Unicorn[[71\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-71) | 2014-10-23[[72\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-UtopicRelease-72) | Old version, no longer supported: 2015-07-23 |
| [15.04](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_15.04_.28Vivid_Vervet.29) | Vivid Vervet[[73\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-73) | 2015-04-23                               | Old version, no longer supported: 2016-02-04 |
| [15.10](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_15.10_.28Wily_Werewolf.29) | Wily Werewolf[[74\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-74) | 2015-10-22[[75\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-75) | Old version, no longer supported: 2016-07-28[[76\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-76) |
| [16.04 LTS](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_16.04_LTS_.28Xenial_Xerus.29) | Xenial Xerus[[77\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-77) | 2016-04-21[[78\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-ubuntu_insights_2016_04_21-78) | Older version, yet still supported: 2021-04 |
| [16.10](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_16.10_.28Yakkety_Yak.29) | Yakkety Yak[[79\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-79) | 2016-10-13[[80\]](https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#cite_note-80) | Current stable version: **2017-07[81]**  |
| 17.04                                    | Zesty Zapus                              | 2017-04                                  | 2018-01                                  |

```shell
$ docker pull ubuntu
```

Supported tags and respective `Dockerfile` links

- `12.04.5`, `12.04`, `precise-20161123`, `precise` [(*precise/Dockerfile*)](https://github.com/tianon/docker-brew-ubuntu-core/blob/cf9d7a2ee20c8a4706a05d1d7f1a1e25ae32ed39/precise/Dockerfile)
- `14.04.5`, `14.04`, `trusty-20161123`, `trusty` [(*trusty/Dockerfile*)](https://github.com/tianon/docker-brew-ubuntu-core/blob/cf9d7a2ee20c8a4706a05d1d7f1a1e25ae32ed39/trusty/Dockerfile)
- `16.04`, `xenial-20161121`, `xenial`, `latest` [(*xenial/Dockerfile*)](https://github.com/tianon/docker-brew-ubuntu-core/blob/cf9d7a2ee20c8a4706a05d1d7f1a1e25ae32ed39/xenial/Dockerfile)
- `16.10`, `yakkety-20161121`, `yakkety`[ (*yakkety/Dockerfile*)](https://github.com/tianon/docker-brew-ubuntu-core/blob/cf9d7a2ee20c8a4706a05d1d7f1a1e25ae32ed39/yakkety/Dockerfile)
- `17.04`, `zesty-20161129.1`, `zesty`, `devel` [(*zesty/Dockerfile*)](https://github.com/tianon/docker-brew-ubuntu-core/blob/cf9d7a2ee20c8a4706a05d1d7f1a1e25ae32ed39/zesty/Dockerfile)


#### [Centos](https://hub.docker.com/_/centos/)

Supported tags and respective `Dockerfile` links

- `latest`, `centos7`, `7`[ (*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/155416b523b3353f97015f1942bab8152992a689/docker/Dockerfile)
- `centos6`, `6` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/83a75fbb40f80935d91b876115704f6e12334575/docker/Dockerfile)
- `centos5`, `5` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/4bf8330498e1c10cf365aff31d2a8a5c3254c2cf/docker/Dockerfile)
- `centos7.2.1511`, `7.2.1511` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/a3c59bd4e98a7f9c063d993955c8ec19c5b1ceff/docker/Dockerfile)
- `centos7.1.1503`, `7.1.1503` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/bc561dfdd671d612dbb9f92e7e17dd8009befc44/docker/Dockerfile)
- `centos7.0.1406`, `7.0.1406` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/f1d1e0bd83baef08e257da50e6fb446e4dd1b90c/docker/Dockerfile)
- `centos6.8`, `6.8` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/f32666d2af356ed6835942ed753a4970e18bca94/docker/Dockerfile)
- `centos6.7`, `6.7` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/d0b72df83f49da844f88aabebe3826372f675370/docker/Dockerfile)
- `centos6.6`, `6.6` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/8911843d9a6cc71aadd81e491f94618aded94f30/docker/Dockerfile)
- `centos5.11`, `5.11` [(*docker/Dockerfile*)](https://github.com/CentOS/sig-cloud-instance-images/blob/2d0554464ae19f4fd70d1b540c8968dbe872797b/docker/Dockerfile)


#### [Windows](https://hub.docker.com/u/microsoft/)

##### Windows Server 2016 Server Core

```shell
# Windows Server 2016 Server Core base OS image for Windows containers
$ docker pull microsoft/windowsservercore

# The official Docker images for .NET Framework on Windows Server 2016 Server Core
$ docker pull microsoft/dotnet-framework

# Internet Information Services (IIS) installed in a Windows Server Core based container
$ docker pull microsoft/iis

# ASP.NET is an open source server-side Web application framework
# 	Windows Server Core as the base OS
# 	IIS 10 as Web Server
# 	.NET Framework 4.6.2 (or 3.5)
# 	.NET Extensibility for IIS
$ docker pull microsoft/aspnet

# Official images for Microsoft SQL Server for Windows Containers
$ docker pull microsoft/mssql-server-windows
# Official images for Microsoft SQL Server Express for Windows Containers
$ docker pull microsoft/mssql-server-windows-express
```

##### Windows Server 2016 Nano Server

```shell
# Windows Server 2016 Nano Server base OS image for Windows containers
$ docker pull microsoft/nanoserver
$ docker pull microsoft/dotnet:nanoserver
```

##### Linux

```shell
# Official images for .NET Core for Linux (debian)
$ docker pull microsoft/dotnet

# Official images for building ASP.NET Core applications
# 	.NET Core SDK so that you can create, build and run your .NET Core applications.
# 	A NuGet package cache for the ASP.NET Core libraries. 
# 	Node.js
# 	Bower
# 	Gulp
$ docker pull microsoft/aspnetcore-build

# Official images for running compiled ASP.NET Core applications
$ docker pull microsoft/aspnetcore

# .NET Core Docker Samples
$ docker pull microsoft/dotnet-samples

# CNTK
$ docker pull microsoft/cntk

# Monitor your containers using the Operations Management Suite (OMS). For minimal OS like CoreOS.
# Supported Linux Operating Systems, Docker, and ACS Mesosphere DC/OS:
# 	Docker 1.10 thru 1.12.1
# 	An x64 version of Linux OS
# 		Ubuntu 14.04 LTS, 16.04 LTS
# 		CoreOS(stable)
# 		Amazon Linux 2016.09.0
# 		openSUSE 13.2
# 		CentOS 7
# 		SLES 12
# 		RHEL 7.2
# 	ACS Mesosphere DC/OS 1.7.3, 1.8.4
$ docker pull microsoft/oms
```

### Web服务

**Nginx何时取代Apache？**

Nginx和Apache都是流行的开源Web服务器。Apache是世界使用排名第一的Web服务器软件，是Apache软件基金会的一个开源Web服务器，几乎所有的计算机平台都可以运行，由于其开放的API接口，使得Apache有超多的模块，基本想到的都可以找到；加之历史悠久，因此相关文档齐全，因此，长期雄踞Web服务器市场的巅峰。

而Nginx最初是俄罗斯程序员Igor Sysoev开发的轻量级开源Web服务器，同时也是一个反向代理服务器和电子邮件代理服务器，并在一个BSD-like协议下发行。

![img](http://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VN2G1VqmdpBhBQymVBicia7ia8x2ROagx8n0K3JXJEdOfM3P995iaaU8GEBZ7yAMfV9FYTXOrRVezEV6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

Apache是顶级的Web服务器，但是Nginx持续增长，而Microsoft IIS几十年来首次下降到10％以下。

用户自然会关心，Nginx会不会取代Apache，以及何时能取代Apache？Nginx首席执行官Gus Robertson近日就表示，这两者的使用场景并不同，并不存在谁取代谁的问题。

Nginx已经成为第二大Web服务器。它很久以前就超越了微软的Internet Information Services（IIS），长期以来，它一直逼近顶级Web服务器Apache。但是，Nginx首席执行官Gus Roberston在接受采访时表示，Apache和Nginx的用户范围并不相同。

Robertson表示：「我认为Apache是一个卓越的Web服务器。但Nginx和它不是一个相同的使用案例。我们不认为Apache是一个竞争对手，我们的客户使用Nginx来替换硬件负载均衡和构建微服务，这两者都不是Apache干的事。」

事实上，Roberston发现许多用户同时使用两个开源Web服务器，他说，客户在Apache的前端使用Nginx进行负载平衡和应用，它们的架构完全不同，可以提供更好的并发性能。他还表示，在云配置方面，Nginx表现会更好。

Roberston总结道：「我们（Nginx）是唯一仍在增长的Web服务器，而其他Web服务器正在萎缩。」

然而这不是事实。根据10月份Netcraft的Web服务器调查

https://news.netcraft.com/archives/2016/10/21/october-2016-Web-server-survey.html

Apache本月活跃网站增长最多，获得180万；而Nginx增长40万，仅次于Apache。

这些增长，加上微软损失的120万活跃网站，导致微软的活跃网站份额下降到9.27％，首次跌至10％以下。Apache在市场份额提高了0.19%，并继续占据主导地位，现在拥有46.30％的活跃网站。尽管如此，多年来Apache一直在慢慢下降，而Nginx现在只有19％。

目前，Nginx的开发人员正在继续改进开放核心商业网络服务器Nginx Plus，以求提高其竞争力。Web服务器使用最新版本的Nginx Plus Release 11（R11），更易于扩展和自定义，并支持更广泛的部署。

最大的提升是动态模块（dynamic modules）的二进制兼容性。这意味着为开源Nginx软件编译的动态模块可以加载到Nginx Plus中。

还意味着开发人员可以利用大量的第三方Nginx模块来扩展和添加功能到Nginx Plus，从一系列开源模块到商业模块。开发人员可以基于支持的Nginx Plus核心创建自定义扩展、附加组件和新产品。

Nginx Plus R11还增加了其他增强功能：

- 改进的TCP/UDP负载平衡：新功能包括SSL服务器名称路由、新的日志功能、附加变量和改进的Proxy协议支持。这些新功能增强了调试功能，使开发者能够支持更广泛的企业应用程序。
- 通过IP地址更好地进行地理定位：第三方GeoIP2模块现已通过认证，并提供给Nginx Plus客户。相比原始GeoIP模块，新版本提供了更为本地化和更丰富的位置详细信息。
- 增强的nginScript模块：nginScript是基于JavaScript的Nginx Plus的下一代配置语言。开发者能使用新功能在Stream（TCP/UDP）模块中即时修改请求和响应数据。

可以预见的是，在这场旷日持久的角逐顶级Web服务器的战争中，Nginx会同Apache进行激烈的竞争。而微软的IIS，则继续缓慢地衰落，走向消亡。

#### [Apache HTTP Server](https://hub.docker.com/_/httpd/)

```shell
# The Apache HTTP Server Project
$ docker pull httpd
$ docker pull httpd:alpine

$ docker run -dit --name my-apache-app -v "$PWD":/usr/local/apache2/htdocs/ httpd:alpine
```

#### [Apache Tomcat](https://hub.docker.com/_/tomcat/)

```shell
# Apache Tomcat is an open source implementation of the Java Servlet and JavaServer Pages technologies
$ docker pull tomcat
$ docker pull tomcat:alpine

$ docker run -it --rm -p 8888:8080 tomcat:alpine
```

#### [Nginx](https://hub.docker.com/_/nginx/)

```shell
$ docker pull nginx
$ docker pull nginx:alpine

# hosting some simple static content
$ docker run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d -p 8080:80 nginx:alpine
```



### 数据库

#### [Mysql](https://hub.docker.com/_/mysql/)

```shell
# MySQL is a widely used, open-source relational database management system (RDBMS).
$ docker pull mysql

# 运行MySQL
$ docker run --name mysqlD -e MYSQL_ROOT_PASSWORD=Pass@word8 -d mysql

# Connect to MySQL from an application in another Docker container
$ docker run --name some-app --link mysqlD:mysql -d application-that-uses-mysql

# Connect to MySQL from the MySQL command line client
$ docker run -it --link some-mysql:mysql --rm mysql sh -c 'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'

$ docker run -it --rm mysql mysql -hsome.mysql.host -usome-mysql-user -p

# Container shell access and viewing MySQL logs
$ docker exec -it mysqlD bash
$ docker logs mysqlD
```

#### SQL Server

```shell
# 启动Linux版 SQL Server
$ docker pull microsoft/mssql-server-linux
$ docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Pass@word8' -p 1433:1433 -v /B/mssql -d microsoft/mssql-server-linux
# 使用sqlcmd连接数据库
$ sqlcmd -S localhost -U SA -P 'Pass@word8'

# 安装sqlcmd
# for Ubuntu
$ curl https://packages.microsoft.com/keys/microsoft.asc | apt-key add -
$ curl https://packages.microsoft.com/config/ubuntu/16.04/prod.list | tee /etc/apt/sources.list.d/msprod.list
$ apt-get update 
$ apt-get install mssql-tools

# for CentOS
$ curl https://packages.microsoft.com/config/rhel/7/prod.repo > /etc/yum.repos.d/msprod.repo
$ yum install mssql-tools
```

SQL测试

```mssql
SELECT Name from sys.Databases;
GO

CREATE DATABASE testdb;
GO

USE testdb;
GO

CREATE TABLE inventory (id INT, name NVARCHAR(50), quantity INT);
GO

INSERT INTO inventory VALUES (1, 'banana', 150);
INSERT INTO inventory VALUES (2, 'orange', 154);
GO

SELECT * FROM inventory WHERE quantity > 152;
GO

QUIT
```

#### [PostgreSQL](https://hub.docker.com/_/postgres/)

```shell
# 拉取官方镜像最新版本
$ docker pull postgres
# 最小Linux版
$ docker pull postgres:alpine 
# 运行容器
$ docker run --name postgresBLK -e POSTGRES_PASSWORD=Pass@word8 -d postgres
# EXPOSE 5432 (the postgres port)
# POSTGRES_PASSWORD
# POSTGRES_USER postgres
# PGDATA /var/lib/postgresql/data
# POSTGRES_DB POSTGRES_USER
# POSTGRES_INITDB_ARGS  # postgres initdb arguments # -e POSTGRES_INITDB_ARGS="--data-checksums".
# psql连接数据库
$ docker run -it --rm --link postgresBLK:postgres postgres psql -h postgres -U postgres
# 应用程序连接数据库
$ docker run --name postgresTest --link postgresBLK:postgres -d centos
```

PSQL

```plsql
SELECT 1;
```

#### [Mongo](https://hub.docker.com/r/_/mongo/)

```shell
# MongoDB document databases provide high availability and easy scalability.
$ docker pull mongo
$ docker pull mongo:windowsservercore

# EXPOSE 27017 (the mongo port)
$ docker run --name some-mongo -d mongo

# connect to it from an application
$ docker run --name some-app --link some-mongo:mongo -d application-that-uses-mongo
# via mongo
$ docker run -it --link some-mongo:mongo --rm mongo sh -c 'exec mongo "$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test"'
```

#### [Redis](https://hub.docker.com/_/redis/)

```shell
# Redis is an open source key-value store that functions as a data structure server.
$ docker pull redis
$ docker pull redis:alpine

# start a redis instance
$ docker run --name some-redis -d redis

# start with persistent storage
$ docker run --name some-redis -d redis redis-server --appendonly yes

# connect to it from an application
$ docker run --name some-app --link some-redis:redis -d application-that-uses-redis
# ... or via redis-cli
$ docker run -it --link some-redis:redis --rm redis redis-cli -h redis -p 6379
```



### 开发环境

#### [Python](https://hub.docker.com/_/python/)

```shell
# python3
$ docker pull python
$ docker pull python:alpine
$ docker pull python:windowsservercore
# python2
$ docker pull python:2
$ docker pull python:2-alpine

# 运行
$ docker run -it --rm python:alpine
$ docker run -it --rm python:2-alpine

# 运行Python3脚本
$ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/myapp -w /usr/src/myapp python:alpine python your-daemon-or-script.py
# 运行Python2脚本
$ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/myapp -w /usr/src/myapp python:2-alpine python your-daemon-or-script.py
```

#### [OpenJdk](https://hub.docker.com/_/openjdk/)

```shell
# OpenJDK is an open-source implementation of the Java Platform, Standard Edition
$ docker pull openjdk
$ docker pull openjdk:jre
$ docker pull openjdk:alpine
$ docker pull openjdk:jre-alpine

# Compile your app inside the Docker container
$ docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp openjdk:alpine javac Main.java
```

#### [php](https://hub.docker.com/_/php/)

```shell
# While designed for web development, the PHP scripting language also provides general-purpose use.
$ docker pull php
$ docker pull php:alpine
$ docker pull php:apache

# Run a single PHP script
$ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/myapp -w /usr/src/myapp php:alpine php your-script.php
```

#### [Node](https://hub.docker.com/_/node/)

```shell
# Node.js is a JavaScript-based platform for server-side and networking applications.
$ docker pull node
$ docker pull node:alpine

# Run a single Node.js script
$ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/app -w /usr/src/app node:alpine node your-daemon-or-script.js
```

#### [Ruby](https://hub.docker.com/_/ruby/)

```shell
# Ruby is a dynamic, reflective, object-oriented, general-purpose, open-source programming language.
$ docker pull ruby
$ docker pull ruby:alpine

# Generate a Gemfile.lock
$ docker run --rm -v "$PWD":/usr/src/app -w /usr/src/app ruby:alpine bundle install

# Run a single Ruby script
$ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/myapp -w /usr/src/myapp ruby:alpine ruby your-daemon-or-script.rb
```

#### [Go (golang)](https://hub.docker.com/r/_/golang/)

```shell
# Go (golang) is a general purpose, higher-level, imperative programming language.
$ docker pull golang
$ docker pull golang:alpine
$ docker pull golang:windowsservercore
$ docker pull golang:nanoserver

# Compile your app inside the Docker container
$ docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp golang:alpine go build -v
$ docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp golang:alpine bash -c make

# Cross-compile your app inside the Docker container
$ docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp -e GOOS=windows -e GOARCH=386 golang:alpine go build -v
```

#### [Perl](https://hub.docker.com/_/perl/)

```shell
# Perl is a high-level, general-purpose, interpreted, dynamic programming language.
$ docker pull perl
$ docker pull perl:threaded

# Run a single Perl script
$ docker run -it --rm --name my-running-script -v "$PWD":/usr/src/myapp -w /usr/src/myapp perl perl your-daemon-or-script.pl
```

[Bash](https://hub.docker.com/_/bash/)

```shell
# Bash is the GNU Project's Bourne Again SHell
$ docker pull bash

# Interactive shell
$ docker run -it --rm bash
# Testing scripts via bind-mount
$ docker run -it --rm -v /path/to/script.sh:/script.sh:ro bash bash /script.sh
```

### 平台

#### [Elasticsearch](https://hub.docker.com/r/_/elasticsearch/)

```shell
# Elasticsearch is a powerful open source search and analytics engine that makes data easy to explore.
$ docker pull elasticsearch

# includes EXPOSE 9200 9300 (default http.port)
$ docker run -d elasticsearch
# You can also pass in additional flags to elasticsearch:
$ docker run -d elasticsearch -Des.node.name="TestNode"
# comes with a default set of configuration files for elasticsearch
$ docker run -d -v "$PWD/config":/usr/share/elasticsearch/config elasticsearch
# configured with a volume at /usr/share/elasticsearch/data to hold the persisted index data. 
$ docker run -d -v "$PWD/esdata":/usr/share/elasticsearch/data elasticsearch
```

#### [Jenkins](https://hub.docker.com/_/jenkins/)

```shell
# The Jenkins Continuous Integration and Delivery server.
$ docker pull jenkins
$ docker pull jenkins:alpine

$ docker run --name myjenkins -p 8080:8080 -p 50000:50000 -v /your/home:/var/jenkins_home jenkins
```

#### [webcenter](https://hub.docker.com/u/webcenter/)/[activemq](https://hub.docker.com/r/webcenter/activemq/)

```shell
# ActiveMQ 5.13.2 with OpenJDK-jre-8-headless on Ubuntu 15.10 (full documented)
$ docker pull webcenter/activemq

$ docker run --name='activemq' -it --rm \
    -e 'ACTIVEMQ_MIN_MEMORY=512' \
    -e 'ACTIVEMQ_MAX_MEMORY=2048'\
        -P
    webcenter/activemq:latest
```

#### [RabbitMQ](https://hub.docker.com/_/rabbitmq/)

```shell
# RabbitMQ is a highly reliable enterprise messaging system based on the emerging AMQP standard
$ docker pull rabbitmq
$ docker pull rabbitmq:management

$ docker run -d --hostname my-rabbit --name some-rabbit rabbitmq
```

#### [Memcached](https://hub.docker.com/_/memcached/)

```shell
# Free & open source, high-performance, distributed memory object caching system.
$ docker pull memcached
$ docker pull memcached:alpine

# 运行
$ docker run --name my-memcache -d memcached memcached -m 64
# 容器连接
$ docker run --link my-memcache:memcache -d my-app-image
```

#### [HAProxy](https://hub.docker.com/_/haproxy/)

```shell
# HAProxy - The Reliable, High Performance TCP/HTTP Load Balancer
$ docker pull haproxy
$ docker pull haproxy:alpine

# Directly via bind mount
$ docker run -d --name my-running-haproxy -v /path/to/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro haproxy:1.5
# Reloading config
# If you used a bind mount for the config and have edited your haproxy.cfg file, 
# you can use haproxy's graceful reload feature by sending a SIGHUP to the container:
$ docker kill -s HUP my-running-haproxy
```

#### [Docker in Docker](https://hub.docker.com/_/docker/)

```shell
# Docker in Docker!
$ docker pull docker

# Start a daemon instance
# IMPORTANT: this image defaults to --storage-driver=vfs, which will be very slow and inefficient (but is the only driver which is guaranteed to work regardless of your underlying filesystem). Which driver you should use varies depending on your needs, but a good rule of thumb is that your DinD instance should be using the same driver as your host (which can be seen under Storage Driver in the output of docker info). See the "Custom daemon flags" section below for how to specify your storage driver.
$ docker run --privileged --name some-docker -d docker
# Note: --privileged is required for Docker-in-Docker to function properly, but it should be used with care as it provides full access to the host environment, as explained in the relevant section of the Docker documentation.
```

#### [Zookeeper](https://hub.docker.com/_/zookeeper/)

```sh
# Apache ZooKeeper is an open-source server which enables highly reliable distributed coordination.
$ docker pull zookeeper

# Start a Zookeeper server instance
$ docker run --name some-zookeeper --restart always -d zookeeper
# This image includes EXPOSE 2181 2888 3888 (the zookeeper client port, follower port, election port respectively), so standard container linking will make it automatically available to the linked containers. Since the Zookeeper "fails fast" it's better to always restart it.

# Connect to Zookeeper from an application in another Docker container
$ docker run --name some-app --link some-zookeeper:zookeeper -d application-that-uses-zookeeper
# Connect to Zookeeper from the Zookeeper command line client
$ docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper
```

#### [Storm](https://hub.docker.com/_/storm/)

```shell
# Apache Storm is a free and open source distributed realtime computation system.
$ docker pull storm

# Running topologies in local mode
# Assuming you have storm-starter-topologies-1.0.2.jar in the current directory.
$ docker run -it -v $(pwd)/storm-starter-topologies-1.0.2.jar:/topology.jar storm storm jar /topology.jar org.apache.storm.starter.ExclamationTopology
```

#### [sequenceiq](https://hub.docker.com/u/sequenceiq/)/[hadoop-docker](https://hub.docker.com/r/sequenceiq/hadoop-docker/)

```shell
# An easy way to try Hadoop 
# Apache Hadoop 2.7.0 Docker image
$ docker pull sequenceiq/hadoop-docker

# run 
$ docker run -it sequenceiq/hadoop-docker /etc/bootstrap.sh -bash
```



---

# Docker桌面系统

Docker自家的美女程序员『杰西·弗莱泽尔（Jessie Frazelle）』

https://blog.jessfraz.com/post/docker-containers-on-the-desktop/

https://github.com/jessfraz/dockerfiles.git

```shell
docker run -it -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=unix$DISPLAY jess/chrome
```

## X11

在X11协议中，分为X11服务端和X11客户端两个部分。X11服务端是用于驱动具体显示硬件将数据进行展示的模块，而X11客户端则接收应用程序和用户的操作，并产生刷新屏幕信息的命令发送给服务端。服务端与客户端可以是在同一个主机上，也可以通过网络相连。如下图所示：

![img](http://cdn2.infoqstatic.com/statics_s1_20170117-0322_1/resource/articles/talk-about-docker-running-the-chinese-gui-software/zh/resources/0812000.png)

在X11的通信协议中有一个十分重要的变量：`DISPLAY`。这个变量能够决定X11的服务端怎样监听来自客户端的控制指令。DISPLAY的格式是`unix:端口`或`主机地址:端口`，前一种格式表示使用本地的UNIX套接字，后一种表示使用TCP套接字。换句话说，前一种适用于X11服务端和客户端在同一个主机上的情况，而后一种适用于X11服务端与客户端分布在不同主机的情况。

### 将容器中的图形界面展示到外部的一般性思路。

目前Unix/Linux比较主流的图形界面服务是X11，而X11服务的图形显示方式实际上是一种Client/Server模式，在服务端和客户端之间，X11通过『DISPLAY』环境变量来指定将图形显示到何处。如下面的流程所示，请注意服务端与客户端的位置，服务端是用于提供显示信息的。

[应用程序]->[X11客户端]->[X11服务端]->[显示屏幕]

DISPLAY的格式是『unix:端口』或『主机名:端口』，前一种格式表示使用本地的unix套接字，后一种表示使用tcp套接字。

默认情况下，X11的服务端会监听本地的『unit:0』端口，而DISPLAY的默认值为『:0』，这实际上是『unit:0』的简写。因此如果在Linux的控制台启动一个图形程序，它就会出现在当前主机的显示屏幕中。

基于这个原理，将Docker中的GUI程序显示到外面，就是通过某种方式把X11的客户端的内容从容器里面传递出来。基本的思路无非有两种：

1. 通过SSH连接或远程控制软件，最终通过tcp套接字将数据发送出来
2. 让容器和主机共享X11的unix套接字，直接将数据发送出来

从应用场景上划分，又可以分成两类情况：『运行本地的GUI程序』和『运行远程服务器上的GUI程序』。这两类情况在操作上很相似，但前者可以使用unix套接字，而后者必然要使用tcp套接字转发，原理上有很大差别。先说本地运行GUI程序的情况。

以Jessie在Docker开发者大会上做的第一个演示『LibreOffice』为例。这个镜像的Dockerfile代码和使用方法都已经[开源在Github](https://github.com/jfrazelle/dockerfiles/blob/master/libreoffice/Dockerfile)上了。

## Xvfb

`Xvfb`的全称是“X virtual frame buffer”，是一种X11服务端的特殊实现。说比较特殊是因为Xvfb不需要实际的显示装置和硬件驱动，它将渲染的图像内容保存在内存中，最初的应用场景主要是用于自动化测试等不需要看到执行界面的地方，作为完整X服务的替代。

`Xvfb`的所有文件放在一起只有大约10MB的大小（加上一些额外依赖的包，实际增加镜像的体积大概在几十MB）。这样一种轻量级的X11服务器用在Docker里面使用实在是在合适不过了，此外，`Xvfb`也与CoreOS不支持图形显示、没有显示器驱动的情况十分契合。

## X11vnc

`X11vnc`提供了将X11服务端内容获取出来并展现到远程的用户控制端的功能。

在X11的通信协议中有一个十分重要的变量：`DISPLAY`。这个变量能够决定X11的服务端怎样监听来自客户端的控制指令。DISPLAY的格式是`unix:端口`或`主机地址:端口`，前一种格式表示使用本地的UNIX套接字，后一种表示使用TCP套接字。换句话说，前一种适用于X11服务端和客户端在同一个主机上的情况，而后一种适用于X11服务端与客户端分布在不同主机的情况。

在这个方案中，咋看起来CoreOS不具备显示设备和显卡驱动，显示的内容展现在远端的用户屏幕中，似乎应该使用后一种地址格式。然而，实际上`X11vnc`虽然将数据传送到了远程的展现端，但它本身却是X11的客户端。正如`X11vnc`的名字所体现的，它在这个过程中扮演了一个中介者的角色，将`Xvfb`服务在Docker容器中通过X11协议传输的显示数据获取后，再通过另一种VNC远程控制协议将这些数据转发出来，而用户操作的是一个VNC协议的客户端。因此，对于X11的部分来说，它的服务端和客户端运行在同一个主机上（也就是同一个容器里），`DISPLAY`的变量值应该使用本地的任意UNIX端口地址。这个通信流程如下图所示：

![img](http://cdn2.infoqstatic.com/statics_s1_20170117-0322_1/resource/articles/talk-about-docker-running-the-chinese-gui-software/zh/resources/0812001.png)

虽然用户无法直接看到Xvfb的图形渲染结果，但`Xvfb`的确在内存里实实在在存放了实际的图像数据。`Xvfb`服务在运行程序时通过`DISPLAY`变量的值监听X11服务请求，而`X11vnc`服务在运行时则通过`DISPLAY`变量的值（也可以通过`-display`参数传入）获取X11图形数据并转发到VNC客户端。

和X11协议相似，VNC协议也同时支持的图像数据和控制指令的双向传输。这种协议设计出来就是为了做远程控制的，它最初用于AT&T的欧洲研究实验室开发的的同名软件VNC，全称是“虚拟网络计算机”（Virtual Network Computer）。它在Windows、Linux、Mac甚至手机系统上都有客户端，因此实施起来十分方便。

## Flutbox

Fluxbox is a windowmanager for X that was based on the Blackbox 0.61.1 code. It is very light on resources and easy to handle but yet full of features to make an easy, and extremely fast, desktop experience. It is built using C++ and licensed under the [MIT-License](http://en.wikipedia.org/wiki/MIT_License)

Fluxbox is supplied with lots of native options such as **tabbing, grouping, a long list of keycommands, Chainable Keygrabber, fully editable menu and much, much more**. You might want to dive into it and [learn more about fluxbox's features](http://fluxbox.org/features/).

## Xpra

Xpra is 'screen for X' & allows you to run X programs, usually on a remote host over SSH or encrypted tcp.

Xpra是一个允许你本地显示一个窗口的工具，该窗口的显示的是在远端主机上运行的X Clients。它不同于X转发，它能在不打断远端进程的同时断开或者重连远端主机。它也不同于VNC，通过xpra，远端的应用能被本地的窗口管理其当作一个普通的桌面应用进行管理，而不像VNC只能在vncviewer或类似软件（如上文中的浏览器）中显示。

## Xephyr

Xephyr 是一个 Xserver，但是它执行在一个存在的 X server 里面，这个可以用来做很多事情，比如需要通过 XDMCP 连接到另外一台主机，那么不需要另外打开一个新的 X server；又比如正在写一个 window manager，那么在一个 X server 里面打开的 X server 里面调试，将会比直接在现有的 X server 里面替换现有的 window manager 方便很多。

## noVNC

VNCServer 是一个为了满足分布式用户共享服务器资源，而在服务器开启的一项服务，对应的客户端软件有图形化客户端 VNCViewer，而 noVNC 则是 HTML5 VNC 客户端，它采用 HTML5 WebSockets，Canvas 和 JavaScript 实现。

noVNC 被普遍用在各大云计算、虚拟机控制面板中，比如 OpenStack Dashboard 和 OpenNebula Sunstone 都用的是 noVNC。noVNC 采用 WebSockets 实现，但是当前蛮多 VNC 服务器都不支持 WebSockets，所以 noVNC 不能直连 VNC 服务器，而是需要开启一个代理来做 WebSockets 和 TCP sockets 之间的转换。这个代理叫做 websockify。

## ssh + Xpra

```shell
# 安装镜像：rogaha/docker-desktop
$ sudo docker pull rogaha/docker-desktop

# 自主构建
$ git clone https://github.com/rogaha/docker-desktop.git
$ cd docker-desktop
$ docker build -t tinylab/docker-desktop .

# 启动容器
$ CONTAINER_ID=$(sudo docker run -d -p 2222:22 rogaha/docker-desktop)
# 注：-p 2222:22 把容器内的 Ssh 端口地址 22 映射到主机的 2222 端口。

# 获取登陆密码
$ echo $(sudo docker logs $CONTAINER_ID | sed -n 1p)
# 该镜像通过 pwgen 随机产生了一个登陆密码，见 startup.sh。

# 通过 Ssh 启动一个 Xpra 会话
$ ssh docker@localhost -p 2222 "sh -c './docker-desktop -s 800x600 -d 10 > /dev/null 2>&1 &'"
# -p 2222 连上 docker 那边的 ssh 服务
# -s 800x600 设置桌面的分辨率
# -d 10 设置显示服务会话编号

# 通过 Xpra Attach 上述会话
$ xpra --ssh="ssh -p 2222" attach ssh:docker@0.0.0.0:10
```

## VNCServer + noVNC

```shell
# 下载镜像：fcwu/docker-ubuntu-vnc-desktop
$ docker pull fcwu/docker-ubuntu-vnc-desktop

# 自主构建
$ git clone https://github.com/fcwu/docker-ubuntu-vnc-desktop.git
$ cd docker-ubuntu-vnc-desktop
$ docker build -t novnc-desktop .

# 启动容器并加载 VNCServer 服务
$ CONTAINER_ID=$(docker run -d -p 6080:6080 dorowu/ubuntu-desktop-lxde-vnc)

# 获得登录密码
$ docker logs $CONTAINER_ID | sed -n 1p
User: ubuntu Pass: ubuntu

# 通过浏览器登录
# 宿主机访问：http://localhost:6080/vnc.html
# 先获取 IP 地址
$ docker exec $CONTAINER_ID ifconfig eth0 | grep "inet addr:"
inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
# 远程访问：http://172.17.0.1:6080/vnc.html
```



# LinuxKit

## LinuxKit项目介绍：一个构建安全、精简和可移植的Linux子系统的工具包

原创 2017-04-22 钟最龙 译 [Docker](##) Docker



去年我们听到来自用户的一个最多的请求是将Docker原生的体验带到他们的平台上。这些平台数量众多且各有不同，从云平台如AWS、Azure和Google Cloud，到服务器平台如Windows Server，到开发者使用的桌面平台如OSX和Windows 10，再到大型主机和物联网平台，诸如此类的例子还有很多。

于是我们开始了对这些平台支持的工作，我们起初发布了Docker for Mac和Docker for Windows，接着我们发布了Docker for AWS和Docker for Azure。我们最近又发布了Docker for GCP的Beta版本。我们在每一个平台上做的使Docker原生化的定制，都推动了相关Docker版本的采用。

我们遇到的一个问题是这些平台的很多用户想要有Linuxcontainer的支持，但是这些平台自身却不带有Linux。MacOS和Windows是两个很明显的例子。平台也有可能包含了一个不标准的Linux。所以为了要（让Linuxcontainer）在这些平台上运行，在Docker平台中捆绑Linux是一个合理的做法。

我们需要打包的是一个安全、精简和可移植的Linux子系统，它能提供Linux容器的功能，并能作为容器平台的一个组件。我们也发现，这也正是很多其他和容器打交道的人想要的功能：他们想有一个安全、精简和可移植的Linux子系统以便于容器的移动。所以在构建这个组件过程中，我们与几个公司以及Linux基金会进行了合作。这些公司包括HPE、Intel、ARM、IBM和Microsoft，它们都有兴趣将Linux容器的功能带到新的不同平台中，从物联网到大型主机。

LinuxKit包含的工具集能允许构建自定义的只包含运行时平台必需组件的Linux子系统。所有的系统服务都是可以被替换的容器，它们中一切不必要的都可以被移除。所有的组件都可以被满足（相同）特定需求的组件替换。它是一个工具集，与Docker的“自带电池但允许更换”的哲学很像。今天在Dockercon 2017的舞台上，我们开源了LinuxKit，地址在http://github.com/linuxkit/linuxkit。

为了达到构建一个安全、精简和可移植的操作系统的目标，我们采取了“==一切使用容器构建，一切为了运行容器==”的构建方法。安全是最高的目标，符合国家标准与技术协会（NIST）在“应用容器安全指南”草案中陈述的：“使用容器特定的操作系统而不是一个用途广泛的操作系统来减少攻击面。当使用一个容器特定的操作系统时，攻击面通常比用一个用途广泛的操作系统的攻击面要小很多，因此容器特定操作系统受到攻击以及被攻陷的几率都要小”。

如果操作系统是围绕着容器设计的，通过移除不需要的部分，精简化直接有助于提升安全性。因为LinuxKit是容器原生的，它有着极小的体积 - 35MB，而且启动时间也极短。所有的系统服务都是容器，意味着一切都可以移除和替换。

系统服务都在容器中被沙箱隔离，只拥有它们所必需的特权。配置是针对容器使用场景而设计的。整个系统是构建来用作一个不可变的基础设施，因此它可以通过持续集成的流水线来构建和测试、部署或者在你希望升级时重新部署新版本。

内核来自于和Linux内核社区的协作。我们参与了相关小组如KSPP（内核自我保护项目）的流程和工作，并发布了一些最新的一些内核，只包含最少的与LinuxKit支持平台相关问题的补丁。内核安全的流程太大，任何一个公司要独自开发太难，因此有必要进行行业协作。

另外，LinuxKit提供了一个空间来孵化有望提升Linux安全性的项目。我们正在和外部的项目合作，如Wireguard、Landlock、Mirage、oKernel、ClearContainer和更多的其他项目，并且集中关注容器的领域的创新，以及通往生产的途径。

LinuxKit是可移植的，正如它是为很多目前运行着Docker的平台打造的一样，同时它有要在更多的平台上运行的眼光，随着容器深入到计算的各个领域，不论它们是或大或小的机器，物理裸机或者是虚拟机，大型主机或者用于物联网场景的设备。

在发布的时候，我们邀请了微软的John Gossman到舞台，我们和Microsoft有长的合作历史，从Docker for Windows Server、Docker for Windows到Docker for Azure。合作的一部分内容是Docker for Windows和Docker for Azure中的Linux子系统，以及在这些平台上Hyper-V和LinuxKit的整合。今天我们公布的下一步合作内容是所有的Windows Server和Windows 10客户都将能使用Linux容器，并且我们正在一起努力将 LinuxKit和Hyper-v隔离进行整合。

今天我们将LinuxKit开放给合作伙伴和开源的爱好者，希望能推动使用Linux构建新的伟大，促进容器平台的扩展。我们也期待你能从中受益，并最终回馈社区。



# Moby

## Moby项目介绍：一个新的用于推进软件容器化运动的开源项目

原创 2017-04-21 梁晓勇 译 [Docker](##) Docker



从四年前Docker普及软件容器开始，围绕容器化的一整个生态系统成长了起来，并在这有限的时间段里经历了两个截然不同的成长阶段。在这两个阶段中，用于生产容器系统的模型在不断演进，以适应用户社区、项目及日益壮大的贡献者生态系统的数量和需求。

Moby项目是一个新的用于推进软件容器化运动的开源项目，它将协助生态系统让容器成为主流。它提供了一个组件库、一个用于将这些组件组装成基于定制容器的系统的框架，以及一个所有容器爱好者进行试验和交流想法的场所。

下面来回顾一下我们是如何走到今天这步的。在2013-2014年之间，先驱者们开始使用容器并在一个庞大的开源代码库（Docker及其他一些项目）中协作以帮助这些工具成熟起来。



接着在2015-2016年之间，容器被大规模应用到了原生云应用程序的生产环境中。在这个阶段，在数百个生态系统项目及数千个贡献者的支持下，用户社区迅速增长到足以支撑成千上万的部署。也就是在这个阶段中，Docker将生产模型转变成了一个基于开放组件的方案。通过这种方式，让我们可以同时提升创新和协作的表面积。

有助于合作方生态系统及用户社区成长的新的独立的Docker组件项目迅速崛起。在这段时间中，我们将各个组件从Docker代码库中剥离并快速进行创新，以便系统制作者们可以在构建自己的容器系统时独立地重用它们，比如runc、HyperKit、VPNKit、SwarmKit、InfraKit、containerd等等。



处在容器浪潮的最前沿，我们看到2017年新兴的一个趋势是容器正在成为主流，它广泛地传播到了计算的各个类型中：服务器、数据中心、云服务、台式机、物联网及移动设备；涉及每个行业和垂直市场：金融业、医疗业、政府、旅游业、制造业；以及每个用例：先进的Web应用程序、传统的服务器应用程序、机器学习、工业控制系统、机器人。在容器生态系统中，很多新加入者的共同点在于他们针对某个特定的基础设施、行业或用例构建了特有的系统。

作为一个公司，Docker以开源作为创新实验室与整个生态系统进行协作。Docker的成功与容器生态系统的成功密不可分：只要生态系统成功了，我们就成功了。因此我们一直在规划容器生态系统成长的下一个阶段：什么样的生产环境模型可以帮助我们扩展容器生态系统以实现将容器作为主流的承诺？

去年，我们的客户开始寻求Linux之外其他平台上的Docker方案：Mac和Windows桌面版、Windows服务器版，以及类似亚马逊AWS、微软Azure或谷歌云的云平台，而我们也创建了针对这些平台的多个Docker版本。为了让这些特定版本能在一个相对短的时间内，以小团队、可扩展的方式完成构建和交付，而无须重新发明轮子，很明显我们需要一个新的方案。我们借鉴了汽车行业中通过组装可重用组件以构建完全不同的车型的主意，要求我们的团队不仅要在组件上协作，也要在组件的组装上进行协作。



我们认为扩展容器生态系统进入下一层次，从而让容器进入主流的最好办法是在生态系统层次进行组装的协作。



为了实现这个新层次的协作，我们宣布了Moby项目，一个新的用于推进软件容器化运动的开源项目。它提供了数个组件的“乐高组合”，以及一个所有容器爱好者进行试验和交流想法的场所。可以将Moby视为容器系统的“乐高俱乐部”。

Moby由以下部分组成：

1. 一个容器化的后台组件库（比如，一个低层次的构建器、日志工具、数据卷管理、网络、镜像管理、containerd、SwarmKit……）


1. 一个用于将这些组件组装成一个独立容器系统，并协助构建、测试和部署这些组装产物的框架。


1. 一个名为Moby Origin的参考组装品，它是Docker容器系统的开放基础，同时也是使用来自Moby库或其它项目的不同组件的容器系统示例。

Moby是为系统构建者——想构建自己的基于容器的系统的人设计的，而不是使用Docker或者其他容器平台的开发者。Moby项目的参与者可以选择派生自Docker的组件库，也可以“bring your own components（自带组件）” (BYOC)，打包成可以混合搭配其他组件的容器来创建定制化的容器系统。

Docker使用Moby项目作为开放的研发实验室，用于试验、开发新组件并与生态圈就未来容器技术进行合作。我们所有的开源合作都会迁移到Moby项目。Docker现在、将来都一直会是一个可以让你构建、传播、运行容器的开源项目。从用户角度来说，一切都没有发生变化。用户可以继续在docker.com上下载Docker。关于更多信息，请参考[more information about the respective roles of Docker and Moby on the Moby website](https://mobyproject.org/#moby-and-docker)。

请加入我们，通过组件与组装品的合作，一起让软件容器成为主流，扩大我们的生态圈和我们的用户社群到下一个高度。



可以说Moby是Docker之母。通过Moby可以将定制化的组件打包做成一个Docker，而Moby就相当于一个组件仓库与Docker工厂。Docker公司的这一举动可以说也是顺应了潮流，将Docker与操作系统解耦，并且将其以组件组装的形式模块化。可以说今后，操作系统也是Docker容器的一个基础组件。而Moby项目既是一个组件库又是一个框架，为今后组件制作与组装提供了一套规范。

当然，这一切对于使用Docker容器进行应用开发的开发者来说，其实关系并不是太大，甚至可以说目前来看几乎没什么影响。

在[Docker官方仓库](https://github.com/moby/moby)上我们可以看到已经写得很清楚：Moby主要针对的人群是想要组装一个基于容器的系统的人，包括

- 想要定制化Docker构建的hacker
- 想要构建一个容器系统的系统工程师
- 想要将已经存在的容器系统适配到自己环境的 基础设施提供方
- 想要体验最新容器技术的容器爱好者
- 想要在不同系统中测试项目的开源开发者
- 任何对Docker内部原理与如何构建感兴趣的人

但对于如下人群，Moby并不适合：

- 寻求一种简单的在容器中运行应用程序的应用开发者。推荐使用Docker CE。
- 想要一个带有商业支持且开箱即用容器平台的企业IT与开发团队。推荐使用Docker EE。
- 任何对容器感兴趣并且寻求一种简单易学的方式的人。请访问docker.com吧。

参考

- [Docker Github仓库](https://github.com/moby/moby)
- [INTRODUCING MOBY PROJECT](https://blog.docker.com/2017/04/introducing-the-moby-project/)
- [moby-and-docker](https://mobyproject.org/#moby-and-docker)
- [Docker 重磅发布：LinuxKit 和 Moby 开源项目](http://www.oschina.net/news/84015/docker-linuxkit-moby)











