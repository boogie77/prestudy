
// node是一个命令行工具。你可以下载一个tar包，然后编译安装。
// 在terminal中输入“node my_app.js”就可以运行起来你的javascript代码。
// JS都是在V8引擎（这也是Google Chrome这么快的原因）中运行的。
// Node提供了访问文件和文件系统的API。

// 如果你要再同事处理多个事情的时候，Node基本上是一个不错的选择。
// 你有没有写过一堆代码，然后你说：“希望这些代码可以并行执行”？
// 好吧，node中的代码都是并行执行的，除了你的代码。

// 你可以这样理解，把你的代码想象成一个国王，而node就是他得一堆跟班。
// *每一天的开始都会有一个小跟班叫醒这个国王，然后问他需要什么。这个国王给这个跟班一个任务列表，然后去睡回笼觉。
//  这个跟班把任务分配给其他的跟班，然后他们就开始工作了。
// *每当一个跟班完成了一个任务，他就站在国王的寝室外等待汇报。国王每次只让一个跟班进来向他汇报工作。
//  有时，国王会给某个跟班更多地任务去处理。
// *生活很美好，因为国王的跟班们并行执行他分配的任务，但是每次只有一个完成任务的跟班可以汇报。这样国王可以集中注意力。

// 这段代码是要读写一个文件，然后休眠。每次node完成一个任务，回调就会触发。
// 但是每次只可以有一个回调被触发，直到这个回调执行完成。其他回调都需要等待。
// 另外，回调执行的顺序是不能保证一定和调用回调的顺序相同的。
var fs = require('fs');
fs.readFile('treasure-chamber-report.txt', function(report) {
  console.log("oh, look at all my money: "+report);
});
fs.writeFile('letter-to-princess.txt', '...', function() {
  console.log("can't wait to hear back from her!");
});
// Output:
// ---can't wait to hear back from her!
// ---oh, look at all my money: null

// “所以，我不用担心代码同事访问同一个数据结构了？”
// 是额，这就是Node.js的单线程、时间循环的魅力所在了。

// “很好，但是我为什么要用它？”
// *第一个原因就在于效率。在一个web应用中，你主要的时间消耗就在于数据库查询。
//  使用node，你可以同时执行你的全部查询，时间可以压缩到只需要用最慢的查询消耗的时间就可以返回。
// *另一个原因是javascript。你可以用node分享前后端的代码。Javascript已经在成为全站语言的路上了。
//  无论你使用过python、ruby、php还是java，你都会在开发中或多或少的接触过javascript。
// *最后一个原因是速度。V8不是地球最快的动态语言解释器也非常的接近了。
//  我还真是想不出任何语言能像javascript一样如此大刀阔斧的提高执行速度。
//  而且，node的I/O组件非常轻量级，可以最佳的发挥你的系统的I/O能力。

// Node.js显然可以胜任你需要完成的任何工作。但是，如果这事还有deadline的话，你就需要考虑一下的东西了：
// *高并发，低返回时间是否必要。这是node的擅长领域。
// *项目有多大？小的项目还好，大项目的话就需要考虑可用的库，修改bug的资源等的问题了。
