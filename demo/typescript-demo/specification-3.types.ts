// Types --------------------------------------------------------------------// TypeScript adds optional static types to JavaScript.// Types are used to place static constraints on program entities// such as functions, variables, and properties so that compilers and development tools// can offer better verification and assistance during software development.// TypeScript's static compile-time type system closely models// the dynamic run-time type system of JavaScript,// allowing programmers to accurately express the type relationships that are expected to exist// when their programs run and have those assumptions pre-validated by the TypeScript compiler.// TypeScript's type analysis occurs entirely// at compile-time and adds no run-time overhead to program execution.//  Types can be associated with variables through explicit type annotations, such asvar x1: number;// or through implicit type inference, as invar x1 = 1;// 3.1  The Any Type ----------// The Any type is used to represent any JavaScript value.// A value of the Any type supports the same operations as a value in JavaScript// and minimal static type checking is performed for operations on Any values.// Specifically, properties of any name can be accessed through an Any value and// Any values can be called as functions or constructors with any argument list.var x2: any;             // Explicitly typedvar y2;                  // Same as y: anyvar z2: { a; b; };       // Same as z: { a: any; b: any; }function f2(x) {         // Same as f(x: any): void  console.log(x);}// 3.2  Primitive Types ----------// The primitive types are the Number, Boolean, String, Void, Null, and Undefined types// and all user defined enum types.// 3.2.1  The Number Type// The Number primitive type corresponds to the similarly named JavaScript primitive type// and represents double-precision 64-bit format IEEE 754 floating point values.var x3: number;          // Explicitly typedvar y3 = 0;              // Same as y: number = 0var z3 = 123.456;        // Same as z: number = 123.456var s3 = z3.toFixed(2);  // Property of Number interface// 3.2.2  The Boolean Type// The Boolean primitive type corresponds to the similarly named JavaScript primitive type// and represents logical values that are either true or false.var b: boolean;         // Explicitly typedvar yes = true;         // Same as yes: boolean = truevar no = false;         // Same as no: boolean = false// 3.2.3  The String Type// The String primitive type corresponds to the similarly named JavaScript primitive type// and represents sequences of characters stored as Unicode UTF-16 code units.var s: string;             // Explicitly typedvar empty = "";            // Same as empty: string = ""var abc = 'abc';           // Same as abc: string = "abc"var c333 = abc.charAt(2);  // Property of String interface// 3.2.4  The Void Type// The Void type, referenced by the void keyword, represents the absence of a value and// is used as the return type of functions with no return value.// 3.2.5  The Null Type// The Null type corresponds to the similarly named JavaScript primitive type// and is the type of the null literal.var n5: number = null;   // Primitives can be nullvar x5 = null;           // Same as x: any = null// var e5: Null;         // **"Red"**Error, can't reference Null type// 3.2.6  The Undefined Type// The Undefined type corresponds to the similarly named JavaScript primitive type// and is the type of the undefined literal.var n6: number;          // Same as n: number = undefinedvar x6 = undefined;      // Same as x: any = undefined// var e6: Undefined;       // **"Red"**Error, can't reference Undefined type// 3.2.7  Enum Types// Enum types are distinct user defined subtypes of the Number primitive type.// Enum types are declared using enum declarations (section 9.1)// and referenced using type references (section 3.7.2).// 3.2.8  String Literal Types// Specialized signatures (section 3.8.2.4) permit string literals// to be used as types in parameter type annotations.// String literal types are permitted only in that context and nowhere else.// 3.3  Object Types ----------// Object types are composed from properties, call signatures, construct signatures,// and index signatures, collectively called members.// Class and interface type references, array types, tuple types, union types, function types,// and constructor types are all classified as object types.// Multiple constructs in the TypeScript language create object types, including://   Object type literals (section 3.7.3).//   Array type literals (section 3.7.4).//   Tuple type literals (section 3.7.5).//   Function type literals (section 3.7.7).//   Constructor type literals (section 3.7.8).//   Object literals (section 4.5).//   Array literals (section 4.6).//   Function expressions (section 4.9) and function declarations (6.1).//   Constructor function types created by class declarations (section 8.2.5).//   Module instance types created by module declarations (section 10.3).// 3.3.1  Named Type References// Type references (section 3.7.2) to class and interface types are classified as object types.// Type references to generic class and interface types include type arguments that// are substituted for the type parameters of the class or interface// to produce an actual object type.// 3.3.2  Array Types// Array types represent JavaScript arrays with a common element type.// Array types are named type references created from the generic interface type 'Array'// in the global module with the array element type as a type argument.// Array type literals (section 3.7.4) provide a shorthand notation for creating such references.interface Array332<T> {  length: number;  [x: number]: T;  // Other members}var a: string[] = ["hello", "world"];// 3.3.3  Tuple Types// Tuple types represent JavaScript arrays with individually tracked element types.// Tuple types are written using tuple type literals (section 3.7.5).// A tuple type combines a set of numerically named properties with the members of an array type.var t333: [number, string] = [3, "three"];var n333 = t333[0];  // Type of n is numbervar s333 = t333[1];  // Type of s is stringvar i333: number;var x333 = t333[i];  // Type of x is number | stringinterface KeyValuePair<K, V> extends Array<K | V> { 0: K; 1: V; }var x3333: KeyValuePair<number, string> = [10, "ten"];// 3.3.4  Function Types// An object type containing one or more call signatures is said to be a function type.// Function types may be written using function type literals (section 3.7.7)// or by including call signatures in object type literals.// 3.3.5  Constructor Types// An object type containing one or more construct signatures is said to be a constructor type.// Constructor types may be written using constructor type literals (section 3.7.8)// or by including construct signatures in object type literals.// 3.3.6  Members// Every object type is composed from zero or more of the following kinds of members://   Properties, which define the names and types of the properties of objects of the given type.// Property names are unique within their type.//   Call signatures, which define the possible parameter lists and return types associated with// applying call operations to objects of the given type.//   Construct signatures, which define the possible parameter lists and return types associated// with applying the new operator to objects of the given type.//   Index signatures, which define type constraints for properties in the given type.// An object type can have at most one string index signature and one numeric index signature.// 3.4  Union Types ----------// Union types represent values that may have one of several disjoint representations.// A value of a union type A | B is a value that is either of type A or type B.// Union types are written using union type literals (section 3.7.6).var x34: string | number;var test34: boolean;x34 = "hello";            // Okx34 = 42;                 // Ok// x34 = test34;               // **"Red"**Error, boolean not assignablex34 = test34 ? 5 : "five";  // Ok// x34 = test34 ? 0 : false;   // **"Red"**Error, number | boolean not asssignablevar n34 = typeof x34 === "string" ? x34.length : x34;  // Type of n is numberinterface A {  a: string;  b: number;}interface B {  a: number;  b: number;  c: number;}var x340: A | B;var a340 = x340.a;  // a has type string | numbervar b340 = x340.b;  // b has type number// var c340 = x340.c;  // **"Red"**Error, no property c in union type// 3.4.1  Contextual Union Types// When used as a contextual type (section 4.19),// a union type U has those members that are present in any of its constituent types,// with types that are unions of the respective members in the constituent types.// 3.5  Type Parameters ----------// A type parameter represents an actual type that the parameter is bound to in// a generic type reference or a generic function call.// Type parameters have constraints that establish upper bounds// for their actual type arguments.// 3.5.1  Type Parameter Lists// Class, interface, and function declarations may optionally include lists of// type parameters enclosed in < and > brackets.// Type parameters are also permitted in call signatures of object, function,// and constructor type literals.interface G<T, U extends Function> {  f<V extends U>(x: V): V;}// 3.5.2  Type Argument Lists// A type reference (section 3.7.2) to a generic type must include a list of type arguments// enclosed in angle brackets and separated by commas. Similarly,// a call (section 4.12) to a generic function may explicitly// include a type argument list instead of relying on type inference.interface G<T, U extends Function> { }// 3.6  Named Types ----------// Classes, interfaces, enums, and type aliases are named types that are introduced// through class declarations (section 8.1), interface declarations (section 7.1),// enum declarations (9.1), and type alias declarations (section 3.9).// Class and interface types may have type parameters and are then called generic types.// Conversely, named types without type parameters are called non-generic types.interface Pair<T1, T2> { first: T1; second: T2; }// Pair<string, Entity>// { first: string; second: Entity; }// 3.6.1  Instance Types// Each class and interface has an associated actual type known as the instance type.class G361<T> {               // Introduce type parameter T  self: G361<T>;              // Use T as type argument to form instance type  f() {    this.self = this;         // self and this are both of type G<T>  }}// 3.7  Specifying Types ----------// Types are specified either by referencing their keyword or name,// or by writing object type literals, array type literals, tuple type literals,// function type literals, constructor type literals, or type queries.// (string | number)[]// ((x: string) => string) | ((x: number) => number)// 3.7.1  Predefined Types// The any, number, boolean, string, and void keywords reference the Any type and the Number,// Boolean, String, and Void primitive types respectively.// 3.7.2  Type References// A type reference references a named type or type parameter through its name and,// in the case of a generic type, supplies a type argument list.interface A372 { a: string; }interface B372 extends A372 { b: string; }interface C372 extends B372 { c: string; }interface G372<T, U extends B372> {    x: T;    y: U;}var v1: G372<A372, C372>;               // Okvar v2: G372<{ a: string }, C372>;      // Ok, equivalent to G<A, C>// var v3: G372<A372, A372>;            // **"Red"**Error, A not valid argument for Uvar v4: G372<G372<A372, B372>, C372>;   // Okvar v5: G372<any, any>;                 // Ok// var v6: G372<any>;                   // **"Red"**Error, wrong number of arguments// var v7: G372;                        // **"Red"**Error, no argumentsvar v1: {  x: { a: string; }  y: { a: string; b: string; c: string };};// 3.7.3  Object Type Literals// An object type literal defines an object type by specifying the set of members// that are statically considered to be present in instances of the type.// Object type literals can be given names using interface declarations but are otherwise anonymous.// 3.7.4  Array Type Literals// An array type literal is written as an element type followed by an open and close square bracket.// (string | number)[]// (() => string))[]// Array<string | number>// Array<() => string>// 3.7.5  Tuple Type Literals// A tuple type literal is written as a sequence of element types,// separated by commas and enclosed in square brackets.// 3.7.6  Union Type Literals// A union type literal is written as a sequence of types separated by vertical bars.// ((x: string) => string) | ((x: number) => number)// { (x: string): string } | { (x: number): number }// 3.7.7  Function Type Literals// A function type literal specifies the type parameters, regular parameters,// and return type of a call signature.// 3.7.8  Constructor Type Literals// A constructor type literal specifies the type parameters, regular parameters,// and return type of a construct signature.// 3.7.9  Type Queries// A type query obtains the type of an expression.var a379 = { x: 10, y: 20 };var b379: typeof a379;var c379: typeof b379;var d379: typeof c379;var e379: typeof d379;var f379: Array<typeof f>;var g379: { x: typeof g379; };var h379: () => typeof h379;// 3.8  Specifying Members// The members of an object type literal (section 3.7.3) are specified// as a combination of property, call, construct, index, and method signatures.// 3.8.1  Property Signatures// A property signature declares the name and type of a property member.// 3.8.2  Call Signatures// A call signature defines the type parameters, parameter list, and return type associated// with applying a call operation (section 4.12) to an instance of the containing type.// A type may overload call operations by defining multiple different call signatures.// 3.8.2.1  Type Parameters// Type parameters (section 3.5.1) in call signatures provide a mechanism for expressing// the relationships of parameter and return types in call operations.// <T>(x: T): T// <T>(x: T, y: T): T[]// <T, U>(x: T, y: U): { x: T; y: U; }// <T, U>(a: T[], f: (x: T) => U): U[]// 3.8.2.2  Parameter List// A signature's parameter list consists of zero or more required parameters,// followed by zero or more optional parameters, finally followed by an optional rest parameter.// 3.8.2.3  Return Type// If present, a call signature's return type annotation specifies the type of the value// computed and returned by a call operation.// A void return type annotation is used to indicate that a function has no return value.// 3.8.2.4  Specialized Signatures// When a parameter type annotation specifies a string literal type (section 3.2.8),// the containing signature is considered a specialized signature.// Specialized signatures are used to express patterns where specific string values// for some parameters cause the types of other parameters or the function result// to become further specialized. For example, the declarationinterface Document {  createElement(tagName: "div"): HTMLDivElement;  createElement(tagName: "span"): HTMLSpanElement;  createElement(tagName: "canvas"): HTMLCanvasElement;  createElement(tagName: string): HTMLElement;}// 3.8.3  Construct Signatures// A construct signature defines the parameter list and return type associated with// applying the new operator (section 4.11) to an instance of the containing type.// A type may overload new operations by defining multiple construct signatures// with different parameter lists.// 3.8.4  Index Signatures// An index signature defines a type constraint for properties in the containing type.// 3.8.5  Method Signatures// A method signature is shorthand for declaring a property of a function type.// {//     func1(x: number): number;         // Method signature//     func2: (x: number) => number;     // Function type literal//     func3: { (x: number): number };   // Object type literal// }// {//     func4(x: number): number;//     func4(s: string): string;//     func5: {//         (x: number): number;//         (s: string): string;//     };// }// 3.9  Type Aliases ----------// A type alias declaration introduces a type alias in the containing module.type StringOrNumber39 = string | number;type Text39 = string | { text: string };type Coordinates39 = [number, number];// type NameLookup39 = Dictionary<string, Person>;type Callback39 = (data: string) => void;type RecFunc39 = () => RecFunc39;type ObjectStatics39 = typeof Object;interface Point39 {  x: number;  y: number;}type Point391 = {  x: number;  y: number;};// 3.10  Type Relationships// Types in TypeScript have identity, subtype, supertype, and assignment compatibility relationships// as defined in the following sections.// 3.10.1  Apparent Members// The apparent members of a type are the members observed in subtype, supertype,// and assignment compatibility relationships, as well as in the type checking of// property accesses (section 4.10), new operations (section 4.11),// and function calls (section 4.12).var o3101: Object = { x: 10, y: 20 };         // Okvar f3101: Function = (x: number) => x * x;   // Ok// var err3101: Object = { toString: 0 };     // **"Red"**Error// 3.10.2  Type and Member Identityclass C3102<T> { private x: T; }interface X3102 { f(): string; }interface Y3102 { f(): string; }var a3102: C3102<X3102>;var b3102: C3102<Y3102>;// 3.10.3  Subtypes and Supertypes// 3.10.4  Assignment Compatibilityfunction foo(x: { id: number; name?: string; }) { }foo({ id: 1234 });                 // Okfoo({ id: 1234, name: "hello" });  // Ok// foo({ id: 1234, name: false });    // **"Red"**Error, name of wrong type// foo({ name: "hello" });            // **"Red"**Error, id required but missing// 3.10.5  Contextual Signature Instantiation// 3.10.6  Type Inference// 3.10.7  Recursive Typesinterface A { next: A; }interface B { next: C; }interface C { next: D; }interface D { next: B; }// interface List<T> {//     data: T;//     next: List<T>;//     owner: List<List<T>>;// }// 3.11  Widened Types ----------var name = "Steve";var a311 = null;                 // var a: anyvar b311 = undefined;            // var b: anyvar c311 = { x: 0, y: null };     // var c: { x: number, y: any }var d311 = [ null, undefined ];  // var d: any[]