---  
layout: post  
title:  "浏览器的工作原理"  
date:   2015-08-28  
categories: JavaScript  
tagline: JavaScript  
tags : [JavaScript]  
---  


#浏览器的工作原理  

##[1]浏览器的功能：
    将用户选择的web资源呈现出来，需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式，用户用URI来指定所请求资源的位置。  

##[2]浏览器的结构
###[用户接口 user interface]  
    包括地址栏、书签选项、前进后退、刷新、暂停、主页等窗口上除了网页显示区域以外的部分  
###[浏览器引擎 browser engine]  
    查询与操作渲染引擎的接口  
###[渲染引擎 rendering engine]  
    显示用CSS格式化的HTML与图片  
###[网络 network]
    用于网络请求，如HTTP请求，它包括平台无关的接口和各平台独立的实现  
###[UI后端 UI backend]  
    绘制基础元件，如组合框与窗口，提供平台无关的接口，内部使用操作系统的相应实现  
###[JS解释器 javascript interpreter]  
    用于解析执行Javascript代码　　
###[数据存储 data persistence]  
    浏览器需要把所有数据存到硬盘上，如cookies  

##[3]渲染引擎
###firefox使用的是geoko
###safari和chrome使用的是webkit
###[3.1]基本流程:
    渲染引擎首先通过网络获得所请求文档的内容，通常以8k分块的方式完成->解析html构建dom树->构造render树->布局render树->绘制render树  
###[3.2]详细流程:
    渲染引擎开始解析html,并将标签转化为内容树中的dom节点。接着，解析外部css文件及style标签中的样式信息，这些样式信息以及html中的样式信息将被用来构建另一棵树-render树。render树由一些包含css属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。render树构建好之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。  
###[3.3]特点:
    为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树，它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。  
###[3.4]注意:
    webkit中元素的定位称为布局，而gecko中称为回流。

##[4]解析与DOM树构建(parsing and DOM tree construction)
###[4.1]html解析
    [4.1.1]html不能被一般的自顶向下或者自底向上的解析器所解析的原因如下：  
        [1]这门语言本身的宽容特性  
        [2]浏览器对一些常见的非法html有容错机制  
        [3]解析过程是往复的，通常源码不会有解析过程中发生改变，但在html中，脚本标签包含document.write可能添加标签，这说明在解析过程中实际上修改了输入  
        
    [4.1.2]html5规范中描述了html的解析算法:包括两个阶段——符号化及构建树。符号化是词法分析的过程，将输入解析为符号，html的符号包括开始标签、结束标签、属性名及属性值，符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，这样直到处理完所有输入。  
###[4.2]css解析
    [4.2.1]特性：css解析属于上下文无关文法   
       
    [4.2.2]实现：webkit使用flex和bison解析生成器从css语法文件中自动生成解析器。Bison创建一个自底向上的解析器，firefox使用自顶向下解析器。它们都将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。
      
    [4.2.3] 处理脚本及样式表的顺序  
        [4.2.3.1]脚本：web的模式是同步的。开发者可以将脚本标识为defer,以使其不阻塞文档解析，并在文档解析结束后执行。  
        [4.2.3.2]预解析：当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。  
        [4.2.3.3]样式表：脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，firefox在存在样式表还在加载和解析时阻塞所有的脚本，而chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。  

##[5]渲染树构建
###[5.1]DOM树构建
    当DOM树构建完成时，浏览器开始构建另一棵树——渲染树，渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。
###[5.2]实现：
    firefox将渲染树中的元素称为frames，webkit则用renderer或渲染对象来描述这些元素。
###[5.3]渲染
    渲染对象和DOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树，例如head元素另外display属性为none的元素也不会出现在渲染树中，而visibility属性为hidden的元素将出现在渲染树中
###[5.4]创建树的流程：
    [5.4.1]firefox中，表述为一个监听DOM更新的监听器，将frame的创建委派给frame constructor,这个构建器计算样式，并创建一个frame  
    
    [5.4.2]webkit中计算样式生成渲染对象的过程称为attachment,每个dom节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法将节点插入到dom树中  

##[6]布局  
###[6.1]计算位置和大小  
    当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为layout或reflow
###[6.2]全局和增量layout
    [6.2.1]当layout在整棵渲染树触发时，称为全局layout,这可能在下面这些情况下发生:  
        1、一个全局的样式改变影响所有的渲染对象，比如字号的改变
        2、窗口resize
        全局layout一般是同步触发，有些时候，layout会被当作一个初始layout之后的回调，比如滑动条的滑动。  

    [6.2.2]增量layout的过程是异步的
        firefox为增量layout生成了reflow队列，以及一个调度执行这些批处理命令。webkit也有一个计时器用来执行增量layout——遍历树，为dirty状态的渲染对象重新布局。当脚本请求样式信息时，例如offsetHeight，会同步触发增量布局。  
###6.3]折行
    当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent需要折行，parent将创建额外的渲染对象并调用它们的layout  

##[7]绘制 painting  
###[7.1]绘制阶段  
    绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件  
###[7.2]渲染顺序  
    一个块渲染对象的堆栈顺序是：背景色->背景图->border->children->outline
###[7.3]动态变化：
    浏览器总是试着以最小的动作响应一个变化，所以一个元素颜色的变化将只 导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个DOM节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而引起整体的布局和重绘。


#浏览器内核、渲染引擎、js引擎  
##[1]定义  
    浏览器内核分成两部分渲染引擎和js引擎，由于js引擎越来越独立，内核就倾向于只指渲染引擎  
    渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具  
##[2]常见引擎

###渲染引擎：
    firefox使用gecko引擎  
    IE使用Trident引擎  
    chrome\safari\opera使用webkit引擎  
    13年chrome和safari开始使用Blink引擎  
###js引擎：
    老版本IE使用Jscript引擎  
    IE9之后使用Chakra引擎  
    firefox使用monkey系列引擎  
    chrome使用V8引擎。nodeJs其实就是封装了V8引擎  


#URI和URL  

##url和uri的区别  
###[1]定义  
    uri(uniform resource identifier)统一资源标识符,用来唯一的标识一个资源  
    URI抽象结构：[scheme:]scheme-specific-part[#fragment]  
    url(uniform resource locator)统一资源定位器，用来标识一个资源，而且还指明了如何定位这个资源  
###[2]e.g. (以下都是URI)  
    ftp://ftp.a.b.c/a.txt(是URL)  
    ftp.a.com(不是URL)  
    http://www.baidu.com(是URL)  
    tel:15412345678(不是URL)  
###[3]维基百科的翻译  
    URI可以分为URL和URN,URI同时具备locators和names特性  
    URN作用就好像一个人的名字，URL就像一个人的地址  
    换句话说，URN确定了东西的身份，URL提供了找到它的方式
###[4]总结  
    URI是一种语义上的抽象概念。  
    URL是一种具体的URI，提供定位资源的访问机制  


#在浏览器中输入URL按下回车键后发生了什么
    [1]解析URL  
    [2]DNS查询，解析域名，将域名解析为IP地址  
    [3]ARP广播，根据IP地址来解析MAC地址
    [4]分别从应用层到传输层、网络层和数据链路层分别加入各个层的头部封装为包  
    [5]进行三次握手后，客户端与服务器建立连接  
    [6]客服务器向客户端返回数据，浏览器接收到数据  
    [7]浏览器开始渲染页面  

##补充：浏览器渲染页面详解
    [1]由从服务器接收到的html形成DOM  
    [2]样式被加载和解析，形成css对象模型CSSOM  
    [3]DOM和CSSOM创建一个渲染树  
    [4]每个渲染元素来说，它的坐标是经过计算的，进行渲染树的布局layout  
    [5]最后，将布局显示在浏览器窗口，进行渲染树的绘制painting  

##补充：三次握手
    [1]建立连接时，客户端发送syn包到服务器，等待服务器确认  
    [2]服务器收到syn包之后 ，确认客户的SYN，同时自己也发送一个SYN包  
    [3]客户端收到服务器的包之后，向服务器发送确认包，此包发送完毕，客户端和服务器进入连接状态  
    [4]开始传输数据  

##补充：渲染被阻塞之后的猜测预加载
    [1]轻量级的html或css扫描器继续在文档中扫描  
    [2]查找那些将来可能能够用到的资源文件的url  
    [3]在渲染器使用它们之前将其下载下来  


# script标签
##【1】script标签属性  
    [a]async:可选，表示应该立即下载脚本，但不妨碍页面的其他操作。只对外部脚本有效  
    [b]charset:可选，表示通过src属性指定的代码的字符集，大多数浏览器会忽略  
    [c]defer:可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本有效  
    [d]language:已废弃  
    [e]src:表示包含要执行代码的外部文件。这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。  
    [f]type:可选，是language的替代属性，表示编写代码使用的脚本语言的内容类型，也称为MIME类型。考虑到兼容，一般还是text/javascript，若不指定，默认值也是text/javascript  
##【2】script标签使用方式
    两种使用<script>标签的方式：引入外部文件和在页面内嵌入js代码  
    注意：带有src属性的<script>元素不应该在其<script>标签之间再包含额外的js代码，如果包含了嵌入的代码，则只会下载并执行外部脚本，而忽略嵌入的代码
##【3】script标签位置  
    注意1：浏览器在遇到<body>标签时才开始呈现内容。因此，把<script>引用放在<body>元素中页面内容的后面是最佳选择。  
    注意2：最好只包含一个延迟脚本。同时把延迟脚本也放在页面底部。  
    注意3：异步脚本在加载期间不要修改DOM  
##【4】noscript标签
    使用<noscript>标签可以指定在不支持脚本的浏览器中显示的替代内容，但在启用了脚本的情况下，浏览器不会显示<noscript>的任何内容。  
